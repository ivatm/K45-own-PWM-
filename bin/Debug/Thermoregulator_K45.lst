
bin/Debug/Thermoregulator_K45:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .interp       00000019  00010154  00010154  00000154  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .note.ABI-tag 00000020  00010170  00010170  00000170  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .note.gnu.build-id 00000024  00010190  00010190  00000190  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .gnu.hash     00000104  000101b4  000101b4  000001b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .dynsym       00000280  000102b8  000102b8  000002b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dynstr       000001c5  00010538  00010538  00000538  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .gnu.version  00000050  000106fe  000106fe  000006fe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .gnu.version_r 00000060  00010750  00010750  00000750  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .rel.dyn      00000010  000107b0  000107b0  000007b0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rel.plt      00000120  000107c0  000107c0  000007c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .init         0000000c  000108e0  000108e0  000008e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .plt          000001c4  000108ec  000108ec  000008ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         000054a4  00010ab0  00010ab0  00000ab0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .fini         00000008  00015f54  00015f54  00005f54  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .rodata       000005b2  00015f5c  00015f5c  00005f5c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 15 .ARM.exidx    00000008  00016510  00016510  00006510  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .eh_frame     00000004  00016518  00016518  00006518  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 17 .init_array   00000004  00026f00  00026f00  00006f00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 18 .fini_array   00000004  00026f04  00026f04  00006f04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 19 .dynamic      000000f8  00026f08  00026f08  00006f08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 20 .got          000000a0  00027000  00027000  00007000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 21 .data         0000015c  000270a0  000270a0  000070a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 22 .bss          000006f8  00027200  00027200  000071fc  2**3
                  ALLOC
 23 .comment      00000023  00000000  00000000  000071fc  2**0
                  CONTENTS, READONLY
 24 .ARM.attributes 0000002f  00000000  00000000  0000721f  2**0
                  CONTENTS, READONLY
 25 .debug_aranges 000006e0  00000000  00000000  0000724e  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_info   000096e2  00000000  00000000  0000792e  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_abbrev 00001c64  00000000  00000000  00011010  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_line   000046f5  00000000  00000000  00012c74  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_frame  00001654  00000000  00000000  0001736c  2**2
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_str    00002d53  00000000  00000000  000189c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .debug_ranges 000005e0  00000000  00000000  0001b713  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .init:

000108e0 <_init>:
   108e0:	e92d4008 	push	{r3, lr}
   108e4:	eb000080 	bl	10aec <call_weak_fn>
   108e8:	e8bd8008 	pop	{r3, pc}

Disassembly of section .plt:

000108ec <.plt>:
   108ec:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
   108f0:	e59fe004 	ldr	lr, [pc, #4]	; 108fc <.plt+0x10>
   108f4:	e08fe00e 	add	lr, pc, lr
   108f8:	e5bef008 	ldr	pc, [lr, #8]!
   108fc:	00016704 	.word	0x00016704

00010900 <signal@plt>:
   10900:	e28fc600 	add	ip, pc, #0, 12
   10904:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10908:	e5bcf704 	ldr	pc, [ip, #1796]!	; 0x704

0001090c <pthread_mutex_lock@plt>:
   1090c:	e28fc600 	add	ip, pc, #0, 12
   10910:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10914:	e5bcf6fc 	ldr	pc, [ip, #1788]!	; 0x6fc

00010918 <pthread_join@plt>:
   10918:	e28fc600 	add	ip, pc, #0, 12
   1091c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10920:	e5bcf6f4 	ldr	pc, [ip, #1780]!	; 0x6f4

00010924 <exit@plt>:
   10924:	e28fc600 	add	ip, pc, #0, 12
   10928:	e28cca16 	add	ip, ip, #90112	; 0x16000
   1092c:	e5bcf6ec 	ldr	pc, [ip, #1772]!	; 0x6ec

00010930 <printf@plt>:
   10930:	e28fc600 	add	ip, pc, #0, 12
   10934:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10938:	e5bcf6e4 	ldr	pc, [ip, #1764]!	; 0x6e4

0001093c <strerror@plt>:
   1093c:	e28fc600 	add	ip, pc, #0, 12
   10940:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10944:	e5bcf6dc 	ldr	pc, [ip, #1756]!	; 0x6dc

00010948 <puts@plt>:
   10948:	e28fc600 	add	ip, pc, #0, 12
   1094c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10950:	e5bcf6d4 	ldr	pc, [ip, #1748]!	; 0x6d4

00010954 <perror@plt>:
   10954:	e28fc600 	add	ip, pc, #0, 12
   10958:	e28cca16 	add	ip, ip, #90112	; 0x16000
   1095c:	e5bcf6cc 	ldr	pc, [ip, #1740]!	; 0x6cc

00010960 <nanosleep@plt>:
   10960:	e28fc600 	add	ip, pc, #0, 12
   10964:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10968:	e5bcf6c4 	ldr	pc, [ip, #1732]!	; 0x6c4

0001096c <close@plt>:
   1096c:	e28fc600 	add	ip, pc, #0, 12
   10970:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10974:	e5bcf6bc 	ldr	pc, [ip, #1724]!	; 0x6bc

00010978 <fopen@plt>:
   10978:	e28fc600 	add	ip, pc, #0, 12
   1097c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10980:	e5bcf6b4 	ldr	pc, [ip, #1716]!	; 0x6b4

00010984 <abort@plt>:
   10984:	e28fc600 	add	ip, pc, #0, 12
   10988:	e28cca16 	add	ip, ip, #90112	; 0x16000
   1098c:	e5bcf6ac 	ldr	pc, [ip, #1708]!	; 0x6ac

00010990 <clock_gettime@plt>:
   10990:	e28fc600 	add	ip, pc, #0, 12
   10994:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10998:	e5bcf6a4 	ldr	pc, [ip, #1700]!	; 0x6a4

0001099c <mmap@plt>:
   1099c:	e28fc600 	add	ip, pc, #0, 12
   109a0:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109a4:	e5bcf69c 	ldr	pc, [ip, #1692]!	; 0x69c

000109a8 <open@plt>:
   109a8:	e28fc600 	add	ip, pc, #0, 12
   109ac:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109b0:	e5bcf694 	ldr	pc, [ip, #1684]!	; 0x694

000109b4 <fread@plt>:
   109b4:	e28fc600 	add	ip, pc, #0, 12
   109b8:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109bc:	e5bcf68c 	ldr	pc, [ip, #1676]!	; 0x68c

000109c0 <raise@plt>:
   109c0:	e28fc600 	add	ip, pc, #0, 12
   109c4:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109c8:	e5bcf684 	ldr	pc, [ip, #1668]!	; 0x684

000109cc <__ctype_b_loc@plt>:
   109cc:	e28fc600 	add	ip, pc, #0, 12
   109d0:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109d4:	e5bcf67c 	ldr	pc, [ip, #1660]!	; 0x67c

000109d8 <fgets@plt>:
   109d8:	e28fc600 	add	ip, pc, #0, 12
   109dc:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109e0:	e5bcf674 	ldr	pc, [ip, #1652]!	; 0x674

000109e4 <fputc@plt>:
   109e4:	e28fc600 	add	ip, pc, #0, 12
   109e8:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109ec:	e5bcf66c 	ldr	pc, [ip, #1644]!	; 0x66c

000109f0 <fwrite@plt>:
   109f0:	e28fc600 	add	ip, pc, #0, 12
   109f4:	e28cca16 	add	ip, ip, #90112	; 0x16000
   109f8:	e5bcf664 	ldr	pc, [ip, #1636]!	; 0x664

000109fc <memcpy@plt>:
   109fc:	e28fc600 	add	ip, pc, #0, 12
   10a00:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a04:	e5bcf65c 	ldr	pc, [ip, #1628]!	; 0x65c

00010a08 <geteuid@plt>:
   10a08:	e28fc600 	add	ip, pc, #0, 12
   10a0c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a10:	e5bcf654 	ldr	pc, [ip, #1620]!	; 0x654

00010a14 <malloc@plt>:
   10a14:	e28fc600 	add	ip, pc, #0, 12
   10a18:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a1c:	e5bcf64c 	ldr	pc, [ip, #1612]!	; 0x64c

00010a20 <getcwd@plt>:
   10a20:	e28fc600 	add	ip, pc, #0, 12
   10a24:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a28:	e5bcf644 	ldr	pc, [ip, #1604]!	; 0x644

00010a2c <munmap@plt>:
   10a2c:	e28fc600 	add	ip, pc, #0, 12
   10a30:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a34:	e5bcf63c 	ldr	pc, [ip, #1596]!	; 0x63c

00010a38 <fprintf@plt>:
   10a38:	e28fc600 	add	ip, pc, #0, 12
   10a3c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a40:	e5bcf634 	ldr	pc, [ip, #1588]!	; 0x634

00010a44 <fclose@plt>:
   10a44:	e28fc600 	add	ip, pc, #0, 12
   10a48:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a4c:	e5bcf62c 	ldr	pc, [ip, #1580]!	; 0x62c

00010a50 <pthread_create@plt>:
   10a50:	e28fc600 	add	ip, pc, #0, 12
   10a54:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a58:	e5bcf624 	ldr	pc, [ip, #1572]!	; 0x624

00010a5c <strcmp@plt>:
   10a5c:	e28fc600 	add	ip, pc, #0, 12
   10a60:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a64:	e5bcf61c 	ldr	pc, [ip, #1564]!	; 0x61c

00010a68 <__errno_location@plt>:
   10a68:	e28fc600 	add	ip, pc, #0, 12
   10a6c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a70:	e5bcf614 	ldr	pc, [ip, #1556]!	; 0x614

00010a74 <strrchr@plt>:
   10a74:	e28fc600 	add	ip, pc, #0, 12
   10a78:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a7c:	e5bcf60c 	ldr	pc, [ip, #1548]!	; 0x60c

00010a80 <__isoc99_fscanf@plt>:
   10a80:	e28fc600 	add	ip, pc, #0, 12
   10a84:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a88:	e5bcf604 	ldr	pc, [ip, #1540]!	; 0x604

00010a8c <__libc_start_main@plt>:
   10a8c:	e28fc600 	add	ip, pc, #0, 12
   10a90:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10a94:	e5bcf5fc 	ldr	pc, [ip, #1532]!	; 0x5fc

00010a98 <__gmon_start__@plt>:
   10a98:	e28fc600 	add	ip, pc, #0, 12
   10a9c:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10aa0:	e5bcf5f4 	ldr	pc, [ip, #1524]!	; 0x5f4

00010aa4 <pthread_mutex_unlock@plt>:
   10aa4:	e28fc600 	add	ip, pc, #0, 12
   10aa8:	e28cca16 	add	ip, ip, #90112	; 0x16000
   10aac:	e5bcf5ec 	ldr	pc, [ip, #1516]!	; 0x5ec

Disassembly of section .text:

00010ab0 <_start>:
   10ab0:	e3a0b000 	mov	fp, #0
   10ab4:	e3a0e000 	mov	lr, #0
   10ab8:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
   10abc:	e1a0200d 	mov	r2, sp
   10ac0:	e52d2004 	push	{r2}		; (str r2, [sp, #-4]!)
   10ac4:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
   10ac8:	e59fc010 	ldr	ip, [pc, #16]	; 10ae0 <_start+0x30>
   10acc:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)
   10ad0:	e59f000c 	ldr	r0, [pc, #12]	; 10ae4 <_start+0x34>
   10ad4:	e59f300c 	ldr	r3, [pc, #12]	; 10ae8 <_start+0x38>
   10ad8:	ebffffeb 	bl	10a8c <__libc_start_main@plt>
   10adc:	ebffffa8 	bl	10984 <abort@plt>
   10ae0:	00015f50 	.word	0x00015f50
   10ae4:	00010ddc 	.word	0x00010ddc
   10ae8:	00015ef0 	.word	0x00015ef0

00010aec <call_weak_fn>:
   10aec:	e59f3014 	ldr	r3, [pc, #20]	; 10b08 <call_weak_fn+0x1c>
   10af0:	e59f2014 	ldr	r2, [pc, #20]	; 10b0c <call_weak_fn+0x20>
   10af4:	e08f3003 	add	r3, pc, r3
   10af8:	e7932002 	ldr	r2, [r3, r2]
   10afc:	e3520000 	cmp	r2, #0
   10b00:	012fff1e 	bxeq	lr
   10b04:	eaffffe3 	b	10a98 <__gmon_start__@plt>
   10b08:	00016504 	.word	0x00016504
   10b0c:	0000009c 	.word	0x0000009c

00010b10 <deregister_tm_clones>:
   10b10:	e59f0018 	ldr	r0, [pc, #24]	; 10b30 <deregister_tm_clones+0x20>
   10b14:	e59f3018 	ldr	r3, [pc, #24]	; 10b34 <deregister_tm_clones+0x24>
   10b18:	e1530000 	cmp	r3, r0
   10b1c:	012fff1e 	bxeq	lr
   10b20:	e59f3010 	ldr	r3, [pc, #16]	; 10b38 <deregister_tm_clones+0x28>
   10b24:	e3530000 	cmp	r3, #0
   10b28:	012fff1e 	bxeq	lr
   10b2c:	e12fff13 	bx	r3
   10b30:	000271fc 	.word	0x000271fc
   10b34:	000271fc 	.word	0x000271fc
   10b38:	00000000 	.word	0x00000000

00010b3c <register_tm_clones>:
   10b3c:	e59f0024 	ldr	r0, [pc, #36]	; 10b68 <register_tm_clones+0x2c>
   10b40:	e59f1024 	ldr	r1, [pc, #36]	; 10b6c <register_tm_clones+0x30>
   10b44:	e0411000 	sub	r1, r1, r0
   10b48:	e1a01141 	asr	r1, r1, #2
   10b4c:	e0811fa1 	add	r1, r1, r1, lsr #31
   10b50:	e1b010c1 	asrs	r1, r1, #1
   10b54:	012fff1e 	bxeq	lr
   10b58:	e59f3010 	ldr	r3, [pc, #16]	; 10b70 <register_tm_clones+0x34>
   10b5c:	e3530000 	cmp	r3, #0
   10b60:	012fff1e 	bxeq	lr
   10b64:	e12fff13 	bx	r3
   10b68:	000271fc 	.word	0x000271fc
   10b6c:	000271fc 	.word	0x000271fc
   10b70:	00000000 	.word	0x00000000

00010b74 <__do_global_dtors_aux>:
   10b74:	e92d4010 	push	{r4, lr}
   10b78:	e59f4018 	ldr	r4, [pc, #24]	; 10b98 <__do_global_dtors_aux+0x24>
   10b7c:	e5d43000 	ldrb	r3, [r4]
   10b80:	e3530000 	cmp	r3, #0
   10b84:	18bd8010 	popne	{r4, pc}
   10b88:	ebffffe0 	bl	10b10 <deregister_tm_clones>
   10b8c:	e3a03001 	mov	r3, #1
   10b90:	e5c43000 	strb	r3, [r4]
   10b94:	e8bd8010 	pop	{r4, pc}
   10b98:	00027204 	.word	0x00027204

00010b9c <frame_dummy>:
   10b9c:	eaffffe6 	b	10b3c <register_tm_clones>

00010ba0 <ADC_service>:
/* ===============================================================================
 * The thread for all measurements.
 * The external library for ADC plate ADS1256 is used
 * =============================================================================== */
void* ADC_service()
{
   10ba0:	e92d4800 	push	{fp, lr}
   10ba4:	e28db004 	add	fp, sp, #4

   while(1)
   {

      //fastADCinterrogation();
      updateCurrentVoltages();
   10ba8:	eb000d5d 	bl	14124 <updateCurrentVoltages>

      // Delay is necessary for turn the time for other
      delay(1000);
   10bac:	e3a00ffa 	mov	r0, #1000	; 0x3e8
   10bb0:	eb0001c7 	bl	112d4 <bcm2835_delay>
      updateCurrentVoltages();
   10bb4:	eafffffb 	b	10ba8 <ADC_service+0x8>

00010bb8 <Indication_service>:
/* ===============================================================================
 * The thread for all Input/Output user interfaces.
 *
 * =============================================================================== */
void* Indication_service()
{
   10bb8:	e92d4800 	push	{fp, lr}
   10bbc:	e28db004 	add	fp, sp, #4

   while(1)
   {

      KeyboardProcess();
   10bc0:	eb0008f4 	bl	12f98 <KeyboardProcess>
      OutCurrentVariable();
   10bc4:	eb00082e 	bl	12c84 <OutCurrentVariable>


      delay(200);
   10bc8:	e3a000c8 	mov	r0, #200	; 0xc8
   10bcc:	eb0001c0 	bl	112d4 <bcm2835_delay>
      KeyboardProcess();
   10bd0:	eafffffa 	b	10bc0 <Indication_service+0x8>

00010bd4 <TemperatureRegulator_service>:
/* ===============================================================================
 * The thread for temperature regulator.
 *
 * =============================================================================== */
void* TemperatureRegulator_service()
{
   10bd4:	e92d4800 	push	{fp, lr}
   10bd8:	e28db004 	add	fp, sp, #4
   iniTemperaturController();
   10bdc:	eb001059 	bl	14d48 <iniTemperaturController>

   while(1)
   {
      CalculRegulator();
   10be0:	eb0010c3 	bl	14ef4 <CalculRegulator>

      #ifdef SCANNING
         AutoSettingTemperature();
   10be4:	eb0011d4 	bl	1533c <AutoSettingTemperature>
      #endif
      delay(mNormTime(kTemperaturControlPeriod));
   10be8:	e3a00064 	mov	r0, #100	; 0x64
   10bec:	eb0001b8 	bl	112d4 <bcm2835_delay>
      CalculRegulator();
   10bf0:	eafffffa 	b	10be0 <TemperatureRegulator_service+0xc>

00010bf4 <PowerEquipment_service>:
/* ===============================================================================
 * The thread for power switches.
 *
 * =============================================================================== */
void* PowerEquipment_service()
{
   10bf4:	e92d4800 	push	{fp, lr}
   10bf8:	e28db004 	add	fp, sp, #4

   while(1)
   {
      executeModulControl();
   10bfc:	eb000d17 	bl	14060 <executeModulControl>
      delay(2000);
   10c00:	e3a00e7d 	mov	r0, #2000	; 0x7d0
   10c04:	eb0001b2 	bl	112d4 <bcm2835_delay>
      executeModulControl();
   10c08:	eafffffb 	b	10bfc <PowerEquipment_service+0x8>

00010c0c <Inits>:
   return NULL;
}


uint16_t Inits(void)
{
   10c0c:	e92d4800 	push	{fp, lr}
   10c10:	e28db004 	add	fp, sp, #4

   if (!K45GlobalInit())
   10c14:	eb00003a 	bl	10d04 <K45GlobalInit>
   10c18:	e1a03000 	mov	r3, r0
   10c1c:	e3530000 	cmp	r3, #0
   10c20:	1a000003 	bne	10c34 <Inits+0x28>
   {
      printf("Some thing goes wrong on init...\n");
   10c24:	e59f00b4 	ldr	r0, [pc, #180]	; 10ce0 <Inits+0xd4>
   10c28:	ebffff46 	bl	10948 <puts@plt>
      return(FALSE);
   10c2c:	e3a03000 	mov	r3, #0
   10c30:	ea000028 	b	10cd8 <Inits+0xcc>
   }

   pthread_create(&ADC_Thread,           NULL, ADC_service, NULL);
   10c34:	e3a03000 	mov	r3, #0
   10c38:	e59f20a4 	ldr	r2, [pc, #164]	; 10ce4 <Inits+0xd8>
   10c3c:	e3a01000 	mov	r1, #0
   10c40:	e59f00a0 	ldr	r0, [pc, #160]	; 10ce8 <Inits+0xdc>
   10c44:	ebffff81 	bl	10a50 <pthread_create@plt>
   pthread_create(&Indication_Thread,    NULL, Indication_service, NULL);
   10c48:	e3a03000 	mov	r3, #0
   10c4c:	e59f2098 	ldr	r2, [pc, #152]	; 10cec <Inits+0xe0>
   10c50:	e3a01000 	mov	r1, #0
   10c54:	e59f0094 	ldr	r0, [pc, #148]	; 10cf0 <Inits+0xe4>
   10c58:	ebffff7c 	bl	10a50 <pthread_create@plt>
   pthread_create(&TemperatureRegulator, NULL, TemperatureRegulator_service, NULL);
   10c5c:	e3a03000 	mov	r3, #0
   10c60:	e59f208c 	ldr	r2, [pc, #140]	; 10cf4 <Inits+0xe8>
   10c64:	e3a01000 	mov	r1, #0
   10c68:	e59f0088 	ldr	r0, [pc, #136]	; 10cf8 <Inits+0xec>
   10c6c:	ebffff77 	bl	10a50 <pthread_create@plt>
   pthread_create(&PowerEquipment,       NULL, PowerEquipment_service, NULL);
   10c70:	e3a03000 	mov	r3, #0
   10c74:	e59f2080 	ldr	r2, [pc, #128]	; 10cfc <Inits+0xf0>
   10c78:	e3a01000 	mov	r1, #0
   10c7c:	e59f007c 	ldr	r0, [pc, #124]	; 10d00 <Inits+0xf4>
   10c80:	ebffff72 	bl	10a50 <pthread_create@plt>

   pthread_join( ADC_Thread,           NULL);
   10c84:	e59f305c 	ldr	r3, [pc, #92]	; 10ce8 <Inits+0xdc>
   10c88:	e5933000 	ldr	r3, [r3]
   10c8c:	e3a01000 	mov	r1, #0
   10c90:	e1a00003 	mov	r0, r3
   10c94:	ebffff1f 	bl	10918 <pthread_join@plt>
   pthread_join( Indication_Thread,    NULL);
   10c98:	e59f3050 	ldr	r3, [pc, #80]	; 10cf0 <Inits+0xe4>
   10c9c:	e5933000 	ldr	r3, [r3]
   10ca0:	e3a01000 	mov	r1, #0
   10ca4:	e1a00003 	mov	r0, r3
   10ca8:	ebffff1a 	bl	10918 <pthread_join@plt>
   pthread_join( TemperatureRegulator, NULL);
   10cac:	e59f3044 	ldr	r3, [pc, #68]	; 10cf8 <Inits+0xec>
   10cb0:	e5933000 	ldr	r3, [r3]
   10cb4:	e3a01000 	mov	r1, #0
   10cb8:	e1a00003 	mov	r0, r3
   10cbc:	ebffff15 	bl	10918 <pthread_join@plt>
   pthread_join( PowerEquipment,       NULL);
   10cc0:	e59f3038 	ldr	r3, [pc, #56]	; 10d00 <Inits+0xf4>
   10cc4:	e5933000 	ldr	r3, [r3]
   10cc8:	e3a01000 	mov	r1, #0
   10ccc:	e1a00003 	mov	r0, r3
   10cd0:	ebffff10 	bl	10918 <pthread_join@plt>

   return(TRUE);
   10cd4:	e3a03001 	mov	r3, #1
}
   10cd8:	e1a00003 	mov	r0, r3
   10cdc:	e8bd8800 	pop	{fp, pc}
   10ce0:	00015f5c 	.word	0x00015f5c
   10ce4:	00010ba0 	.word	0x00010ba0
   10ce8:	0002727c 	.word	0x0002727c
   10cec:	00010bb8 	.word	0x00010bb8
   10cf0:	00027278 	.word	0x00027278
   10cf4:	00010bd4 	.word	0x00010bd4
   10cf8:	00027280 	.word	0x00027280
   10cfc:	00010bf4 	.word	0x00010bf4
   10d00:	00027284 	.word	0x00027284

00010d04 <K45GlobalInit>:

uint16_t K45GlobalInit(void)
{
   10d04:	e92d4800 	push	{fp, lr}
   10d08:	e28db004 	add	fp, sp, #4
   10d0c:	e24dd008 	sub	sp, sp, #8
   uint16_t Result;
   boolean SPIconfigured; // Common SPI interface for Indicator and RTmodule

   SPIconfigured = periferal_SPI1_Init();
   10d10:	eb0005eb 	bl	124c4 <periferal_SPI1_Init>
   10d14:	e1a03000 	mov	r3, r0
   10d18:	e14b30b8 	strh	r3, [fp, #-8]

 //  bcm2835_gpio_set(IND_CS_PIN);
   bcm2835_gpio_set(MODUL_ISP_PIN);
   10d1c:	e3a00019 	mov	r0, #25
   10d20:	eb000113 	bl	11174 <bcm2835_gpio_set>

   if (SPIconfigured)
   10d24:	e15b30b8 	ldrh	r3, [fp, #-8]
   10d28:	e3530000 	cmp	r3, #0
   10d2c:	0a000006 	beq	10d4c <K45GlobalInit+0x48>
   {
      Result = TRUE;
   10d30:	e3a03001 	mov	r3, #1
   10d34:	e14b30b6 	strh	r3, [fp, #-6]
      Result = FALSE;
      printf("SPI can`t configure ...\n");
      return Result;
   }

   if (ADC_Init())
   10d38:	eb000cd7 	bl	1409c <ADC_Init>
   10d3c:	e1a03000 	mov	r3, r0
   10d40:	e3530000 	cmp	r3, #0
   10d44:	0a000009 	beq	10d70 <K45GlobalInit+0x6c>
   10d48:	ea000005 	b	10d64 <K45GlobalInit+0x60>
      Result = FALSE;
   10d4c:	e3a03000 	mov	r3, #0
   10d50:	e14b30b6 	strh	r3, [fp, #-6]
      printf("SPI can`t configure ...\n");
   10d54:	e59f0070 	ldr	r0, [pc, #112]	; 10dcc <K45GlobalInit+0xc8>
   10d58:	ebfffefa 	bl	10948 <puts@plt>
      return Result;
   10d5c:	e15b30b6 	ldrh	r3, [fp, #-6]
   10d60:	ea000016 	b	10dc0 <K45GlobalInit+0xbc>
   {
      Result = TRUE;
   10d64:	e3a03001 	mov	r3, #1
   10d68:	e14b30b6 	strh	r3, [fp, #-6]
   10d6c:	ea000003 	b	10d80 <K45GlobalInit+0x7c>
   }
   else
   {
      printf("allocation TM1638 wrong\n");
   10d70:	e59f0058 	ldr	r0, [pc, #88]	; 10dd0 <K45GlobalInit+0xcc>
   10d74:	ebfffef3 	bl	10948 <puts@plt>
      Result = FALSE;
   10d78:	e3a03000 	mov	r3, #0
   10d7c:	e14b30b6 	strh	r3, [fp, #-6]
   }

   // !! It is GPIO Numbers - not pins
   pTM1638board = tm1638_alloc(IND_DATA_PIN, IND_CLOCK_PIN, IND_STROBE_PIN);
   10d80:	e3a0200d 	mov	r2, #13
   10d84:	e3a01006 	mov	r1, #6
   10d88:	e3a00005 	mov	r0, #5
   10d8c:	eb000981 	bl	13398 <tm1638_alloc>
   10d90:	e1a02000 	mov	r2, r0
   10d94:	e59f3038 	ldr	r3, [pc, #56]	; 10dd4 <K45GlobalInit+0xd0>
   10d98:	e5832000 	str	r2, [r3]
   if (!pTM1638board)
   10d9c:	e59f3030 	ldr	r3, [pc, #48]	; 10dd4 <K45GlobalInit+0xd0>
   10da0:	e5933000 	ldr	r3, [r3]
   10da4:	e3530000 	cmp	r3, #0
   10da8:	1a000003 	bne	10dbc <K45GlobalInit+0xb8>
     {
       printf("Unable to allocate TM1638\n");
   10dac:	e59f0024 	ldr	r0, [pc, #36]	; 10dd8 <K45GlobalInit+0xd4>
   10db0:	ebfffee4 	bl	10948 <puts@plt>
       return FALSE;
   10db4:	e3a03000 	mov	r3, #0
   10db8:	ea000000 	b	10dc0 <K45GlobalInit+0xbc>
     }

   return Result;
   10dbc:	e15b30b6 	ldrh	r3, [fp, #-6]
}
   10dc0:	e1a00003 	mov	r0, r3
   10dc4:	e24bd004 	sub	sp, fp, #4
   10dc8:	e8bd8800 	pop	{fp, pc}
   10dcc:	00015f80 	.word	0x00015f80
   10dd0:	00015f98 	.word	0x00015f98
   10dd4:	0002728c 	.word	0x0002728c
   10dd8:	00015fb0 	.word	0x00015fb0

00010ddc <main>:


int main(void)
{
   10ddc:	e92d4800 	push	{fp, lr}
   10de0:	e28db004 	add	fp, sp, #4

    Inits();
   10de4:	ebffff88 	bl	10c0c <Inits>

   return 0;
   10de8:	e3a03000 	mov	r3, #0
}
   10dec:	e1a00003 	mov	r0, r3
   10df0:	e8bd8800 	pop	{fp, pc}

00010df4 <DEV_GPIOConfig>:
function:   Initialization pin
parameter:
Info:
******************************************************************************/
static void DEV_GPIOConfig(void)
{
   10df4:	e92d4800 	push	{fp, lr}
   10df8:	e28db004 	add	fp, sp, #4
   //output
   bcm2835_gpio_fsel(DEV_RST_PIN, BCM2835_GPIO_FSEL_OUTP);
   10dfc:	e3a01001 	mov	r1, #1
   10e00:	e3a00012 	mov	r0, #18
   10e04:	eb0000a9 	bl	110b0 <bcm2835_gpio_fsel>
   bcm2835_gpio_fsel(DEV_CS_PIN, BCM2835_GPIO_FSEL_OUTP);
   10e08:	e3a01001 	mov	r1, #1
   10e0c:	e3a00016 	mov	r0, #22
   10e10:	eb0000a6 	bl	110b0 <bcm2835_gpio_fsel>

   //intput
   bcm2835_gpio_fsel(DEV_DRDY_PIN,BCM2835_GPIO_FSEL_INPT);
   10e14:	e3a01000 	mov	r1, #0
   10e18:	e3a00011 	mov	r0, #17
   10e1c:	eb0000a3 	bl	110b0 <bcm2835_gpio_fsel>
}
   10e20:	e1a00000 	nop			; (mov r0, r0)
   10e24:	e8bd8800 	pop	{fp, pc}

00010e28 <DEV_ModuleInit>:
function:   Module Initialize, the BCM2835 library and initialize the pins, SPI protocol
parameter:
Info:
******************************************************************************/
UBYTE DEV_ModuleInit(void)
{
   10e28:	e92d4800 	push	{fp, lr}
   10e2c:	e28db004 	add	fp, sp, #4
    if(!bcm2835_init())
   10e30:	eb0003df 	bl	11db4 <bcm2835_init>
   10e34:	e1a03000 	mov	r3, r0
   10e38:	e3530000 	cmp	r3, #0
   10e3c:	1a000003 	bne	10e50 <DEV_ModuleInit+0x28>
    {
        printf("bcm2835 init failed  !!! \r\n");
   10e40:	e59f0034 	ldr	r0, [pc, #52]	; 10e7c <DEV_ModuleInit+0x54>
   10e44:	ebfffebf 	bl	10948 <puts@plt>
        return 1;
   10e48:	e3a03001 	mov	r3, #1
   10e4c:	ea000008 	b	10e74 <DEV_ModuleInit+0x4c>
    else
    {
       // printf("bcm2835 init success !!! \r\n");
    }

   DEV_GPIOConfig();
   10e50:	ebffffe7 	bl	10df4 <DEV_GPIOConfig>

    bcm2835_spi_begin();                                         //Start spi interface, set spi pin for the reuse function
   10e54:	eb0001ab 	bl	11508 <bcm2835_spi_begin>
    bcm2835_spi_setBitOrder(BCM2835_SPI_BIT_ORDER_MSBFIRST);     //High first transmission
   10e58:	e3a00001 	mov	r0, #1
   10e5c:	eb0001e2 	bl	115ec <bcm2835_spi_setBitOrder>
    bcm2835_spi_setDataMode(BCM2835_SPI_MODE1);                  //spi mode 0
   10e60:	e3a00001 	mov	r0, #1
   10e64:	eb0001fe 	bl	11664 <bcm2835_spi_setDataMode>
    bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_65536);  //Frequency
   10e68:	e3a00000 	mov	r0, #0
   10e6c:	eb0001eb 	bl	11620 <bcm2835_spi_setClockDivider>
    return 0;
   10e70:	e3a03000 	mov	r3, #0
}
   10e74:	e1a00003 	mov	r0, r3
   10e78:	e8bd8800 	pop	{fp, pc}
   10e7c:	00015fcc 	.word	0x00015fcc

00010e80 <DEV_ModuleExit>:
function:   Module exits, closes SPI and BCM2835 library
parameter:
Info:
******************************************************************************/
void DEV_ModuleExit(void)
{
   10e80:	e92d4800 	push	{fp, lr}
   10e84:	e28db004 	add	fp, sp, #4
    bcm2835_spi_end();
   10e88:	eb0001c4 	bl	115a0 <bcm2835_spi_end>
    bcm2835_close();
   10e8c:	eb000524 	bl	12324 <bcm2835_close>
}
   10e90:	e1a00000 	nop			; (mov r0, r0)
   10e94:	e8bd8800 	pop	{fp, pc}

00010e98 <bcm2835_correct_order>:
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
};

static uint8_t bcm2835_correct_order(uint8_t b)
{
   10e98:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   10e9c:	e28db000 	add	fp, sp, #0
   10ea0:	e24dd00c 	sub	sp, sp, #12
   10ea4:	e1a03000 	mov	r3, r0
   10ea8:	e54b3005 	strb	r3, [fp, #-5]
    if (bcm2835_spi_bit_order == BCM2835_SPI_BIT_ORDER_LSBFIRST)
   10eac:	e59f302c 	ldr	r3, [pc, #44]	; 10ee0 <bcm2835_correct_order+0x48>
   10eb0:	e5d33000 	ldrb	r3, [r3]
   10eb4:	e3530000 	cmp	r3, #0
   10eb8:	1a000003 	bne	10ecc <bcm2835_correct_order+0x34>
	return bcm2835_byte_reverse_table[b];
   10ebc:	e55b3005 	ldrb	r3, [fp, #-5]
   10ec0:	e59f201c 	ldr	r2, [pc, #28]	; 10ee4 <bcm2835_correct_order+0x4c>
   10ec4:	e7d23003 	ldrb	r3, [r2, r3]
   10ec8:	ea000000 	b	10ed0 <bcm2835_correct_order+0x38>
    else
	return b;
   10ecc:	e55b3005 	ldrb	r3, [fp, #-5]
}
   10ed0:	e1a00003 	mov	r0, r3
   10ed4:	e28bd000 	add	sp, fp, #0
   10ed8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   10edc:	e12fff1e 	bx	lr
   10ee0:	000270d4 	.word	0x000270d4
   10ee4:	000270d8 	.word	0x000270d8

00010ee8 <bcm2835_peri_read>:

/* Read with memory barriers from peripheral
 *
 */
uint32_t bcm2835_peri_read(volatile uint32_t* paddr)
{
   10ee8:	e92d4800 	push	{fp, lr}
   10eec:	e28db004 	add	fp, sp, #4
   10ef0:	e24dd010 	sub	sp, sp, #16
   10ef4:	e50b0010 	str	r0, [fp, #-16]
    uint32_t ret;
    if (debug)
   10ef8:	e59f3040 	ldr	r3, [pc, #64]	; 10f40 <bcm2835_peri_read+0x58>
   10efc:	e5d33000 	ldrb	r3, [r3]
   10f00:	e3530000 	cmp	r3, #0
   10f04:	0a000004 	beq	10f1c <bcm2835_peri_read+0x34>
    {
		printf("bcm2835_peri_read  paddr %p\n", (void *) paddr);
   10f08:	e51b1010 	ldr	r1, [fp, #-16]
   10f0c:	e59f0030 	ldr	r0, [pc, #48]	; 10f44 <bcm2835_peri_read+0x5c>
   10f10:	ebfffe86 	bl	10930 <printf@plt>
		return 0;
   10f14:	e3a03000 	mov	r3, #0
   10f18:	ea000005 	b	10f34 <bcm2835_peri_read+0x4c>
    }
    else
    {
       __sync_synchronize();
   10f1c:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
       ret = *paddr;
   10f20:	e51b3010 	ldr	r3, [fp, #-16]
   10f24:	e5933000 	ldr	r3, [r3]
   10f28:	e50b3008 	str	r3, [fp, #-8]
       __sync_synchronize();
   10f2c:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
       return ret;
   10f30:	e51b3008 	ldr	r3, [fp, #-8]
    }
}
   10f34:	e1a00003 	mov	r0, r3
   10f38:	e24bd004 	sub	sp, fp, #4
   10f3c:	e8bd8800 	pop	{fp, pc}
   10f40:	00027205 	.word	0x00027205
   10f44:	00015fe8 	.word	0x00015fe8

00010f48 <bcm2835_peri_read_nb>:
 * will follow.  The sequence must terminate with memory barrier
 * before any read or write to another peripheral can occur.
 * The MB can be explicit, or one of the barrier read/write calls.
 */
uint32_t bcm2835_peri_read_nb(volatile uint32_t* paddr)
{
   10f48:	e92d4800 	push	{fp, lr}
   10f4c:	e28db004 	add	fp, sp, #4
   10f50:	e24dd008 	sub	sp, sp, #8
   10f54:	e50b0008 	str	r0, [fp, #-8]
    if (debug)
   10f58:	e59f3030 	ldr	r3, [pc, #48]	; 10f90 <bcm2835_peri_read_nb+0x48>
   10f5c:	e5d33000 	ldrb	r3, [r3]
   10f60:	e3530000 	cmp	r3, #0
   10f64:	0a000004 	beq	10f7c <bcm2835_peri_read_nb+0x34>
    {
	printf("bcm2835_peri_read_nb  paddr %p\n", paddr);
   10f68:	e51b1008 	ldr	r1, [fp, #-8]
   10f6c:	e59f0020 	ldr	r0, [pc, #32]	; 10f94 <bcm2835_peri_read_nb+0x4c>
   10f70:	ebfffe6e 	bl	10930 <printf@plt>
	return 0;
   10f74:	e3a03000 	mov	r3, #0
   10f78:	ea000001 	b	10f84 <bcm2835_peri_read_nb+0x3c>
    }
    else
    {
	return *paddr;
   10f7c:	e51b3008 	ldr	r3, [fp, #-8]
   10f80:	e5933000 	ldr	r3, [r3]
    }
}
   10f84:	e1a00003 	mov	r0, r3
   10f88:	e24bd004 	sub	sp, fp, #4
   10f8c:	e8bd8800 	pop	{fp, pc}
   10f90:	00027205 	.word	0x00027205
   10f94:	00016008 	.word	0x00016008

00010f98 <bcm2835_peri_write>:

/* Write with memory barriers to peripheral
 */

void bcm2835_peri_write(volatile uint32_t* paddr, uint32_t value)
{
   10f98:	e92d4800 	push	{fp, lr}
   10f9c:	e28db004 	add	fp, sp, #4
   10fa0:	e24dd008 	sub	sp, sp, #8
   10fa4:	e50b0008 	str	r0, [fp, #-8]
   10fa8:	e50b100c 	str	r1, [fp, #-12]
    if (debug)
   10fac:	e59f303c 	ldr	r3, [pc, #60]	; 10ff0 <bcm2835_peri_write+0x58>
   10fb0:	e5d33000 	ldrb	r3, [r3]
   10fb4:	e3530000 	cmp	r3, #0
   10fb8:	0a000004 	beq	10fd0 <bcm2835_peri_write+0x38>
    {
	printf("bcm2835_peri_write paddr %p, value %08X\n", paddr, value);
   10fbc:	e51b200c 	ldr	r2, [fp, #-12]
   10fc0:	e51b1008 	ldr	r1, [fp, #-8]
   10fc4:	e59f0028 	ldr	r0, [pc, #40]	; 10ff4 <bcm2835_peri_write+0x5c>
   10fc8:	ebfffe58 	bl	10930 <printf@plt>
    {
        __sync_synchronize();
        *paddr = value;
        __sync_synchronize();
    }
}
   10fcc:	ea000004 	b	10fe4 <bcm2835_peri_write+0x4c>
        __sync_synchronize();
   10fd0:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
        *paddr = value;
   10fd4:	e51b3008 	ldr	r3, [fp, #-8]
   10fd8:	e51b200c 	ldr	r2, [fp, #-12]
   10fdc:	e5832000 	str	r2, [r3]
        __sync_synchronize();
   10fe0:	ee070fba 	mcr	15, 0, r0, cr7, cr10, {5}
}
   10fe4:	e1a00000 	nop			; (mov r0, r0)
   10fe8:	e24bd004 	sub	sp, fp, #4
   10fec:	e8bd8800 	pop	{fp, pc}
   10ff0:	00027205 	.word	0x00027205
   10ff4:	00016028 	.word	0x00016028

00010ff8 <bcm2835_peri_write_nb>:

/* write to peripheral without the write barrier */
void bcm2835_peri_write_nb(volatile uint32_t* paddr, uint32_t value)
{
   10ff8:	e92d4800 	push	{fp, lr}
   10ffc:	e28db004 	add	fp, sp, #4
   11000:	e24dd008 	sub	sp, sp, #8
   11004:	e50b0008 	str	r0, [fp, #-8]
   11008:	e50b100c 	str	r1, [fp, #-12]
    if (debug)
   1100c:	e59f3034 	ldr	r3, [pc, #52]	; 11048 <bcm2835_peri_write_nb+0x50>
   11010:	e5d33000 	ldrb	r3, [r3]
   11014:	e3530000 	cmp	r3, #0
   11018:	0a000004 	beq	11030 <bcm2835_peri_write_nb+0x38>
    {
	printf("bcm2835_peri_write_nb paddr %p, value %08X\n",
   1101c:	e51b200c 	ldr	r2, [fp, #-12]
   11020:	e51b1008 	ldr	r1, [fp, #-8]
   11024:	e59f0020 	ldr	r0, [pc, #32]	; 1104c <bcm2835_peri_write_nb+0x54>
   11028:	ebfffe40 	bl	10930 <printf@plt>
    }
    else
    {
	*paddr = value;
    }
}
   1102c:	ea000002 	b	1103c <bcm2835_peri_write_nb+0x44>
	*paddr = value;
   11030:	e51b3008 	ldr	r3, [fp, #-8]
   11034:	e51b200c 	ldr	r2, [fp, #-12]
   11038:	e5832000 	str	r2, [r3]
}
   1103c:	e1a00000 	nop			; (mov r0, r0)
   11040:	e24bd004 	sub	sp, fp, #4
   11044:	e8bd8800 	pop	{fp, pc}
   11048:	00027205 	.word	0x00027205
   1104c:	00016054 	.word	0x00016054

00011050 <bcm2835_peri_set_bits>:

/* Set/clear only the bits in value covered by the mask
 * This is not atomic - can be interrupted.
 */
void bcm2835_peri_set_bits(volatile uint32_t* paddr, uint32_t value, uint32_t mask)
{
   11050:	e92d4800 	push	{fp, lr}
   11054:	e28db004 	add	fp, sp, #4
   11058:	e24dd018 	sub	sp, sp, #24
   1105c:	e50b0010 	str	r0, [fp, #-16]
   11060:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
   11064:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    uint32_t v = bcm2835_peri_read(paddr);
   11068:	e51b0010 	ldr	r0, [fp, #-16]
   1106c:	ebffff9d 	bl	10ee8 <bcm2835_peri_read>
   11070:	e50b0008 	str	r0, [fp, #-8]
    v = (v & ~mask) | (value & mask);
   11074:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11078:	e1e02003 	mvn	r2, r3
   1107c:	e51b3008 	ldr	r3, [fp, #-8]
   11080:	e0022003 	and	r2, r2, r3
   11084:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
   11088:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   1108c:	e0033001 	and	r3, r3, r1
   11090:	e1823003 	orr	r3, r2, r3
   11094:	e50b3008 	str	r3, [fp, #-8]
    bcm2835_peri_write(paddr, v);
   11098:	e51b1008 	ldr	r1, [fp, #-8]
   1109c:	e51b0010 	ldr	r0, [fp, #-16]
   110a0:	ebffffbc 	bl	10f98 <bcm2835_peri_write>
}
   110a4:	e1a00000 	nop			; (mov r0, r0)
   110a8:	e24bd004 	sub	sp, fp, #4
   110ac:	e8bd8800 	pop	{fp, pc}

000110b0 <bcm2835_gpio_fsel>:
//
// So the 3 bits for port X are:
//      X / 10 + ((X % 10) * 3)
*/
void bcm2835_gpio_fsel(uint8_t pin, uint8_t mode)
{
   110b0:	e92d4800 	push	{fp, lr}
   110b4:	e28db004 	add	fp, sp, #4
   110b8:	e24dd018 	sub	sp, sp, #24
   110bc:	e1a03000 	mov	r3, r0
   110c0:	e1a02001 	mov	r2, r1
   110c4:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
   110c8:	e1a03002 	mov	r3, r2
   110cc:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
    /* Function selects are 10 pins per 32 bit word, 3 bits per pin */
    volatile uint32_t* paddr = bcm2835_gpio + BCM2835_GPFSEL0/4 + (pin/10);
   110d0:	e59f3094 	ldr	r3, [pc, #148]	; 1116c <bcm2835_gpio_fsel+0xbc>
   110d4:	e5932000 	ldr	r2, [r3]
   110d8:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
   110dc:	e59f108c 	ldr	r1, [pc, #140]	; 11170 <bcm2835_gpio_fsel+0xc0>
   110e0:	e0831391 	umull	r1, r3, r1, r3
   110e4:	e1a031a3 	lsr	r3, r3, #3
   110e8:	e6ef3073 	uxtb	r3, r3
   110ec:	e1a03103 	lsl	r3, r3, #2
   110f0:	e0823003 	add	r3, r2, r3
   110f4:	e50b3008 	str	r3, [fp, #-8]
    uint8_t   shift = (pin % 10) * 3;
   110f8:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
   110fc:	e59f306c 	ldr	r3, [pc, #108]	; 11170 <bcm2835_gpio_fsel+0xc0>
   11100:	e0831293 	umull	r1, r3, r3, r2
   11104:	e1a011a3 	lsr	r1, r3, #3
   11108:	e1a03001 	mov	r3, r1
   1110c:	e1a03103 	lsl	r3, r3, #2
   11110:	e0833001 	add	r3, r3, r1
   11114:	e1a03083 	lsl	r3, r3, #1
   11118:	e0423003 	sub	r3, r2, r3
   1111c:	e6ef3073 	uxtb	r3, r3
   11120:	e1a02003 	mov	r2, r3
   11124:	e1a02082 	lsl	r2, r2, #1
   11128:	e0823003 	add	r3, r2, r3
   1112c:	e54b3009 	strb	r3, [fp, #-9]
    uint32_t  mask = BCM2835_GPIO_FSEL_MASK << shift;
   11130:	e55b3009 	ldrb	r3, [fp, #-9]
   11134:	e3a02007 	mov	r2, #7
   11138:	e1a03312 	lsl	r3, r2, r3
   1113c:	e50b3010 	str	r3, [fp, #-16]
    uint32_t  value = mode << shift;
   11140:	e55b2016 	ldrb	r2, [fp, #-22]	; 0xffffffea
   11144:	e55b3009 	ldrb	r3, [fp, #-9]
   11148:	e1a03312 	lsl	r3, r2, r3
   1114c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    bcm2835_peri_set_bits(paddr, value, mask);
   11150:	e51b2010 	ldr	r2, [fp, #-16]
   11154:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
   11158:	e51b0008 	ldr	r0, [fp, #-8]
   1115c:	ebffffbb 	bl	11050 <bcm2835_peri_set_bits>
}
   11160:	e1a00000 	nop			; (mov r0, r0)
   11164:	e24bd004 	sub	sp, fp, #4
   11168:	e8bd8800 	pop	{fp, pc}
   1116c:	000270ac 	.word	0x000270ac
   11170:	cccccccd 	.word	0xcccccccd

00011174 <bcm2835_gpio_set>:

/* Set output pin */
void bcm2835_gpio_set(uint8_t pin)
{
   11174:	e92d4800 	push	{fp, lr}
   11178:	e28db004 	add	fp, sp, #4
   1117c:	e24dd010 	sub	sp, sp, #16
   11180:	e1a03000 	mov	r3, r0
   11184:	e54b300d 	strb	r3, [fp, #-13]
    volatile uint32_t* paddr = bcm2835_gpio + BCM2835_GPSET0/4 + pin/32;
   11188:	e59f304c 	ldr	r3, [pc, #76]	; 111dc <bcm2835_gpio_set+0x68>
   1118c:	e5932000 	ldr	r2, [r3]
   11190:	e55b300d 	ldrb	r3, [fp, #-13]
   11194:	e1a032a3 	lsr	r3, r3, #5
   11198:	e6ef3073 	uxtb	r3, r3
   1119c:	e2833007 	add	r3, r3, #7
   111a0:	e1a03103 	lsl	r3, r3, #2
   111a4:	e0823003 	add	r3, r2, r3
   111a8:	e50b3008 	str	r3, [fp, #-8]
    uint8_t shift = pin % 32;
   111ac:	e55b300d 	ldrb	r3, [fp, #-13]
   111b0:	e203301f 	and	r3, r3, #31
   111b4:	e54b3009 	strb	r3, [fp, #-9]
    bcm2835_peri_write(paddr, 1 << shift);
   111b8:	e55b3009 	ldrb	r3, [fp, #-9]
   111bc:	e3a02001 	mov	r2, #1
   111c0:	e1a03312 	lsl	r3, r2, r3
   111c4:	e1a01003 	mov	r1, r3
   111c8:	e51b0008 	ldr	r0, [fp, #-8]
   111cc:	ebffff71 	bl	10f98 <bcm2835_peri_write>
}
   111d0:	e1a00000 	nop			; (mov r0, r0)
   111d4:	e24bd004 	sub	sp, fp, #4
   111d8:	e8bd8800 	pop	{fp, pc}
   111dc:	000270ac 	.word	0x000270ac

000111e0 <bcm2835_gpio_clr>:

/* Clear output pin */
void bcm2835_gpio_clr(uint8_t pin)
{
   111e0:	e92d4800 	push	{fp, lr}
   111e4:	e28db004 	add	fp, sp, #4
   111e8:	e24dd010 	sub	sp, sp, #16
   111ec:	e1a03000 	mov	r3, r0
   111f0:	e54b300d 	strb	r3, [fp, #-13]
    volatile uint32_t* paddr = bcm2835_gpio + BCM2835_GPCLR0/4 + pin/32;
   111f4:	e59f304c 	ldr	r3, [pc, #76]	; 11248 <bcm2835_gpio_clr+0x68>
   111f8:	e5932000 	ldr	r2, [r3]
   111fc:	e55b300d 	ldrb	r3, [fp, #-13]
   11200:	e1a032a3 	lsr	r3, r3, #5
   11204:	e6ef3073 	uxtb	r3, r3
   11208:	e283300a 	add	r3, r3, #10
   1120c:	e1a03103 	lsl	r3, r3, #2
   11210:	e0823003 	add	r3, r2, r3
   11214:	e50b3008 	str	r3, [fp, #-8]
    uint8_t shift = pin % 32;
   11218:	e55b300d 	ldrb	r3, [fp, #-13]
   1121c:	e203301f 	and	r3, r3, #31
   11220:	e54b3009 	strb	r3, [fp, #-9]
    bcm2835_peri_write(paddr, 1 << shift);
   11224:	e55b3009 	ldrb	r3, [fp, #-9]
   11228:	e3a02001 	mov	r2, #1
   1122c:	e1a03312 	lsl	r3, r2, r3
   11230:	e1a01003 	mov	r1, r3
   11234:	e51b0008 	ldr	r0, [fp, #-8]
   11238:	ebffff56 	bl	10f98 <bcm2835_peri_write>
}
   1123c:	e1a00000 	nop			; (mov r0, r0)
   11240:	e24bd004 	sub	sp, fp, #4
   11244:	e8bd8800 	pop	{fp, pc}
   11248:	000270ac 	.word	0x000270ac

0001124c <bcm2835_gpio_lev>:
    bcm2835_peri_write(paddr, mask);
}

/* Read input pin */
uint8_t bcm2835_gpio_lev(uint8_t pin)
{
   1124c:	e92d4800 	push	{fp, lr}
   11250:	e28db004 	add	fp, sp, #4
   11254:	e24dd018 	sub	sp, sp, #24
   11258:	e1a03000 	mov	r3, r0
   1125c:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    volatile uint32_t* paddr = bcm2835_gpio + BCM2835_GPLEV0/4 + pin/32;
   11260:	e59f3068 	ldr	r3, [pc, #104]	; 112d0 <bcm2835_gpio_lev+0x84>
   11264:	e5932000 	ldr	r2, [r3]
   11268:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
   1126c:	e1a032a3 	lsr	r3, r3, #5
   11270:	e6ef3073 	uxtb	r3, r3
   11274:	e283300d 	add	r3, r3, #13
   11278:	e1a03103 	lsl	r3, r3, #2
   1127c:	e0823003 	add	r3, r2, r3
   11280:	e50b3008 	str	r3, [fp, #-8]
    uint8_t shift = pin % 32;
   11284:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
   11288:	e203301f 	and	r3, r3, #31
   1128c:	e54b3009 	strb	r3, [fp, #-9]
    uint32_t value = bcm2835_peri_read(paddr);
   11290:	e51b0008 	ldr	r0, [fp, #-8]
   11294:	ebffff13 	bl	10ee8 <bcm2835_peri_read>
   11298:	e50b0010 	str	r0, [fp, #-16]
    return (value & (1 << shift)) ? HIGH : LOW;
   1129c:	e55b3009 	ldrb	r3, [fp, #-9]
   112a0:	e3a02001 	mov	r2, #1
   112a4:	e1a03312 	lsl	r3, r2, r3
   112a8:	e1a02003 	mov	r2, r3
   112ac:	e51b3010 	ldr	r3, [fp, #-16]
   112b0:	e0033002 	and	r3, r3, r2
   112b4:	e3530000 	cmp	r3, #0
   112b8:	13a03001 	movne	r3, #1
   112bc:	03a03000 	moveq	r3, #0
   112c0:	e6ef3073 	uxtb	r3, r3
}
   112c4:	e1a00003 	mov	r0, r3
   112c8:	e24bd004 	sub	sp, fp, #4
   112cc:	e8bd8800 	pop	{fp, pc}
   112d0:	000270ac 	.word	0x000270ac

000112d4 <bcm2835_delay>:

/* Some convenient arduino-like functions
// milliseconds
*/
void bcm2835_delay(unsigned int millis)
{
   112d4:	e92d4800 	push	{fp, lr}
   112d8:	e28db004 	add	fp, sp, #4
   112dc:	e24dd010 	sub	sp, sp, #16
   112e0:	e50b0010 	str	r0, [fp, #-16]
    struct timespec sleeper;
    
    sleeper.tv_sec  = (time_t)(millis / 1000);
   112e4:	e51b3010 	ldr	r3, [fp, #-16]
   112e8:	e59f2078 	ldr	r2, [pc, #120]	; 11368 <bcm2835_delay+0x94>
   112ec:	e0832392 	umull	r2, r3, r2, r3
   112f0:	e1a03323 	lsr	r3, r3, #6
   112f4:	e50b300c 	str	r3, [fp, #-12]
    sleeper.tv_nsec = (long)(millis % 1000) * 1000000;
   112f8:	e51b1010 	ldr	r1, [fp, #-16]
   112fc:	e59f3064 	ldr	r3, [pc, #100]	; 11368 <bcm2835_delay+0x94>
   11300:	e0832193 	umull	r2, r3, r3, r1
   11304:	e1a02323 	lsr	r2, r3, #6
   11308:	e1a03002 	mov	r3, r2
   1130c:	e1a03283 	lsl	r3, r3, #5
   11310:	e0433002 	sub	r3, r3, r2
   11314:	e1a03103 	lsl	r3, r3, #2
   11318:	e0833002 	add	r3, r3, r2
   1131c:	e1a03183 	lsl	r3, r3, #3
   11320:	e0412003 	sub	r2, r1, r3
   11324:	e1a01002 	mov	r1, r2
   11328:	e1a02001 	mov	r2, r1
   1132c:	e1a02282 	lsl	r2, r2, #5
   11330:	e0422001 	sub	r2, r2, r1
   11334:	e1a03302 	lsl	r3, r2, #6
   11338:	e0433002 	sub	r3, r3, r2
   1133c:	e1a03183 	lsl	r3, r3, #3
   11340:	e0833001 	add	r3, r3, r1
   11344:	e1a03303 	lsl	r3, r3, #6
   11348:	e50b3008 	str	r3, [fp, #-8]
    nanosleep(&sleeper, NULL);
   1134c:	e24b300c 	sub	r3, fp, #12
   11350:	e3a01000 	mov	r1, #0
   11354:	e1a00003 	mov	r0, r3
   11358:	ebfffd80 	bl	10960 <nanosleep@plt>
}
   1135c:	e1a00000 	nop			; (mov r0, r0)
   11360:	e24bd004 	sub	sp, fp, #4
   11364:	e8bd8800 	pop	{fp, pc}
   11368:	10624dd3 	.word	0x10624dd3

0001136c <bcm2835_delayMicroseconds>:

/* microseconds */
void bcm2835_delayMicroseconds(uint64_t micros)
{
   1136c:	e92d4800 	push	{fp, lr}
   11370:	e28db004 	add	fp, sp, #4
   11374:	e24dd018 	sub	sp, sp, #24
   11378:	e14b01fc 	strd	r0, [fp, #-28]	; 0xffffffe4
    struct timespec t1;
    uint64_t        start;
	
    if (debug)
   1137c:	e59f30d4 	ldr	r3, [pc, #212]	; 11458 <bcm2835_delayMicroseconds+0xec>
   11380:	e5d33000 	ldrb	r3, [r3]
   11384:	e3530000 	cmp	r3, #0
   11388:	0a000003 	beq	1139c <bcm2835_delayMicroseconds+0x30>
    {
	/* Cant access sytem timers in debug mode */
	printf("bcm2835_delayMicroseconds %lld\n", (long long int) micros);
   1138c:	e14b21dc 	ldrd	r2, [fp, #-28]	; 0xffffffe4
   11390:	e59f00c4 	ldr	r0, [pc, #196]	; 1145c <bcm2835_delayMicroseconds+0xf0>
   11394:	ebfffd65 	bl	10930 <printf@plt>
	return;
   11398:	ea00002c 	b	11450 <bcm2835_delayMicroseconds+0xe4>
    }

    /* Calling nanosleep() takes at least 100-200 us, so use it for
    // long waits and use a busy wait on the System Timer for the rest.
    */
    start =  bcm2835_st_read();
   1139c:	eb0001e6 	bl	11b3c <bcm2835_st_read>
   113a0:	e14b00fc 	strd	r0, [fp, #-12]
   
    /* Not allowed to access timer registers (result is not as precise)*/
    if (start==0)
   113a4:	e14b20dc 	ldrd	r2, [fp, #-12]
   113a8:	e1923003 	orrs	r3, r2, r3
   113ac:	1a00000e 	bne	113ec <bcm2835_delayMicroseconds+0x80>
    {
	t1.tv_sec = 0;
   113b0:	e3a03000 	mov	r3, #0
   113b4:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	t1.tv_nsec = 1000 * (long)(micros);
   113b8:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
   113bc:	e1a03002 	mov	r3, r2
   113c0:	e1a03283 	lsl	r3, r3, #5
   113c4:	e0433002 	sub	r3, r3, r2
   113c8:	e1a03103 	lsl	r3, r3, #2
   113cc:	e0833002 	add	r3, r3, r2
   113d0:	e1a03183 	lsl	r3, r3, #3
   113d4:	e50b3010 	str	r3, [fp, #-16]
	nanosleep(&t1, NULL);
   113d8:	e24b3014 	sub	r3, fp, #20
   113dc:	e3a01000 	mov	r1, #0
   113e0:	e1a00003 	mov	r0, r3
   113e4:	ebfffd5d 	bl	10960 <nanosleep@plt>
	return;
   113e8:	ea000018 	b	11450 <bcm2835_delayMicroseconds+0xe4>
    }

    if (micros > 450)
   113ec:	e14b21dc 	ldrd	r2, [fp, #-28]	; 0xffffffe4
   113f0:	e59f0068 	ldr	r0, [pc, #104]	; 11460 <bcm2835_delayMicroseconds+0xf4>
   113f4:	e3a01000 	mov	r1, #0
   113f8:	e1530001 	cmp	r3, r1
   113fc:	01520000 	cmpeq	r2, r0
   11400:	9a00000f 	bls	11444 <bcm2835_delayMicroseconds+0xd8>
    {
	t1.tv_sec = 0;
   11404:	e3a03000 	mov	r3, #0
   11408:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	t1.tv_nsec = 1000 * (long)(micros - 200);
   1140c:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
   11410:	e1a03002 	mov	r3, r2
   11414:	e1a03283 	lsl	r3, r3, #5
   11418:	e0433002 	sub	r3, r3, r2
   1141c:	e1a03103 	lsl	r3, r3, #2
   11420:	e0833002 	add	r3, r3, r2
   11424:	e1a03183 	lsl	r3, r3, #3
   11428:	e2433bc3 	sub	r3, r3, #199680	; 0x30c00
   1142c:	e2433d05 	sub	r3, r3, #320	; 0x140
   11430:	e50b3010 	str	r3, [fp, #-16]
	nanosleep(&t1, NULL);
   11434:	e24b3014 	sub	r3, fp, #20
   11438:	e3a01000 	mov	r1, #0
   1143c:	e1a00003 	mov	r0, r3
   11440:	ebfffd46 	bl	10960 <nanosleep@plt>
    }    
  
    bcm2835_st_delay(start, micros);
   11444:	e14b21dc 	ldrd	r2, [fp, #-28]	; 0xffffffe4
   11448:	e14b00dc 	ldrd	r0, [fp, #-12]
   1144c:	eb00020a 	bl	11c7c <bcm2835_st_delay>
}
   11450:	e24bd004 	sub	sp, fp, #4
   11454:	e8bd8800 	pop	{fp, pc}
   11458:	00027205 	.word	0x00027205
   1145c:	00016080 	.word	0x00016080
   11460:	000001c2 	.word	0x000001c2

00011464 <bcm2835_gpio_write>:
// Higher level convenience functions
*/

/* Set the state of an output */
void bcm2835_gpio_write(uint8_t pin, uint8_t on)
{
   11464:	e92d4800 	push	{fp, lr}
   11468:	e28db004 	add	fp, sp, #4
   1146c:	e24dd008 	sub	sp, sp, #8
   11470:	e1a03000 	mov	r3, r0
   11474:	e1a02001 	mov	r2, r1
   11478:	e54b3005 	strb	r3, [fp, #-5]
   1147c:	e1a03002 	mov	r3, r2
   11480:	e54b3006 	strb	r3, [fp, #-6]
    if (on)
   11484:	e55b3006 	ldrb	r3, [fp, #-6]
   11488:	e3530000 	cmp	r3, #0
   1148c:	0a000003 	beq	114a0 <bcm2835_gpio_write+0x3c>
	bcm2835_gpio_set(pin);
   11490:	e55b3005 	ldrb	r3, [fp, #-5]
   11494:	e1a00003 	mov	r0, r3
   11498:	ebffff35 	bl	11174 <bcm2835_gpio_set>
    else
	bcm2835_gpio_clr(pin);
}
   1149c:	ea000002 	b	114ac <bcm2835_gpio_write+0x48>
	bcm2835_gpio_clr(pin);
   114a0:	e55b3005 	ldrb	r3, [fp, #-5]
   114a4:	e1a00003 	mov	r0, r3
   114a8:	ebffff4c 	bl	111e0 <bcm2835_gpio_clr>
}
   114ac:	e1a00000 	nop			; (mov r0, r0)
   114b0:	e24bd004 	sub	sp, fp, #4
   114b4:	e8bd8800 	pop	{fp, pc}

000114b8 <bcm2835_aux_spi_reset>:
    
    return ret;
}

static void bcm2835_aux_spi_reset(void)
 {
   114b8:	e92d4800 	push	{fp, lr}
   114bc:	e28db004 	add	fp, sp, #4
   114c0:	e24dd008 	sub	sp, sp, #8
     volatile uint32_t* cntl0 = bcm2835_spi1 + BCM2835_AUX_SPI_CNTL0/4;
   114c4:	e59f3038 	ldr	r3, [pc, #56]	; 11504 <bcm2835_aux_spi_reset+0x4c>
   114c8:	e5933000 	ldr	r3, [r3]
   114cc:	e50b3008 	str	r3, [fp, #-8]
     volatile uint32_t* cntl1 = bcm2835_spi1 + BCM2835_AUX_SPI_CNTL1/4;
   114d0:	e59f302c 	ldr	r3, [pc, #44]	; 11504 <bcm2835_aux_spi_reset+0x4c>
   114d4:	e5933000 	ldr	r3, [r3]
   114d8:	e2833004 	add	r3, r3, #4
   114dc:	e50b300c 	str	r3, [fp, #-12]
 
     bcm2835_peri_write(cntl1, 0);
   114e0:	e3a01000 	mov	r1, #0
   114e4:	e51b000c 	ldr	r0, [fp, #-12]
   114e8:	ebfffeaa 	bl	10f98 <bcm2835_peri_write>
     bcm2835_peri_write(cntl0, BCM2835_AUX_SPI_CNTL0_CLEARFIFO);
   114ec:	e3a01c02 	mov	r1, #512	; 0x200
   114f0:	e51b0008 	ldr	r0, [fp, #-8]
   114f4:	ebfffea7 	bl	10f98 <bcm2835_peri_write>
}
   114f8:	e1a00000 	nop			; (mov r0, r0)
   114fc:	e24bd004 	sub	sp, fp, #4
   11500:	e8bd8800 	pop	{fp, pc}
   11504:	000270d0 	.word	0x000270d0

00011508 <bcm2835_spi_begin>:

int bcm2835_spi_begin(void)
{
   11508:	e92d4800 	push	{fp, lr}
   1150c:	e28db004 	add	fp, sp, #4
   11510:	e24dd008 	sub	sp, sp, #8
    volatile uint32_t* paddr;

    if (bcm2835_spi0 == MAP_FAILED)
   11514:	e59f3080 	ldr	r3, [pc, #128]	; 1159c <bcm2835_spi_begin+0x94>
   11518:	e5933000 	ldr	r3, [r3]
   1151c:	e3730001 	cmn	r3, #1
   11520:	1a000001 	bne	1152c <bcm2835_spi_begin+0x24>
      return 0; /* bcm2835_init() failed, or not root */
   11524:	e3a03000 	mov	r3, #0
   11528:	ea000018 	b	11590 <bcm2835_spi_begin+0x88>
    
    /* Set the SPI0 pins to the Alt 0 function to enable SPI0 access on them */
    bcm2835_gpio_fsel(RPI_GPIO_P1_26, BCM2835_GPIO_FSEL_ALT0); /* CE1 */
   1152c:	e3a01004 	mov	r1, #4
   11530:	e3a00007 	mov	r0, #7
   11534:	ebfffedd 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_24, BCM2835_GPIO_FSEL_ALT0); /* CE0 */
   11538:	e3a01004 	mov	r1, #4
   1153c:	e3a00008 	mov	r0, #8
   11540:	ebfffeda 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_21, BCM2835_GPIO_FSEL_ALT0); /* MISO */
   11544:	e3a01004 	mov	r1, #4
   11548:	e3a00009 	mov	r0, #9
   1154c:	ebfffed7 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_19, BCM2835_GPIO_FSEL_ALT0); /* MOSI */
   11550:	e3a01004 	mov	r1, #4
   11554:	e3a0000a 	mov	r0, #10
   11558:	ebfffed4 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_23, BCM2835_GPIO_FSEL_ALT0); /* CLK */
   1155c:	e3a01004 	mov	r1, #4
   11560:	e3a0000b 	mov	r0, #11
   11564:	ebfffed1 	bl	110b0 <bcm2835_gpio_fsel>
    
    /* Set the SPI CS register to the some sensible defaults */
    paddr = bcm2835_spi0 + BCM2835_SPI0_CS/4;
   11568:	e59f302c 	ldr	r3, [pc, #44]	; 1159c <bcm2835_spi_begin+0x94>
   1156c:	e5933000 	ldr	r3, [r3]
   11570:	e50b3008 	str	r3, [fp, #-8]
    bcm2835_peri_write(paddr, 0); /* All 0s */
   11574:	e3a01000 	mov	r1, #0
   11578:	e51b0008 	ldr	r0, [fp, #-8]
   1157c:	ebfffe85 	bl	10f98 <bcm2835_peri_write>
    
    /* Clear TX and RX fifos */
    bcm2835_peri_write_nb(paddr, BCM2835_SPI0_CS_CLEAR);
   11580:	e3a01030 	mov	r1, #48	; 0x30
   11584:	e51b0008 	ldr	r0, [fp, #-8]
   11588:	ebfffe9a 	bl	10ff8 <bcm2835_peri_write_nb>

    return 1; // OK
   1158c:	e3a03001 	mov	r3, #1
}
   11590:	e1a00003 	mov	r0, r3
   11594:	e24bd004 	sub	sp, fp, #4
   11598:	e8bd8800 	pop	{fp, pc}
   1159c:	000270bc 	.word	0x000270bc

000115a0 <bcm2835_spi_end>:

void bcm2835_spi_end(void)
{  
   115a0:	e92d4800 	push	{fp, lr}
   115a4:	e28db004 	add	fp, sp, #4
    /* Set all the SPI0 pins back to input */
    bcm2835_gpio_fsel(RPI_GPIO_P1_26, BCM2835_GPIO_FSEL_INPT); /* CE1 */
   115a8:	e3a01000 	mov	r1, #0
   115ac:	e3a00007 	mov	r0, #7
   115b0:	ebfffebe 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_24, BCM2835_GPIO_FSEL_INPT); /* CE0 */
   115b4:	e3a01000 	mov	r1, #0
   115b8:	e3a00008 	mov	r0, #8
   115bc:	ebfffebb 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_21, BCM2835_GPIO_FSEL_INPT); /* MISO */
   115c0:	e3a01000 	mov	r1, #0
   115c4:	e3a00009 	mov	r0, #9
   115c8:	ebfffeb8 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_19, BCM2835_GPIO_FSEL_INPT); /* MOSI */
   115cc:	e3a01000 	mov	r1, #0
   115d0:	e3a0000a 	mov	r0, #10
   115d4:	ebfffeb5 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_GPIO_P1_23, BCM2835_GPIO_FSEL_INPT); /* CLK */
   115d8:	e3a01000 	mov	r1, #0
   115dc:	e3a0000b 	mov	r0, #11
   115e0:	ebfffeb2 	bl	110b0 <bcm2835_gpio_fsel>
}
   115e4:	e1a00000 	nop			; (mov r0, r0)
   115e8:	e8bd8800 	pop	{fp, pc}

000115ec <bcm2835_spi_setBitOrder>:

void bcm2835_spi_setBitOrder(uint8_t order)
{
   115ec:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   115f0:	e28db000 	add	fp, sp, #0
   115f4:	e24dd00c 	sub	sp, sp, #12
   115f8:	e1a03000 	mov	r3, r0
   115fc:	e54b3005 	strb	r3, [fp, #-5]
    bcm2835_spi_bit_order = order;
   11600:	e59f2014 	ldr	r2, [pc, #20]	; 1161c <bcm2835_spi_setBitOrder+0x30>
   11604:	e55b3005 	ldrb	r3, [fp, #-5]
   11608:	e5c23000 	strb	r3, [r2]
}
   1160c:	e1a00000 	nop			; (mov r0, r0)
   11610:	e28bd000 	add	sp, fp, #0
   11614:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   11618:	e12fff1e 	bx	lr
   1161c:	000270d4 	.word	0x000270d4

00011620 <bcm2835_spi_setClockDivider>:
// The divisor must be a power of 2. Odd numbers
// rounded down. The maximum SPI clock rate is
// of the APB clock
*/
void bcm2835_spi_setClockDivider(uint16_t divider)
{
   11620:	e92d4800 	push	{fp, lr}
   11624:	e28db004 	add	fp, sp, #4
   11628:	e24dd010 	sub	sp, sp, #16
   1162c:	e1a03000 	mov	r3, r0
   11630:	e14b30be 	strh	r3, [fp, #-14]
    volatile uint32_t* paddr = bcm2835_spi0 + BCM2835_SPI0_CLK/4;
   11634:	e59f3024 	ldr	r3, [pc, #36]	; 11660 <bcm2835_spi_setClockDivider+0x40>
   11638:	e5933000 	ldr	r3, [r3]
   1163c:	e2833008 	add	r3, r3, #8
   11640:	e50b3008 	str	r3, [fp, #-8]
    bcm2835_peri_write(paddr, divider);
   11644:	e15b30be 	ldrh	r3, [fp, #-14]
   11648:	e1a01003 	mov	r1, r3
   1164c:	e51b0008 	ldr	r0, [fp, #-8]
   11650:	ebfffe50 	bl	10f98 <bcm2835_peri_write>
}
   11654:	e1a00000 	nop			; (mov r0, r0)
   11658:	e24bd004 	sub	sp, fp, #4
   1165c:	e8bd8800 	pop	{fp, pc}
   11660:	000270bc 	.word	0x000270bc

00011664 <bcm2835_spi_setDataMode>:
	divider &= 0xFFFE;
	bcm2835_spi_setClockDivider(divider);
}

void bcm2835_spi_setDataMode(uint8_t mode)
{
   11664:	e92d4800 	push	{fp, lr}
   11668:	e28db004 	add	fp, sp, #4
   1166c:	e24dd010 	sub	sp, sp, #16
   11670:	e1a03000 	mov	r3, r0
   11674:	e54b300d 	strb	r3, [fp, #-13]
    volatile uint32_t* paddr = bcm2835_spi0 + BCM2835_SPI0_CS/4;
   11678:	e59f3028 	ldr	r3, [pc, #40]	; 116a8 <bcm2835_spi_setDataMode+0x44>
   1167c:	e5933000 	ldr	r3, [r3]
   11680:	e50b3008 	str	r3, [fp, #-8]
    /* Mask in the CPO and CPHA bits of CS */
    bcm2835_peri_set_bits(paddr, mode << 2, BCM2835_SPI0_CS_CPOL | BCM2835_SPI0_CS_CPHA);
   11684:	e55b300d 	ldrb	r3, [fp, #-13]
   11688:	e1a03103 	lsl	r3, r3, #2
   1168c:	e3a0200c 	mov	r2, #12
   11690:	e1a01003 	mov	r1, r3
   11694:	e51b0008 	ldr	r0, [fp, #-8]
   11698:	ebfffe6c 	bl	11050 <bcm2835_peri_set_bits>
}
   1169c:	e1a00000 	nop			; (mov r0, r0)
   116a0:	e24bd004 	sub	sp, fp, #4
   116a4:	e8bd8800 	pop	{fp, pc}
   116a8:	000270bc 	.word	0x000270bc

000116ac <bcm2835_spi_transfer>:

/* Writes (and reads) a single byte to SPI */
uint8_t bcm2835_spi_transfer(uint8_t value)
{
   116ac:	e92d4800 	push	{fp, lr}
   116b0:	e28db004 	add	fp, sp, #4
   116b4:	e24dd018 	sub	sp, sp, #24
   116b8:	e1a03000 	mov	r3, r0
   116bc:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
    volatile uint32_t* paddr = bcm2835_spi0 + BCM2835_SPI0_CS/4;
   116c0:	e59f30cc 	ldr	r3, [pc, #204]	; 11794 <bcm2835_spi_transfer+0xe8>
   116c4:	e5933000 	ldr	r3, [r3]
   116c8:	e50b3008 	str	r3, [fp, #-8]
    volatile uint32_t* fifo = bcm2835_spi0 + BCM2835_SPI0_FIFO/4;
   116cc:	e59f30c0 	ldr	r3, [pc, #192]	; 11794 <bcm2835_spi_transfer+0xe8>
   116d0:	e5933000 	ldr	r3, [r3]
   116d4:	e2833004 	add	r3, r3, #4
   116d8:	e50b300c 	str	r3, [fp, #-12]
    /* This is Polled transfer as per section 10.6.1
    // BUG ALERT: what happens if we get interupted in this section, and someone else
    // accesses a different peripheral? 
    // Clear TX and RX fifos
    */
    bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_CLEAR, BCM2835_SPI0_CS_CLEAR);
   116dc:	e3a02030 	mov	r2, #48	; 0x30
   116e0:	e3a01030 	mov	r1, #48	; 0x30
   116e4:	e51b0008 	ldr	r0, [fp, #-8]
   116e8:	ebfffe58 	bl	11050 <bcm2835_peri_set_bits>

    /* Set TA = 1 */
    bcm2835_peri_set_bits(paddr, BCM2835_SPI0_CS_TA, BCM2835_SPI0_CS_TA);
   116ec:	e3a02080 	mov	r2, #128	; 0x80
   116f0:	e3a01080 	mov	r1, #128	; 0x80
   116f4:	e51b0008 	ldr	r0, [fp, #-8]
   116f8:	ebfffe54 	bl	11050 <bcm2835_peri_set_bits>

    /* Maybe wait for TXD */
    while (!(bcm2835_peri_read(paddr) & BCM2835_SPI0_CS_TXD))
   116fc:	e1a00000 	nop			; (mov r0, r0)
   11700:	e51b0008 	ldr	r0, [fp, #-8]
   11704:	ebfffdf7 	bl	10ee8 <bcm2835_peri_read>
   11708:	e1a03000 	mov	r3, r0
   1170c:	e2033701 	and	r3, r3, #262144	; 0x40000
   11710:	e3530000 	cmp	r3, #0
   11714:	0afffff9 	beq	11700 <bcm2835_spi_transfer+0x54>
	;

    /* Write to FIFO, no barrier */
    bcm2835_peri_write_nb(fifo, bcm2835_correct_order(value));
   11718:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
   1171c:	e1a00003 	mov	r0, r3
   11720:	ebfffddc 	bl	10e98 <bcm2835_correct_order>
   11724:	e1a03000 	mov	r3, r0
   11728:	e1a01003 	mov	r1, r3
   1172c:	e51b000c 	ldr	r0, [fp, #-12]
   11730:	ebfffe30 	bl	10ff8 <bcm2835_peri_write_nb>

    /* Wait for DONE to be set */
    while (!(bcm2835_peri_read_nb(paddr) & BCM2835_SPI0_CS_DONE))
   11734:	e1a00000 	nop			; (mov r0, r0)
   11738:	e51b0008 	ldr	r0, [fp, #-8]
   1173c:	ebfffe01 	bl	10f48 <bcm2835_peri_read_nb>
   11740:	e1a03000 	mov	r3, r0
   11744:	e2033801 	and	r3, r3, #65536	; 0x10000
   11748:	e3530000 	cmp	r3, #0
   1174c:	0afffff9 	beq	11738 <bcm2835_spi_transfer+0x8c>
	;

    /* Read any byte that was sent back by the slave while we sere sending to it */
    ret = bcm2835_correct_order(bcm2835_peri_read_nb(fifo));
   11750:	e51b000c 	ldr	r0, [fp, #-12]
   11754:	ebfffdfb 	bl	10f48 <bcm2835_peri_read_nb>
   11758:	e1a03000 	mov	r3, r0
   1175c:	e6ef3073 	uxtb	r3, r3
   11760:	e1a00003 	mov	r0, r3
   11764:	ebfffdcb 	bl	10e98 <bcm2835_correct_order>
   11768:	e1a03000 	mov	r3, r0
   1176c:	e50b3010 	str	r3, [fp, #-16]

    /* Set TA = 0, and also set the barrier */
    bcm2835_peri_set_bits(paddr, 0, BCM2835_SPI0_CS_TA);
   11770:	e3a02080 	mov	r2, #128	; 0x80
   11774:	e3a01000 	mov	r1, #0
   11778:	e51b0008 	ldr	r0, [fp, #-8]
   1177c:	ebfffe33 	bl	11050 <bcm2835_peri_set_bits>

    return ret;
   11780:	e51b3010 	ldr	r3, [fp, #-16]
   11784:	e6ef3073 	uxtb	r3, r3
}
   11788:	e1a00003 	mov	r0, r3
   1178c:	e24bd004 	sub	sp, fp, #4
   11790:	e8bd8800 	pop	{fp, pc}
   11794:	000270bc 	.word	0x000270bc

00011798 <bcm2835_spi_chipSelect>:
{
    bcm2835_spi_transfernb(buf, buf, len);
}

void bcm2835_spi_chipSelect(uint8_t cs)
{
   11798:	e92d4800 	push	{fp, lr}
   1179c:	e28db004 	add	fp, sp, #4
   117a0:	e24dd010 	sub	sp, sp, #16
   117a4:	e1a03000 	mov	r3, r0
   117a8:	e54b300d 	strb	r3, [fp, #-13]
    volatile uint32_t* paddr = bcm2835_spi0 + BCM2835_SPI0_CS/4;
   117ac:	e59f3024 	ldr	r3, [pc, #36]	; 117d8 <bcm2835_spi_chipSelect+0x40>
   117b0:	e5933000 	ldr	r3, [r3]
   117b4:	e50b3008 	str	r3, [fp, #-8]
    /* Mask in the CS bits of CS */
    bcm2835_peri_set_bits(paddr, cs, BCM2835_SPI0_CS_CS);
   117b8:	e55b300d 	ldrb	r3, [fp, #-13]
   117bc:	e3a02003 	mov	r2, #3
   117c0:	e1a01003 	mov	r1, r3
   117c4:	e51b0008 	ldr	r0, [fp, #-8]
   117c8:	ebfffe20 	bl	11050 <bcm2835_peri_set_bits>
}
   117cc:	e1a00000 	nop			; (mov r0, r0)
   117d0:	e24bd004 	sub	sp, fp, #4
   117d4:	e8bd8800 	pop	{fp, pc}
   117d8:	000270bc 	.word	0x000270bc

000117dc <bcm2835_spi_setChipSelectPolarity>:

void bcm2835_spi_setChipSelectPolarity(uint8_t cs, uint8_t active)
{
   117dc:	e92d4800 	push	{fp, lr}
   117e0:	e28db004 	add	fp, sp, #4
   117e4:	e24dd010 	sub	sp, sp, #16
   117e8:	e1a03000 	mov	r3, r0
   117ec:	e1a02001 	mov	r2, r1
   117f0:	e54b300d 	strb	r3, [fp, #-13]
   117f4:	e1a03002 	mov	r3, r2
   117f8:	e54b300e 	strb	r3, [fp, #-14]
    volatile uint32_t* paddr = bcm2835_spi0 + BCM2835_SPI0_CS/4;
   117fc:	e59f3044 	ldr	r3, [pc, #68]	; 11848 <bcm2835_spi_setChipSelectPolarity+0x6c>
   11800:	e5933000 	ldr	r3, [r3]
   11804:	e50b3008 	str	r3, [fp, #-8]
    uint8_t shift = 21 + cs;
   11808:	e55b300d 	ldrb	r3, [fp, #-13]
   1180c:	e2833015 	add	r3, r3, #21
   11810:	e54b3009 	strb	r3, [fp, #-9]
    /* Mask in the appropriate CSPOLn bit */
    bcm2835_peri_set_bits(paddr, active << shift, 1 << shift);
   11814:	e55b200e 	ldrb	r2, [fp, #-14]
   11818:	e55b3009 	ldrb	r3, [fp, #-9]
   1181c:	e1a03312 	lsl	r3, r2, r3
   11820:	e1a01003 	mov	r1, r3
   11824:	e55b3009 	ldrb	r3, [fp, #-9]
   11828:	e3a02001 	mov	r2, #1
   1182c:	e1a03312 	lsl	r3, r2, r3
   11830:	e1a02003 	mov	r2, r3
   11834:	e51b0008 	ldr	r0, [fp, #-8]
   11838:	ebfffe04 	bl	11050 <bcm2835_peri_set_bits>
}
   1183c:	e1a00000 	nop			; (mov r0, r0)
   11840:	e24bd004 	sub	sp, fp, #4
   11844:	e8bd8800 	pop	{fp, pc}
   11848:	000270bc 	.word	0x000270bc

0001184c <bcm2835_aux_spi_begin>:
    bcm2835_peri_set_bits(paddr, 0, BCM2835_SPI0_CS_TA);
#endif
}

int bcm2835_aux_spi_begin(void)
{
   1184c:	e92d4800 	push	{fp, lr}
   11850:	e28db004 	add	fp, sp, #4
   11854:	e24dd010 	sub	sp, sp, #16
    volatile uint32_t* enable = bcm2835_aux + BCM2835_AUX_ENABLE/4;
   11858:	e59f30b4 	ldr	r3, [pc, #180]	; 11914 <bcm2835_aux_spi_begin+0xc8>
   1185c:	e5933000 	ldr	r3, [r3]
   11860:	e2833004 	add	r3, r3, #4
   11864:	e50b3008 	str	r3, [fp, #-8]
    volatile uint32_t* cntl0 = bcm2835_spi1 + BCM2835_AUX_SPI_CNTL0/4;
   11868:	e59f30a8 	ldr	r3, [pc, #168]	; 11918 <bcm2835_aux_spi_begin+0xcc>
   1186c:	e5933000 	ldr	r3, [r3]
   11870:	e50b300c 	str	r3, [fp, #-12]
    volatile uint32_t* cntl1 = bcm2835_spi1 + BCM2835_AUX_SPI_CNTL1/4;
   11874:	e59f309c 	ldr	r3, [pc, #156]	; 11918 <bcm2835_aux_spi_begin+0xcc>
   11878:	e5933000 	ldr	r3, [r3]
   1187c:	e2833004 	add	r3, r3, #4
   11880:	e50b3010 	str	r3, [fp, #-16]

    if (bcm2835_spi1 == MAP_FAILED)
   11884:	e59f308c 	ldr	r3, [pc, #140]	; 11918 <bcm2835_aux_spi_begin+0xcc>
   11888:	e5933000 	ldr	r3, [r3]
   1188c:	e3730001 	cmn	r3, #1
   11890:	1a000001 	bne	1189c <bcm2835_aux_spi_begin+0x50>
	return 0; /* bcm2835_init() failed, or not root */
   11894:	e3a03000 	mov	r3, #0
   11898:	ea00001a 	b	11908 <bcm2835_aux_spi_begin+0xbc>

    /* Set the SPI pins to the Alt 4 function to enable SPI1 access on them */
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_36, BCM2835_GPIO_FSEL_ALT4);	/* SPI1_CE2_N */
   1189c:	e3a01003 	mov	r1, #3
   118a0:	e3a00010 	mov	r0, #16
   118a4:	ebfffe01 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_35, BCM2835_GPIO_FSEL_ALT4);	/* SPI1_MISO */
   118a8:	e3a01003 	mov	r1, #3
   118ac:	e3a00013 	mov	r0, #19
   118b0:	ebfffdfe 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_38, BCM2835_GPIO_FSEL_ALT4);	/* SPI1_MOSI */
   118b4:	e3a01003 	mov	r1, #3
   118b8:	e3a00014 	mov	r0, #20
   118bc:	ebfffdfb 	bl	110b0 <bcm2835_gpio_fsel>
    bcm2835_gpio_fsel(RPI_V2_GPIO_P1_40, BCM2835_GPIO_FSEL_ALT4);	/* SPI1_SCLK */
   118c0:	e3a01003 	mov	r1, #3
   118c4:	e3a00015 	mov	r0, #21
   118c8:	ebfffdf8 	bl	110b0 <bcm2835_gpio_fsel>

    bcm2835_aux_spi_setClockDivider(bcm2835_aux_spi_CalcClockDivider(1000000));	// Default 1MHz SPI
   118cc:	e59f0048 	ldr	r0, [pc, #72]	; 1191c <bcm2835_aux_spi_begin+0xd0>
   118d0:	eb000012 	bl	11920 <bcm2835_aux_spi_CalcClockDivider>
   118d4:	e1a03000 	mov	r3, r0
   118d8:	e1a00003 	mov	r0, r3
   118dc:	eb00003b 	bl	119d0 <bcm2835_aux_spi_setClockDivider>

    bcm2835_peri_write(enable, BCM2835_AUX_ENABLE_SPI0);
   118e0:	e3a01002 	mov	r1, #2
   118e4:	e51b0008 	ldr	r0, [fp, #-8]
   118e8:	ebfffdaa 	bl	10f98 <bcm2835_peri_write>
    bcm2835_peri_write(cntl1, 0);
   118ec:	e3a01000 	mov	r1, #0
   118f0:	e51b0010 	ldr	r0, [fp, #-16]
   118f4:	ebfffda7 	bl	10f98 <bcm2835_peri_write>
    bcm2835_peri_write(cntl0, BCM2835_AUX_SPI_CNTL0_CLEARFIFO);
   118f8:	e3a01c02 	mov	r1, #512	; 0x200
   118fc:	e51b000c 	ldr	r0, [fp, #-12]
   11900:	ebfffda4 	bl	10f98 <bcm2835_peri_write>

    return 1; /* OK */
   11904:	e3a03001 	mov	r3, #1
}
   11908:	e1a00003 	mov	r0, r3
   1190c:	e24bd004 	sub	sp, fp, #4
   11910:	e8bd8800 	pop	{fp, pc}
   11914:	000270cc 	.word	0x000270cc
   11918:	000270d0 	.word	0x000270d0
   1191c:	000f4240 	.word	0x000f4240

00011920 <bcm2835_aux_spi_CalcClockDivider>:
}

#define DIV_ROUND_UP(n,d)	(((n) + (d) - 1) / (d))

uint16_t bcm2835_aux_spi_CalcClockDivider(uint32_t speed_hz)
{
   11920:	e92d4800 	push	{fp, lr}
   11924:	e28db004 	add	fp, sp, #4
   11928:	e24dd010 	sub	sp, sp, #16
   1192c:	e50b0010 	str	r0, [fp, #-16]
    uint16_t divider;

    if (speed_hz < (uint32_t) BCM2835_AUX_SPI_CLOCK_MIN) {
   11930:	e51b3010 	ldr	r3, [fp, #-16]
   11934:	e59f2084 	ldr	r2, [pc, #132]	; 119c0 <bcm2835_aux_spi_CalcClockDivider+0xa0>
   11938:	e1530002 	cmp	r3, r2
   1193c:	8a000002 	bhi	1194c <bcm2835_aux_spi_CalcClockDivider+0x2c>
	speed_hz = (uint32_t) BCM2835_AUX_SPI_CLOCK_MIN;
   11940:	e59f307c 	ldr	r3, [pc, #124]	; 119c4 <bcm2835_aux_spi_CalcClockDivider+0xa4>
   11944:	e50b3010 	str	r3, [fp, #-16]
   11948:	ea000005 	b	11964 <bcm2835_aux_spi_CalcClockDivider+0x44>
    } else if (speed_hz > (uint32_t) BCM2835_AUX_SPI_CLOCK_MAX) {
   1194c:	e51b3010 	ldr	r3, [fp, #-16]
   11950:	e59f2070 	ldr	r2, [pc, #112]	; 119c8 <bcm2835_aux_spi_CalcClockDivider+0xa8>
   11954:	e1530002 	cmp	r3, r2
   11958:	9a000001 	bls	11964 <bcm2835_aux_spi_CalcClockDivider+0x44>
	speed_hz = (uint32_t) BCM2835_AUX_SPI_CLOCK_MAX;
   1195c:	e59f3064 	ldr	r3, [pc, #100]	; 119c8 <bcm2835_aux_spi_CalcClockDivider+0xa8>
   11960:	e50b3010 	str	r3, [fp, #-16]
    }

    divider = (uint16_t) DIV_ROUND_UP(BCM2835_CORE_CLK_HZ, 2 * speed_hz) - 1;
   11964:	e51b2010 	ldr	r2, [fp, #-16]
   11968:	e59f3058 	ldr	r3, [pc, #88]	; 119c8 <bcm2835_aux_spi_CalcClockDivider+0xa8>
   1196c:	e0823003 	add	r3, r2, r3
   11970:	e1a03083 	lsl	r3, r3, #1
   11974:	e2432001 	sub	r2, r3, #1
   11978:	e51b3010 	ldr	r3, [fp, #-16]
   1197c:	e1a03083 	lsl	r3, r3, #1
   11980:	e1a01003 	mov	r1, r3
   11984:	e1a00002 	mov	r0, r2
   11988:	eb001043 	bl	15a9c <__udivsi3>
   1198c:	e1a03000 	mov	r3, r0
   11990:	e6ff3073 	uxth	r3, r3
   11994:	e2433001 	sub	r3, r3, #1
   11998:	e14b30b6 	strh	r3, [fp, #-6]

    if (divider > (uint16_t) BCM2835_AUX_SPI_CNTL0_SPEED_MAX) {
   1199c:	e15b30b6 	ldrh	r3, [fp, #-6]
   119a0:	e3530a01 	cmp	r3, #4096	; 0x1000
   119a4:	3a000001 	bcc	119b0 <bcm2835_aux_spi_CalcClockDivider+0x90>
	return (uint16_t) BCM2835_AUX_SPI_CNTL0_SPEED_MAX;
   119a8:	e59f301c 	ldr	r3, [pc, #28]	; 119cc <bcm2835_aux_spi_CalcClockDivider+0xac>
   119ac:	ea000000 	b	119b4 <bcm2835_aux_spi_CalcClockDivider+0x94>
    }

    return divider;
   119b0:	e15b30b6 	ldrh	r3, [fp, #-6]
}
   119b4:	e1a00003 	mov	r0, r3
   119b8:	e24bd004 	sub	sp, fp, #4
   119bc:	e8bd8800 	pop	{fp, pc}
   119c0:	00007723 	.word	0x00007723
   119c4:	00007724 	.word	0x00007724
   119c8:	07735940 	.word	0x07735940
   119cc:	00000fff 	.word	0x00000fff

000119d0 <bcm2835_aux_spi_setClockDivider>:

static uint32_t spi1_speed;

void bcm2835_aux_spi_setClockDivider(uint16_t divider)
{
   119d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   119d4:	e28db000 	add	fp, sp, #0
   119d8:	e24dd00c 	sub	sp, sp, #12
   119dc:	e1a03000 	mov	r3, r0
   119e0:	e14b30b6 	strh	r3, [fp, #-6]
    spi1_speed = (uint32_t) divider;
   119e4:	e15b30b6 	ldrh	r3, [fp, #-6]
   119e8:	e59f2010 	ldr	r2, [pc, #16]	; 11a00 <bcm2835_aux_spi_setClockDivider+0x30>
   119ec:	e5823000 	str	r3, [r2]
}
   119f0:	e1a00000 	nop			; (mov r0, r0)
   119f4:	e28bd000 	add	sp, fp, #0
   119f8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   119fc:	e12fff1e 	bx	lr
   11a00:	00027208 	.word	0x00027208

00011a04 <bcm2835_aux_spi_transfer>:
	bcm2835_aux_spi_transfernb(buf, buf, len);
}

/* Writes (and reads) a single byte to AUX SPI */
uint8_t bcm2835_aux_spi_transfer(uint8_t value)
{
   11a04:	e92d4800 	push	{fp, lr}
   11a08:	e28db004 	add	fp, sp, #4
   11a0c:	e24dd028 	sub	sp, sp, #40	; 0x28
   11a10:	e1a03000 	mov	r3, r0
   11a14:	e54b3025 	strb	r3, [fp, #-37]	; 0xffffffdb
    volatile uint32_t* cntl0 = bcm2835_spi1 + BCM2835_AUX_SPI_CNTL0/4;
   11a18:	e59f3114 	ldr	r3, [pc, #276]	; 11b34 <bcm2835_aux_spi_transfer+0x130>
   11a1c:	e5933000 	ldr	r3, [r3]
   11a20:	e50b3008 	str	r3, [fp, #-8]
    volatile uint32_t* cntl1 = bcm2835_spi1 + BCM2835_AUX_SPI_CNTL1/4;
   11a24:	e59f3108 	ldr	r3, [pc, #264]	; 11b34 <bcm2835_aux_spi_transfer+0x130>
   11a28:	e5933000 	ldr	r3, [r3]
   11a2c:	e2833004 	add	r3, r3, #4
   11a30:	e50b300c 	str	r3, [fp, #-12]
    volatile uint32_t* stat = bcm2835_spi1 + BCM2835_AUX_SPI_STAT/4;
   11a34:	e59f30f8 	ldr	r3, [pc, #248]	; 11b34 <bcm2835_aux_spi_transfer+0x130>
   11a38:	e5933000 	ldr	r3, [r3]
   11a3c:	e2833008 	add	r3, r3, #8
   11a40:	e50b3010 	str	r3, [fp, #-16]
    volatile uint32_t* io = bcm2835_spi1 + BCM2835_AUX_SPI_IO/4;
   11a44:	e59f30e8 	ldr	r3, [pc, #232]	; 11b34 <bcm2835_aux_spi_transfer+0x130>
   11a48:	e5933000 	ldr	r3, [r3]
   11a4c:	e2833020 	add	r3, r3, #32
   11a50:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

    uint32_t data;

    uint32_t _cntl0 = (spi1_speed << BCM2835_AUX_SPI_CNTL0_SPEED_SHIFT);
   11a54:	e59f30dc 	ldr	r3, [pc, #220]	; 11b38 <bcm2835_aux_spi_transfer+0x134>
   11a58:	e5933000 	ldr	r3, [r3]
   11a5c:	e1a03a03 	lsl	r3, r3, #20
   11a60:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    _cntl0 |= BCM2835_AUX_SPI_CNTL0_CS2_N;
   11a64:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11a68:	e3833806 	orr	r3, r3, #393216	; 0x60000
   11a6c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    _cntl0 |= BCM2835_AUX_SPI_CNTL0_ENABLE;
   11a70:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11a74:	e3833b02 	orr	r3, r3, #2048	; 0x800
   11a78:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    _cntl0 |= BCM2835_AUX_SPI_CNTL0_MSBF_OUT;
   11a7c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11a80:	e3833040 	orr	r3, r3, #64	; 0x40
   11a84:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    _cntl0 |= BCM2835_AUX_SPI_CNTL0_CPHA_IN;
   11a88:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11a8c:	e3833b01 	orr	r3, r3, #1024	; 0x400
   11a90:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
    _cntl0 |= 8; // Shift length.
   11a94:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11a98:	e3833008 	orr	r3, r3, #8
   11a9c:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8

    uint32_t _cntl1 = BCM2835_AUX_SPI_CNTL1_MSBF_IN;
   11aa0:	e3a03002 	mov	r3, #2
   11aa4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4

    bcm2835_peri_write(cntl1, _cntl1);
   11aa8:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
   11aac:	e51b000c 	ldr	r0, [fp, #-12]
   11ab0:	ebfffd38 	bl	10f98 <bcm2835_peri_write>
    bcm2835_peri_write(cntl0, _cntl0);
   11ab4:	e51b1018 	ldr	r1, [fp, #-24]	; 0xffffffe8
   11ab8:	e51b0008 	ldr	r0, [fp, #-8]
   11abc:	ebfffd35 	bl	10f98 <bcm2835_peri_write>

    bcm2835_peri_write(io, (uint32_t) bcm2835_correct_order(value) << 24);
   11ac0:	e55b3025 	ldrb	r3, [fp, #-37]	; 0xffffffdb
   11ac4:	e1a00003 	mov	r0, r3
   11ac8:	ebfffcf2 	bl	10e98 <bcm2835_correct_order>
   11acc:	e1a03000 	mov	r3, r0
   11ad0:	e1a03c03 	lsl	r3, r3, #24
   11ad4:	e1a01003 	mov	r1, r3
   11ad8:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
   11adc:	ebfffd2d 	bl	10f98 <bcm2835_peri_write>

    while (bcm2835_peri_read(stat) & BCM2835_AUX_SPI_STAT_BUSY)
   11ae0:	e1a00000 	nop			; (mov r0, r0)
   11ae4:	e51b0010 	ldr	r0, [fp, #-16]
   11ae8:	ebfffcfe 	bl	10ee8 <bcm2835_peri_read>
   11aec:	e1a03000 	mov	r3, r0
   11af0:	e2033040 	and	r3, r3, #64	; 0x40
   11af4:	e3530000 	cmp	r3, #0
   11af8:	1afffff9 	bne	11ae4 <bcm2835_aux_spi_transfer+0xe0>
        ;

    data = bcm2835_correct_order(bcm2835_peri_read(io) & 0xff);
   11afc:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
   11b00:	ebfffcf8 	bl	10ee8 <bcm2835_peri_read>
   11b04:	e1a03000 	mov	r3, r0
   11b08:	e6ef3073 	uxtb	r3, r3
   11b0c:	e1a00003 	mov	r0, r3
   11b10:	ebfffce0 	bl	10e98 <bcm2835_correct_order>
   11b14:	e1a03000 	mov	r3, r0
   11b18:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0

    bcm2835_aux_spi_reset();
   11b1c:	ebfffe65 	bl	114b8 <bcm2835_aux_spi_reset>

    return data;
   11b20:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
   11b24:	e6ef3073 	uxtb	r3, r3
}
   11b28:	e1a00003 	mov	r0, r3
   11b2c:	e24bd004 	sub	sp, fp, #4
   11b30:	e8bd8800 	pop	{fp, pc}
   11b34:	000270d0 	.word	0x000270d0
   11b38:	00027208 	.word	0x00027208

00011b3c <bcm2835_st_read>:
    return reason;
}

/* Read the System Timer Counter (64-bits) */
uint64_t bcm2835_st_read(void)
{
   11b3c:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   11b40:	e28db014 	add	fp, sp, #20
   11b44:	e24dd018 	sub	sp, sp, #24
    volatile uint32_t* paddr;
    uint32_t hi, lo;
    uint64_t st;

    if (bcm2835_st==MAP_FAILED)
   11b48:	e59f3128 	ldr	r3, [pc, #296]	; 11c78 <bcm2835_st_read+0x13c>
   11b4c:	e5933000 	ldr	r3, [r3]
   11b50:	e3730001 	cmn	r3, #1
   11b54:	1a000002 	bne	11b64 <bcm2835_st_read+0x28>
	return 0;
   11b58:	e3a02000 	mov	r2, #0
   11b5c:	e3a03000 	mov	r3, #0
   11b60:	ea000040 	b	11c68 <bcm2835_st_read+0x12c>

    paddr = bcm2835_st + BCM2835_ST_CHI/4;
   11b64:	e59f310c 	ldr	r3, [pc, #268]	; 11c78 <bcm2835_st_read+0x13c>
   11b68:	e5933000 	ldr	r3, [r3]
   11b6c:	e2833008 	add	r3, r3, #8
   11b70:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    hi = bcm2835_peri_read(paddr);
   11b74:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
   11b78:	ebfffcda 	bl	10ee8 <bcm2835_peri_read>
   11b7c:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc

    paddr = bcm2835_st + BCM2835_ST_CLO/4;
   11b80:	e59f30f0 	ldr	r3, [pc, #240]	; 11c78 <bcm2835_st_read+0x13c>
   11b84:	e5933000 	ldr	r3, [r3]
   11b88:	e2833004 	add	r3, r3, #4
   11b8c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    lo = bcm2835_peri_read(paddr);
   11b90:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
   11b94:	ebfffcd3 	bl	10ee8 <bcm2835_peri_read>
   11b98:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
    
    paddr = bcm2835_st + BCM2835_ST_CHI/4;
   11b9c:	e59f30d4 	ldr	r3, [pc, #212]	; 11c78 <bcm2835_st_read+0x13c>
   11ba0:	e5933000 	ldr	r3, [r3]
   11ba4:	e2833008 	add	r3, r3, #8
   11ba8:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    st = bcm2835_peri_read(paddr);
   11bac:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
   11bb0:	ebfffccc 	bl	10ee8 <bcm2835_peri_read>
   11bb4:	e1a03000 	mov	r3, r0
   11bb8:	e1a02003 	mov	r2, r3
   11bbc:	e3a03000 	mov	r3, #0
   11bc0:	e14b21fc 	strd	r2, [fp, #-28]	; 0xffffffe4
    
    /* Test for overflow */
    if (st == hi)
   11bc4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   11bc8:	e1a02003 	mov	r2, r3
   11bcc:	e3a03000 	mov	r3, #0
   11bd0:	e14b01dc 	ldrd	r0, [fp, #-28]	; 0xffffffe4
   11bd4:	e1510003 	cmp	r1, r3
   11bd8:	01500002 	cmpeq	r0, r2
   11bdc:	1a00000d 	bne	11c18 <bcm2835_st_read+0xdc>
    {
        st <<= 32;
   11be0:	e14b01dc 	ldrd	r0, [fp, #-28]	; 0xffffffe4
   11be4:	e3a02000 	mov	r2, #0
   11be8:	e3a03000 	mov	r3, #0
   11bec:	e1a03000 	mov	r3, r0
   11bf0:	e3a02000 	mov	r2, #0
   11bf4:	e14b21fc 	strd	r2, [fp, #-28]	; 0xffffffe4
        st += lo;
   11bf8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
   11bfc:	e1a02003 	mov	r2, r3
   11c00:	e3a03000 	mov	r3, #0
   11c04:	e14b01dc 	ldrd	r0, [fp, #-28]	; 0xffffffe4
   11c08:	e0906002 	adds	r6, r0, r2
   11c0c:	e0a17003 	adc	r7, r1, r3
   11c10:	e14b61fc 	strd	r6, [fp, #-28]	; 0xffffffe4
   11c14:	ea000012 	b	11c64 <bcm2835_st_read+0x128>
    }
    else
    {
        st <<= 32;
   11c18:	e14b01dc 	ldrd	r0, [fp, #-28]	; 0xffffffe4
   11c1c:	e3a02000 	mov	r2, #0
   11c20:	e3a03000 	mov	r3, #0
   11c24:	e1a03000 	mov	r3, r0
   11c28:	e3a02000 	mov	r2, #0
   11c2c:	e14b21fc 	strd	r2, [fp, #-28]	; 0xffffffe4
        paddr = bcm2835_st + BCM2835_ST_CLO/4;
   11c30:	e59f3040 	ldr	r3, [pc, #64]	; 11c78 <bcm2835_st_read+0x13c>
   11c34:	e5933000 	ldr	r3, [r3]
   11c38:	e2833004 	add	r3, r3, #4
   11c3c:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
        st += bcm2835_peri_read(paddr);
   11c40:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
   11c44:	ebfffca7 	bl	10ee8 <bcm2835_peri_read>
   11c48:	e1a03000 	mov	r3, r0
   11c4c:	e1a02003 	mov	r2, r3
   11c50:	e3a03000 	mov	r3, #0
   11c54:	e14b01dc 	ldrd	r0, [fp, #-28]	; 0xffffffe4
   11c58:	e0904002 	adds	r4, r0, r2
   11c5c:	e0a15003 	adc	r5, r1, r3
   11c60:	e14b41fc 	strd	r4, [fp, #-28]	; 0xffffffe4
    }
    return st;
   11c64:	e14b21dc 	ldrd	r2, [fp, #-28]	; 0xffffffe4
}
   11c68:	e1a00002 	mov	r0, r2
   11c6c:	e1a01003 	mov	r1, r3
   11c70:	e24bd014 	sub	sp, fp, #20
   11c74:	e8bd88f0 	pop	{r4, r5, r6, r7, fp, pc}
   11c78:	000270c8 	.word	0x000270c8

00011c7c <bcm2835_st_delay>:

/* Delays for the specified number of microseconds with offset */
void bcm2835_st_delay(uint64_t offset_micros, uint64_t micros)
{
   11c7c:	e92d4830 	push	{r4, r5, fp, lr}
   11c80:	e28db00c 	add	fp, sp, #12
   11c84:	e24dd018 	sub	sp, sp, #24
   11c88:	e14b01fc 	strd	r0, [fp, #-28]	; 0xffffffe4
   11c8c:	e14b22f4 	strd	r2, [fp, #-36]	; 0xffffffdc
    uint64_t compare = offset_micros + micros;
   11c90:	e14b01dc 	ldrd	r0, [fp, #-28]	; 0xffffffe4
   11c94:	e14b22d4 	ldrd	r2, [fp, #-36]	; 0xffffffdc
   11c98:	e0904002 	adds	r4, r0, r2
   11c9c:	e0a15003 	adc	r5, r1, r3
   11ca0:	e14b41f4 	strd	r4, [fp, #-20]	; 0xffffffec

    while(bcm2835_st_read() < compare)
   11ca4:	e1a00000 	nop			; (mov r0, r0)
   11ca8:	ebffffa3 	bl	11b3c <bcm2835_st_read>
   11cac:	e14b21d4 	ldrd	r2, [fp, #-20]	; 0xffffffec
   11cb0:	e1530001 	cmp	r3, r1
   11cb4:	01520000 	cmpeq	r2, r0
   11cb8:	8afffffa 	bhi	11ca8 <bcm2835_st_delay+0x2c>
	;
}
   11cbc:	e1a00000 	nop			; (mov r0, r0)
   11cc0:	e24bd00c 	sub	sp, fp, #12
   11cc4:	e8bd8830 	pop	{r4, r5, fp, pc}

00011cc8 <mapmem>:
/* Map 'size' bytes starting at 'off' in file 'fd' to memory.
// Return mapped address on success, MAP_FAILED otherwise.
// On error print message.
*/
static void *mapmem(const char *msg, size_t size, int fd, off_t off)
{
   11cc8:	e92d4810 	push	{r4, fp, lr}
   11ccc:	e28db008 	add	fp, sp, #8
   11cd0:	e24dd024 	sub	sp, sp, #36	; 0x24
   11cd4:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
   11cd8:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
   11cdc:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
   11ce0:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
    void *map = mmap(NULL, size, (PROT_READ | PROT_WRITE), MAP_SHARED, fd, off);
   11ce4:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   11ce8:	e58d3004 	str	r3, [sp, #4]
   11cec:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
   11cf0:	e58d3000 	str	r3, [sp]
   11cf4:	e3a03001 	mov	r3, #1
   11cf8:	e3a02003 	mov	r2, #3
   11cfc:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
   11d00:	e3a00000 	mov	r0, #0
   11d04:	ebfffb24 	bl	1099c <mmap@plt>
   11d08:	e50b0010 	str	r0, [fp, #-16]
    if (map == MAP_FAILED)
   11d0c:	e51b3010 	ldr	r3, [fp, #-16]
   11d10:	e3730001 	cmn	r3, #1
   11d14:	1a00000b 	bne	11d48 <mapmem+0x80>
	fprintf(stderr, "bcm2835_init: %s mmap failed: %s\n", msg, strerror(errno));
   11d18:	e59f3038 	ldr	r3, [pc, #56]	; 11d58 <mapmem+0x90>
   11d1c:	e5934000 	ldr	r4, [r3]
   11d20:	ebfffb50 	bl	10a68 <__errno_location@plt>
   11d24:	e1a03000 	mov	r3, r0
   11d28:	e5933000 	ldr	r3, [r3]
   11d2c:	e1a00003 	mov	r0, r3
   11d30:	ebfffb01 	bl	1093c <strerror@plt>
   11d34:	e1a03000 	mov	r3, r0
   11d38:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
   11d3c:	e59f1018 	ldr	r1, [pc, #24]	; 11d5c <mapmem+0x94>
   11d40:	e1a00004 	mov	r0, r4
   11d44:	ebfffb3b 	bl	10a38 <fprintf@plt>
    return map;
   11d48:	e51b3010 	ldr	r3, [fp, #-16]
}
   11d4c:	e1a00003 	mov	r0, r3
   11d50:	e24bd008 	sub	sp, fp, #8
   11d54:	e8bd8810 	pop	{r4, fp, pc}
   11d58:	00027200 	.word	0x00027200
   11d5c:	000160a0 	.word	0x000160a0

00011d60 <unmapmem>:

static void unmapmem(void **pmem, size_t size)
{
   11d60:	e92d4800 	push	{fp, lr}
   11d64:	e28db004 	add	fp, sp, #4
   11d68:	e24dd008 	sub	sp, sp, #8
   11d6c:	e50b0008 	str	r0, [fp, #-8]
   11d70:	e50b100c 	str	r1, [fp, #-12]
    if (*pmem == MAP_FAILED) return;
   11d74:	e51b3008 	ldr	r3, [fp, #-8]
   11d78:	e5933000 	ldr	r3, [r3]
   11d7c:	e3730001 	cmn	r3, #1
   11d80:	0a000008 	beq	11da8 <unmapmem+0x48>
    munmap(*pmem, size);
   11d84:	e51b3008 	ldr	r3, [fp, #-8]
   11d88:	e5933000 	ldr	r3, [r3]
   11d8c:	e51b100c 	ldr	r1, [fp, #-12]
   11d90:	e1a00003 	mov	r0, r3
   11d94:	ebfffb24 	bl	10a2c <munmap@plt>
    *pmem = MAP_FAILED;
   11d98:	e51b3008 	ldr	r3, [fp, #-8]
   11d9c:	e3e02000 	mvn	r2, #0
   11da0:	e5832000 	str	r2, [r3]
   11da4:	ea000000 	b	11dac <unmapmem+0x4c>
    if (*pmem == MAP_FAILED) return;
   11da8:	e1a00000 	nop			; (mov r0, r0)
}
   11dac:	e24bd004 	sub	sp, fp, #4
   11db0:	e8bd8800 	pop	{fp, pc}

00011db4 <bcm2835_init>:

/* Initialise this library. */
int bcm2835_init(void)
{
   11db4:	e92d4810 	push	{r4, fp, lr}
   11db8:	e28db008 	add	fp, sp, #8
   11dbc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    int  memfd;
    int  ok;
    FILE *fp;

    if (debug) 
   11dc0:	e59f34fc 	ldr	r3, [pc, #1276]	; 122c4 <bcm2835_init+0x510>
   11dc4:	e5d33000 	ldrb	r3, [r3]
   11dc8:	e3530000 	cmp	r3, #0
   11dcc:	0a00003b 	beq	11ec0 <bcm2835_init+0x10c>
    {
        bcm2835_peripherals = (uint32_t*)BCM2835_PERI_BASE;
   11dd0:	e59f34f0 	ldr	r3, [pc, #1264]	; 122c8 <bcm2835_init+0x514>
   11dd4:	e3a02202 	mov	r2, #536870912	; 0x20000000
   11dd8:	e5832000 	str	r2, [r3]

	bcm2835_pads = bcm2835_peripherals + BCM2835_GPIO_PADS/4;
   11ddc:	e59f34e4 	ldr	r3, [pc, #1252]	; 122c8 <bcm2835_init+0x514>
   11de0:	e5933000 	ldr	r3, [r3]
   11de4:	e2833601 	add	r3, r3, #1048576	; 0x100000
   11de8:	e59f24dc 	ldr	r2, [pc, #1244]	; 122cc <bcm2835_init+0x518>
   11dec:	e5823000 	str	r3, [r2]
	bcm2835_clk  = bcm2835_peripherals + BCM2835_CLOCK_BASE/4;
   11df0:	e59f34d0 	ldr	r3, [pc, #1232]	; 122c8 <bcm2835_init+0x514>
   11df4:	e5933000 	ldr	r3, [r3]
   11df8:	e2833601 	add	r3, r3, #1048576	; 0x100000
   11dfc:	e2833a01 	add	r3, r3, #4096	; 0x1000
   11e00:	e59f24c8 	ldr	r2, [pc, #1224]	; 122d0 <bcm2835_init+0x51c>
   11e04:	e5823000 	str	r3, [r2]
	bcm2835_gpio = bcm2835_peripherals + BCM2835_GPIO_BASE/4;
   11e08:	e59f34b8 	ldr	r3, [pc, #1208]	; 122c8 <bcm2835_init+0x514>
   11e0c:	e5933000 	ldr	r3, [r3]
   11e10:	e2833602 	add	r3, r3, #2097152	; 0x200000
   11e14:	e59f24b8 	ldr	r2, [pc, #1208]	; 122d4 <bcm2835_init+0x520>
   11e18:	e5823000 	str	r3, [r2]
	bcm2835_pwm  = bcm2835_peripherals + BCM2835_GPIO_PWM/4;
   11e1c:	e59f34a4 	ldr	r3, [pc, #1188]	; 122c8 <bcm2835_init+0x514>
   11e20:	e5933000 	ldr	r3, [r3]
   11e24:	e2833983 	add	r3, r3, #2146304	; 0x20c000
   11e28:	e59f24a8 	ldr	r2, [pc, #1192]	; 122d8 <bcm2835_init+0x524>
   11e2c:	e5823000 	str	r3, [r2]
	bcm2835_spi0 = bcm2835_peripherals + BCM2835_SPI0_BASE/4;
   11e30:	e59f3490 	ldr	r3, [pc, #1168]	; 122c8 <bcm2835_init+0x514>
   11e34:	e5933000 	ldr	r3, [r3]
   11e38:	e2833981 	add	r3, r3, #2113536	; 0x204000
   11e3c:	e59f2498 	ldr	r2, [pc, #1176]	; 122dc <bcm2835_init+0x528>
   11e40:	e5823000 	str	r3, [r2]
	bcm2835_bsc0 = bcm2835_peripherals + BCM2835_BSC0_BASE/4;
   11e44:	e59f347c 	ldr	r3, [pc, #1148]	; 122c8 <bcm2835_init+0x514>
   11e48:	e5933000 	ldr	r3, [r3]
   11e4c:	e2833981 	add	r3, r3, #2113536	; 0x204000
   11e50:	e2833a01 	add	r3, r3, #4096	; 0x1000
   11e54:	e59f2484 	ldr	r2, [pc, #1156]	; 122e0 <bcm2835_init+0x52c>
   11e58:	e5823000 	str	r3, [r2]
	bcm2835_bsc1 = bcm2835_peripherals + BCM2835_BSC1_BASE/4;
   11e5c:	e59f3464 	ldr	r3, [pc, #1124]	; 122c8 <bcm2835_init+0x514>
   11e60:	e5933000 	ldr	r3, [r3]
   11e64:	e2833502 	add	r3, r3, #8388608	; 0x800000
   11e68:	e2833901 	add	r3, r3, #16384	; 0x4000
   11e6c:	e59f2470 	ldr	r2, [pc, #1136]	; 122e4 <bcm2835_init+0x530>
   11e70:	e5823000 	str	r3, [r2]
	bcm2835_st   = bcm2835_peripherals + BCM2835_ST_BASE/4;
   11e74:	e59f344c 	ldr	r3, [pc, #1100]	; 122c8 <bcm2835_init+0x514>
   11e78:	e5933000 	ldr	r3, [r3]
   11e7c:	e2833a03 	add	r3, r3, #12288	; 0x3000
   11e80:	e59f2460 	ldr	r2, [pc, #1120]	; 122e8 <bcm2835_init+0x534>
   11e84:	e5823000 	str	r3, [r2]
	bcm2835_aux  = bcm2835_peripherals + BCM2835_AUX_BASE/4;
   11e88:	e59f3438 	ldr	r3, [pc, #1080]	; 122c8 <bcm2835_init+0x514>
   11e8c:	e5933000 	ldr	r3, [r3]
   11e90:	e2833985 	add	r3, r3, #2179072	; 0x214000
   11e94:	e2833a01 	add	r3, r3, #4096	; 0x1000
   11e98:	e59f244c 	ldr	r2, [pc, #1100]	; 122ec <bcm2835_init+0x538>
   11e9c:	e5823000 	str	r3, [r2]
	bcm2835_spi1 = bcm2835_peripherals + BCM2835_SPI1_BASE/4;
   11ea0:	e59f3420 	ldr	r3, [pc, #1056]	; 122c8 <bcm2835_init+0x514>
   11ea4:	e5933000 	ldr	r3, [r3]
   11ea8:	e2833985 	add	r3, r3, #2179072	; 0x214000
   11eac:	e2833d42 	add	r3, r3, #4224	; 0x1080
   11eb0:	e59f2438 	ldr	r2, [pc, #1080]	; 122f0 <bcm2835_init+0x53c>
   11eb4:	e5823000 	str	r3, [r2]

	return 1; /* Success */
   11eb8:	e3a03001 	mov	r3, #1
   11ebc:	ea0000fd 	b	122b8 <bcm2835_init+0x504>
    }

    /* Figure out the base and size of the peripheral address block
    // using the device-tree. Required for RPi2/3/4, optional for RPi 1
    */
    if ((fp = fopen(BMC2835_RPI2_DT_FILENAME , "rb")))
   11ec0:	e59f142c 	ldr	r1, [pc, #1068]	; 122f4 <bcm2835_init+0x540>
   11ec4:	e59f042c 	ldr	r0, [pc, #1068]	; 122f8 <bcm2835_init+0x544>
   11ec8:	ebfffaaa 	bl	10978 <fopen@plt>
   11ecc:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
   11ed0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
   11ed4:	e3530000 	cmp	r3, #0
   11ed8:	0a000059 	beq	12044 <bcm2835_init+0x290>
    {
        unsigned char buf[16];
        uint32_t base_address;
        uint32_t peri_size;
        if (fread(buf, 1, sizeof(buf), fp) >= 8)
   11edc:	e24b0030 	sub	r0, fp, #48	; 0x30
   11ee0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
   11ee4:	e3a02010 	mov	r2, #16
   11ee8:	e3a01001 	mov	r1, #1
   11eec:	ebfffab0 	bl	109b4 <fread@plt>
   11ef0:	e1a03000 	mov	r3, r0
   11ef4:	e3530007 	cmp	r3, #7
   11ef8:	9a00004f 	bls	1203c <bcm2835_init+0x288>
        {
            base_address = (buf[4] << 24) |
   11efc:	e55b302c 	ldrb	r3, [fp, #-44]	; 0xffffffd4
   11f00:	e1a02c03 	lsl	r2, r3, #24
              (buf[5] << 16) |
   11f04:	e55b302b 	ldrb	r3, [fp, #-43]	; 0xffffffd5
   11f08:	e1a03803 	lsl	r3, r3, #16
            base_address = (buf[4] << 24) |
   11f0c:	e1822003 	orr	r2, r2, r3
              (buf[6] << 8) |
   11f10:	e55b302a 	ldrb	r3, [fp, #-42]	; 0xffffffd6
   11f14:	e1a03403 	lsl	r3, r3, #8
              (buf[5] << 16) |
   11f18:	e1823003 	orr	r3, r2, r3
              (buf[7] << 0);
   11f1c:	e55b2029 	ldrb	r2, [fp, #-41]	; 0xffffffd7
              (buf[6] << 8) |
   11f20:	e1833002 	orr	r3, r3, r2
            base_address = (buf[4] << 24) |
   11f24:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
            
            peri_size = (buf[8] << 24) |
   11f28:	e55b3028 	ldrb	r3, [fp, #-40]	; 0xffffffd8
   11f2c:	e1a02c03 	lsl	r2, r3, #24
              (buf[9] << 16) |
   11f30:	e55b3027 	ldrb	r3, [fp, #-39]	; 0xffffffd9
   11f34:	e1a03803 	lsl	r3, r3, #16
            peri_size = (buf[8] << 24) |
   11f38:	e1822003 	orr	r2, r2, r3
              (buf[10] << 8) |
   11f3c:	e55b3026 	ldrb	r3, [fp, #-38]	; 0xffffffda
   11f40:	e1a03403 	lsl	r3, r3, #8
              (buf[9] << 16) |
   11f44:	e1823003 	orr	r3, r2, r3
              (buf[11] << 0);
   11f48:	e55b2025 	ldrb	r2, [fp, #-37]	; 0xffffffdb
              (buf[10] << 8) |
   11f4c:	e1833002 	orr	r3, r3, r2
            peri_size = (buf[8] << 24) |
   11f50:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
            
            if (!base_address)
   11f54:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11f58:	e3530000 	cmp	r3, #0
   11f5c:	1a000015 	bne	11fb8 <bcm2835_init+0x204>
            {
                /* looks like RPI 4 */
                base_address = (buf[8] << 24) |
   11f60:	e55b3028 	ldrb	r3, [fp, #-40]	; 0xffffffd8
   11f64:	e1a02c03 	lsl	r2, r3, #24
                      (buf[9] << 16) |
   11f68:	e55b3027 	ldrb	r3, [fp, #-39]	; 0xffffffd9
   11f6c:	e1a03803 	lsl	r3, r3, #16
                base_address = (buf[8] << 24) |
   11f70:	e1822003 	orr	r2, r2, r3
                      (buf[10] << 8) |
   11f74:	e55b3026 	ldrb	r3, [fp, #-38]	; 0xffffffda
   11f78:	e1a03403 	lsl	r3, r3, #8
                      (buf[9] << 16) |
   11f7c:	e1823003 	orr	r3, r2, r3
                      (buf[11] << 0);
   11f80:	e55b2025 	ldrb	r2, [fp, #-37]	; 0xffffffdb
                      (buf[10] << 8) |
   11f84:	e1833002 	orr	r3, r3, r2
                base_address = (buf[8] << 24) |
   11f88:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
                      
                peri_size = (buf[12] << 24) |
   11f8c:	e55b3024 	ldrb	r3, [fp, #-36]	; 0xffffffdc
   11f90:	e1a02c03 	lsl	r2, r3, #24
                (buf[13] << 16) |
   11f94:	e55b3023 	ldrb	r3, [fp, #-35]	; 0xffffffdd
   11f98:	e1a03803 	lsl	r3, r3, #16
                peri_size = (buf[12] << 24) |
   11f9c:	e1822003 	orr	r2, r2, r3
                (buf[14] << 8) |
   11fa0:	e55b3022 	ldrb	r3, [fp, #-34]	; 0xffffffde
   11fa4:	e1a03403 	lsl	r3, r3, #8
                (buf[13] << 16) |
   11fa8:	e1823003 	orr	r3, r2, r3
                (buf[15] << 0);
   11fac:	e55b2021 	ldrb	r2, [fp, #-33]	; 0xffffffdf
                (buf[14] << 8) |
   11fb0:	e1833002 	orr	r3, r3, r2
                peri_size = (buf[12] << 24) |
   11fb4:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
            }
            /* check for valid known range formats */
            if ((buf[0] == 0x7e) &&
   11fb8:	e55b3030 	ldrb	r3, [fp, #-48]	; 0xffffffd0
   11fbc:	e353007e 	cmp	r3, #126	; 0x7e
   11fc0:	1a00001d 	bne	1203c <bcm2835_init+0x288>
                    (buf[1] == 0x00) &&
   11fc4:	e55b302f 	ldrb	r3, [fp, #-47]	; 0xffffffd1
            if ((buf[0] == 0x7e) &&
   11fc8:	e3530000 	cmp	r3, #0
   11fcc:	1a00001a 	bne	1203c <bcm2835_init+0x288>
                    (buf[2] == 0x00) &&
   11fd0:	e55b302e 	ldrb	r3, [fp, #-46]	; 0xffffffd2
                    (buf[1] == 0x00) &&
   11fd4:	e3530000 	cmp	r3, #0
   11fd8:	1a000017 	bne	1203c <bcm2835_init+0x288>
                    (buf[3] == 0x00) &&
   11fdc:	e55b302d 	ldrb	r3, [fp, #-45]	; 0xffffffd3
                    (buf[2] == 0x00) &&
   11fe0:	e3530000 	cmp	r3, #0
   11fe4:	1a000014 	bne	1203c <bcm2835_init+0x288>
                    (buf[3] == 0x00) &&
   11fe8:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11fec:	e3530202 	cmp	r3, #536870912	; 0x20000000
   11ff0:	0a000005 	beq	1200c <bcm2835_init+0x258>
                    ((base_address == BCM2835_PERI_BASE) || (base_address == BCM2835_RPI2_PERI_BASE) || (base_address == BCM2835_RPI4_PERI_BASE)))
   11ff4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   11ff8:	e353043f 	cmp	r3, #1056964608	; 0x3f000000
   11ffc:	0a000002 	beq	1200c <bcm2835_init+0x258>
   12000:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   12004:	e35304fe 	cmp	r3, #-33554432	; 0xfe000000
   12008:	1a00000b 	bne	1203c <bcm2835_init+0x288>
            {
                bcm2835_peripherals_base = (off_t)base_address;
   1200c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   12010:	e59f22e4 	ldr	r2, [pc, #740]	; 122fc <bcm2835_init+0x548>
   12014:	e5823000 	str	r3, [r2]
                bcm2835_peripherals_size = (size_t)peri_size;
   12018:	e59f22e0 	ldr	r2, [pc, #736]	; 12300 <bcm2835_init+0x54c>
   1201c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   12020:	e5823000 	str	r3, [r2]
                if( base_address == BCM2835_RPI4_PERI_BASE )
   12024:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   12028:	e35304fe 	cmp	r3, #-33554432	; 0xfe000000
   1202c:	1a000002 	bne	1203c <bcm2835_init+0x288>
                {
                    pud_type_rpi4 = 1;
   12030:	e59f32cc 	ldr	r3, [pc, #716]	; 12304 <bcm2835_init+0x550>
   12034:	e3a02001 	mov	r2, #1
   12038:	e5c32000 	strb	r2, [r3]
                }
            }
        
        }
        
	fclose(fp);
   1203c:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
   12040:	ebfffa7f 	bl	10a44 <fclose@plt>
    /* Now get ready to map the peripherals block 
     * If we are not root, try for the new /dev/gpiomem interface and accept
     * the fact that we can only access GPIO
     * else try for the /dev/mem interface and get access to everything
     */
    memfd = -1;
   12044:	e3e03000 	mvn	r3, #0
   12048:	e50b3010 	str	r3, [fp, #-16]
    ok = 0;
   1204c:	e3a03000 	mov	r3, #0
   12050:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
    if (geteuid() == 0
   12054:	ebfffa6b 	bl	10a08 <geteuid@plt>
   12058:	e1a03000 	mov	r3, r0
   1205c:	e3530000 	cmp	r3, #0
   12060:	1a00005b 	bne	121d4 <bcm2835_init+0x420>
	|| bcm2835_has_capability(CAP_SYS_RAWIO)
#endif
	)
    {
      /* Open the master /dev/mem device */
      if ((memfd = open("/dev/mem", O_RDWR | O_SYNC) ) < 0) 
   12064:	e59f129c 	ldr	r1, [pc, #668]	; 12308 <bcm2835_init+0x554>
   12068:	e59f029c 	ldr	r0, [pc, #668]	; 1230c <bcm2835_init+0x558>
   1206c:	ebfffa4d 	bl	109a8 <open@plt>
   12070:	e50b0010 	str	r0, [fp, #-16]
   12074:	e51b3010 	ldr	r3, [fp, #-16]
   12078:	e3530000 	cmp	r3, #0
   1207c:	aa00000c 	bge	120b4 <bcm2835_init+0x300>
	{
	  fprintf(stderr, "bcm2835_init: Unable to open /dev/mem: %s\n",
   12080:	e59f3288 	ldr	r3, [pc, #648]	; 12310 <bcm2835_init+0x55c>
   12084:	e5934000 	ldr	r4, [r3]
		  strerror(errno)) ;
   12088:	ebfffa76 	bl	10a68 <__errno_location@plt>
   1208c:	e1a03000 	mov	r3, r0
	  fprintf(stderr, "bcm2835_init: Unable to open /dev/mem: %s\n",
   12090:	e5933000 	ldr	r3, [r3]
   12094:	e1a00003 	mov	r0, r3
   12098:	ebfffa27 	bl	1093c <strerror@plt>
   1209c:	e1a03000 	mov	r3, r0
   120a0:	e1a02003 	mov	r2, r3
   120a4:	e59f1268 	ldr	r1, [pc, #616]	; 12314 <bcm2835_init+0x560>
   120a8:	e1a00004 	mov	r0, r4
   120ac:	ebfffa61 	bl	10a38 <fprintf@plt>
	  goto exit;
   120b0:	ea000076 	b	12290 <bcm2835_init+0x4dc>
	}
      
      /* Base of the peripherals block is mapped to VM */
      bcm2835_peripherals = mapmem("gpio", bcm2835_peripherals_size, memfd, bcm2835_peripherals_base);
   120b4:	e59f3244 	ldr	r3, [pc, #580]	; 12300 <bcm2835_init+0x54c>
   120b8:	e5931000 	ldr	r1, [r3]
   120bc:	e59f3238 	ldr	r3, [pc, #568]	; 122fc <bcm2835_init+0x548>
   120c0:	e5933000 	ldr	r3, [r3]
   120c4:	e51b2010 	ldr	r2, [fp, #-16]
   120c8:	e59f0248 	ldr	r0, [pc, #584]	; 12318 <bcm2835_init+0x564>
   120cc:	ebfffefd 	bl	11cc8 <mapmem>
   120d0:	e1a02000 	mov	r2, r0
   120d4:	e59f31ec 	ldr	r3, [pc, #492]	; 122c8 <bcm2835_init+0x514>
   120d8:	e5832000 	str	r2, [r3]
      if (bcm2835_peripherals == MAP_FAILED) goto exit;
   120dc:	e59f31e4 	ldr	r3, [pc, #484]	; 122c8 <bcm2835_init+0x514>
   120e0:	e5933000 	ldr	r3, [r3]
   120e4:	e3730001 	cmn	r3, #1
   120e8:	0a000065 	beq	12284 <bcm2835_init+0x4d0>
      
      /* Now compute the base addresses of various peripherals, 
      // which are at fixed offsets within the mapped peripherals block
      // Caution: bcm2835_peripherals is uint32_t*, so divide offsets by 4
      */
      bcm2835_gpio = bcm2835_peripherals + BCM2835_GPIO_BASE/4;
   120ec:	e59f31d4 	ldr	r3, [pc, #468]	; 122c8 <bcm2835_init+0x514>
   120f0:	e5933000 	ldr	r3, [r3]
   120f4:	e2833602 	add	r3, r3, #2097152	; 0x200000
   120f8:	e59f21d4 	ldr	r2, [pc, #468]	; 122d4 <bcm2835_init+0x520>
   120fc:	e5823000 	str	r3, [r2]
      bcm2835_pwm  = bcm2835_peripherals + BCM2835_GPIO_PWM/4;
   12100:	e59f31c0 	ldr	r3, [pc, #448]	; 122c8 <bcm2835_init+0x514>
   12104:	e5933000 	ldr	r3, [r3]
   12108:	e2833983 	add	r3, r3, #2146304	; 0x20c000
   1210c:	e59f21c4 	ldr	r2, [pc, #452]	; 122d8 <bcm2835_init+0x524>
   12110:	e5823000 	str	r3, [r2]
      bcm2835_clk  = bcm2835_peripherals + BCM2835_CLOCK_BASE/4;
   12114:	e59f31ac 	ldr	r3, [pc, #428]	; 122c8 <bcm2835_init+0x514>
   12118:	e5933000 	ldr	r3, [r3]
   1211c:	e2833601 	add	r3, r3, #1048576	; 0x100000
   12120:	e2833a01 	add	r3, r3, #4096	; 0x1000
   12124:	e59f21a4 	ldr	r2, [pc, #420]	; 122d0 <bcm2835_init+0x51c>
   12128:	e5823000 	str	r3, [r2]
      bcm2835_pads = bcm2835_peripherals + BCM2835_GPIO_PADS/4;
   1212c:	e59f3194 	ldr	r3, [pc, #404]	; 122c8 <bcm2835_init+0x514>
   12130:	e5933000 	ldr	r3, [r3]
   12134:	e2833601 	add	r3, r3, #1048576	; 0x100000
   12138:	e59f218c 	ldr	r2, [pc, #396]	; 122cc <bcm2835_init+0x518>
   1213c:	e5823000 	str	r3, [r2]
      bcm2835_spi0 = bcm2835_peripherals + BCM2835_SPI0_BASE/4;
   12140:	e59f3180 	ldr	r3, [pc, #384]	; 122c8 <bcm2835_init+0x514>
   12144:	e5933000 	ldr	r3, [r3]
   12148:	e2833981 	add	r3, r3, #2113536	; 0x204000
   1214c:	e59f2188 	ldr	r2, [pc, #392]	; 122dc <bcm2835_init+0x528>
   12150:	e5823000 	str	r3, [r2]
      bcm2835_bsc0 = bcm2835_peripherals + BCM2835_BSC0_BASE/4; /* I2C */
   12154:	e59f316c 	ldr	r3, [pc, #364]	; 122c8 <bcm2835_init+0x514>
   12158:	e5933000 	ldr	r3, [r3]
   1215c:	e2833981 	add	r3, r3, #2113536	; 0x204000
   12160:	e2833a01 	add	r3, r3, #4096	; 0x1000
   12164:	e59f2174 	ldr	r2, [pc, #372]	; 122e0 <bcm2835_init+0x52c>
   12168:	e5823000 	str	r3, [r2]
      bcm2835_bsc1 = bcm2835_peripherals + BCM2835_BSC1_BASE/4; /* I2C */
   1216c:	e59f3154 	ldr	r3, [pc, #340]	; 122c8 <bcm2835_init+0x514>
   12170:	e5933000 	ldr	r3, [r3]
   12174:	e2833502 	add	r3, r3, #8388608	; 0x800000
   12178:	e2833901 	add	r3, r3, #16384	; 0x4000
   1217c:	e59f2160 	ldr	r2, [pc, #352]	; 122e4 <bcm2835_init+0x530>
   12180:	e5823000 	str	r3, [r2]
      bcm2835_st   = bcm2835_peripherals + BCM2835_ST_BASE/4;
   12184:	e59f313c 	ldr	r3, [pc, #316]	; 122c8 <bcm2835_init+0x514>
   12188:	e5933000 	ldr	r3, [r3]
   1218c:	e2833a03 	add	r3, r3, #12288	; 0x3000
   12190:	e59f2150 	ldr	r2, [pc, #336]	; 122e8 <bcm2835_init+0x534>
   12194:	e5823000 	str	r3, [r2]
      bcm2835_aux  = bcm2835_peripherals + BCM2835_AUX_BASE/4;
   12198:	e59f3128 	ldr	r3, [pc, #296]	; 122c8 <bcm2835_init+0x514>
   1219c:	e5933000 	ldr	r3, [r3]
   121a0:	e2833985 	add	r3, r3, #2179072	; 0x214000
   121a4:	e2833a01 	add	r3, r3, #4096	; 0x1000
   121a8:	e59f213c 	ldr	r2, [pc, #316]	; 122ec <bcm2835_init+0x538>
   121ac:	e5823000 	str	r3, [r2]
      bcm2835_spi1 = bcm2835_peripherals + BCM2835_SPI1_BASE/4;
   121b0:	e59f3110 	ldr	r3, [pc, #272]	; 122c8 <bcm2835_init+0x514>
   121b4:	e5933000 	ldr	r3, [r3]
   121b8:	e2833985 	add	r3, r3, #2179072	; 0x214000
   121bc:	e2833d42 	add	r3, r3, #4224	; 0x1080
   121c0:	e59f2128 	ldr	r2, [pc, #296]	; 122f0 <bcm2835_init+0x53c>
   121c4:	e5823000 	str	r3, [r2]

      ok = 1;
   121c8:	e3a03001 	mov	r3, #1
   121cc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
   121d0:	ea00002e 	b	12290 <bcm2835_init+0x4dc>
    }
    else
    {
      /* Not root, try /dev/gpiomem */
      /* Open the master /dev/mem device */
      if ((memfd = open("/dev/gpiomem", O_RDWR | O_SYNC) ) < 0) 
   121d4:	e59f112c 	ldr	r1, [pc, #300]	; 12308 <bcm2835_init+0x554>
   121d8:	e59f013c 	ldr	r0, [pc, #316]	; 1231c <bcm2835_init+0x568>
   121dc:	ebfff9f1 	bl	109a8 <open@plt>
   121e0:	e50b0010 	str	r0, [fp, #-16]
   121e4:	e51b3010 	ldr	r3, [fp, #-16]
   121e8:	e3530000 	cmp	r3, #0
   121ec:	aa00000c 	bge	12224 <bcm2835_init+0x470>
	{
	  fprintf(stderr, "bcm2835_init: Unable to open /dev/gpiomem: %s\n",
   121f0:	e59f3118 	ldr	r3, [pc, #280]	; 12310 <bcm2835_init+0x55c>
   121f4:	e5934000 	ldr	r4, [r3]
		  strerror(errno)) ;
   121f8:	ebfffa1a 	bl	10a68 <__errno_location@plt>
   121fc:	e1a03000 	mov	r3, r0
	  fprintf(stderr, "bcm2835_init: Unable to open /dev/gpiomem: %s\n",
   12200:	e5933000 	ldr	r3, [r3]
   12204:	e1a00003 	mov	r0, r3
   12208:	ebfff9cb 	bl	1093c <strerror@plt>
   1220c:	e1a03000 	mov	r3, r0
   12210:	e1a02003 	mov	r2, r3
   12214:	e59f1104 	ldr	r1, [pc, #260]	; 12320 <bcm2835_init+0x56c>
   12218:	e1a00004 	mov	r0, r4
   1221c:	ebfffa05 	bl	10a38 <fprintf@plt>
	  goto exit;
   12220:	ea00001a 	b	12290 <bcm2835_init+0x4dc>
	}
      
      /* Base of the peripherals block is mapped to VM */
      bcm2835_peripherals_base = 0;
   12224:	e59f30d0 	ldr	r3, [pc, #208]	; 122fc <bcm2835_init+0x548>
   12228:	e3a02000 	mov	r2, #0
   1222c:	e5832000 	str	r2, [r3]
      bcm2835_peripherals = mapmem("gpio", bcm2835_peripherals_size, memfd, bcm2835_peripherals_base);
   12230:	e59f30c8 	ldr	r3, [pc, #200]	; 12300 <bcm2835_init+0x54c>
   12234:	e5931000 	ldr	r1, [r3]
   12238:	e59f30bc 	ldr	r3, [pc, #188]	; 122fc <bcm2835_init+0x548>
   1223c:	e5933000 	ldr	r3, [r3]
   12240:	e51b2010 	ldr	r2, [fp, #-16]
   12244:	e59f00cc 	ldr	r0, [pc, #204]	; 12318 <bcm2835_init+0x564>
   12248:	ebfffe9e 	bl	11cc8 <mapmem>
   1224c:	e1a02000 	mov	r2, r0
   12250:	e59f3070 	ldr	r3, [pc, #112]	; 122c8 <bcm2835_init+0x514>
   12254:	e5832000 	str	r2, [r3]
      if (bcm2835_peripherals == MAP_FAILED) goto exit;
   12258:	e59f3068 	ldr	r3, [pc, #104]	; 122c8 <bcm2835_init+0x514>
   1225c:	e5933000 	ldr	r3, [r3]
   12260:	e3730001 	cmn	r3, #1
   12264:	0a000008 	beq	1228c <bcm2835_init+0x4d8>
      bcm2835_gpio = bcm2835_peripherals;
   12268:	e59f3058 	ldr	r3, [pc, #88]	; 122c8 <bcm2835_init+0x514>
   1226c:	e5933000 	ldr	r3, [r3]
   12270:	e59f205c 	ldr	r2, [pc, #92]	; 122d4 <bcm2835_init+0x520>
   12274:	e5823000 	str	r3, [r2]
      ok = 1;
   12278:	e3a03001 	mov	r3, #1
   1227c:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
   12280:	ea000002 	b	12290 <bcm2835_init+0x4dc>
      if (bcm2835_peripherals == MAP_FAILED) goto exit;
   12284:	e1a00000 	nop			; (mov r0, r0)
   12288:	ea000000 	b	12290 <bcm2835_init+0x4dc>
      if (bcm2835_peripherals == MAP_FAILED) goto exit;
   1228c:	e1a00000 	nop			; (mov r0, r0)
    }

exit:
    if (memfd >= 0)
   12290:	e51b3010 	ldr	r3, [fp, #-16]
   12294:	e3530000 	cmp	r3, #0
   12298:	ba000001 	blt	122a4 <bcm2835_init+0x4f0>
        close(memfd);
   1229c:	e51b0010 	ldr	r0, [fp, #-16]
   122a0:	ebfff9b1 	bl	1096c <close@plt>

    if (!ok)
   122a4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   122a8:	e3530000 	cmp	r3, #0
   122ac:	1a000000 	bne	122b4 <bcm2835_init+0x500>
	bcm2835_close();
   122b0:	eb00001b 	bl	12324 <bcm2835_close>

    return ok;
   122b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
   122b8:	e1a00003 	mov	r0, r3
   122bc:	e24bd008 	sub	sp, fp, #8
   122c0:	e8bd8810 	pop	{r4, fp, pc}
   122c4:	00027205 	.word	0x00027205
   122c8:	000270a8 	.word	0x000270a8
   122cc:	000270b8 	.word	0x000270b8
   122d0:	000270b4 	.word	0x000270b4
   122d4:	000270ac 	.word	0x000270ac
   122d8:	000270b0 	.word	0x000270b0
   122dc:	000270bc 	.word	0x000270bc
   122e0:	000270c0 	.word	0x000270c0
   122e4:	000270c4 	.word	0x000270c4
   122e8:	000270c8 	.word	0x000270c8
   122ec:	000270cc 	.word	0x000270cc
   122f0:	000270d0 	.word	0x000270d0
   122f4:	000160c4 	.word	0x000160c4
   122f8:	000160c8 	.word	0x000160c8
   122fc:	000270a0 	.word	0x000270a0
   12300:	000270a4 	.word	0x000270a4
   12304:	00027206 	.word	0x00027206
   12308:	00101002 	.word	0x00101002
   1230c:	000160e8 	.word	0x000160e8
   12310:	00027200 	.word	0x00027200
   12314:	000160f4 	.word	0x000160f4
   12318:	00016120 	.word	0x00016120
   1231c:	00016128 	.word	0x00016128
   12320:	00016138 	.word	0x00016138

00012324 <bcm2835_close>:

/* Close this library and deallocate everything */
int bcm2835_close(void)
{
   12324:	e92d4800 	push	{fp, lr}
   12328:	e28db004 	add	fp, sp, #4
    if (debug) return 1; /* Success */
   1232c:	e59f30b4 	ldr	r3, [pc, #180]	; 123e8 <bcm2835_close+0xc4>
   12330:	e5d33000 	ldrb	r3, [r3]
   12334:	e3530000 	cmp	r3, #0
   12338:	0a000001 	beq	12344 <bcm2835_close+0x20>
   1233c:	e3a03001 	mov	r3, #1
   12340:	ea000026 	b	123e0 <bcm2835_close+0xbc>

    unmapmem((void**) &bcm2835_peripherals, bcm2835_peripherals_size);
   12344:	e59f30a0 	ldr	r3, [pc, #160]	; 123ec <bcm2835_close+0xc8>
   12348:	e5933000 	ldr	r3, [r3]
   1234c:	e1a01003 	mov	r1, r3
   12350:	e59f0098 	ldr	r0, [pc, #152]	; 123f0 <bcm2835_close+0xcc>
   12354:	ebfffe81 	bl	11d60 <unmapmem>
    bcm2835_peripherals = MAP_FAILED;
   12358:	e59f3090 	ldr	r3, [pc, #144]	; 123f0 <bcm2835_close+0xcc>
   1235c:	e3e02000 	mvn	r2, #0
   12360:	e5832000 	str	r2, [r3]
    bcm2835_gpio = MAP_FAILED;
   12364:	e59f3088 	ldr	r3, [pc, #136]	; 123f4 <bcm2835_close+0xd0>
   12368:	e3e02000 	mvn	r2, #0
   1236c:	e5832000 	str	r2, [r3]
    bcm2835_pwm  = MAP_FAILED;
   12370:	e59f3080 	ldr	r3, [pc, #128]	; 123f8 <bcm2835_close+0xd4>
   12374:	e3e02000 	mvn	r2, #0
   12378:	e5832000 	str	r2, [r3]
    bcm2835_clk  = MAP_FAILED;
   1237c:	e59f3078 	ldr	r3, [pc, #120]	; 123fc <bcm2835_close+0xd8>
   12380:	e3e02000 	mvn	r2, #0
   12384:	e5832000 	str	r2, [r3]
    bcm2835_pads = MAP_FAILED;
   12388:	e59f3070 	ldr	r3, [pc, #112]	; 12400 <bcm2835_close+0xdc>
   1238c:	e3e02000 	mvn	r2, #0
   12390:	e5832000 	str	r2, [r3]
    bcm2835_spi0 = MAP_FAILED;
   12394:	e59f3068 	ldr	r3, [pc, #104]	; 12404 <bcm2835_close+0xe0>
   12398:	e3e02000 	mvn	r2, #0
   1239c:	e5832000 	str	r2, [r3]
    bcm2835_bsc0 = MAP_FAILED;
   123a0:	e59f3060 	ldr	r3, [pc, #96]	; 12408 <bcm2835_close+0xe4>
   123a4:	e3e02000 	mvn	r2, #0
   123a8:	e5832000 	str	r2, [r3]
    bcm2835_bsc1 = MAP_FAILED;
   123ac:	e59f3058 	ldr	r3, [pc, #88]	; 1240c <bcm2835_close+0xe8>
   123b0:	e3e02000 	mvn	r2, #0
   123b4:	e5832000 	str	r2, [r3]
    bcm2835_st   = MAP_FAILED;
   123b8:	e59f3050 	ldr	r3, [pc, #80]	; 12410 <bcm2835_close+0xec>
   123bc:	e3e02000 	mvn	r2, #0
   123c0:	e5832000 	str	r2, [r3]
    bcm2835_aux  = MAP_FAILED;
   123c4:	e59f3048 	ldr	r3, [pc, #72]	; 12414 <bcm2835_close+0xf0>
   123c8:	e3e02000 	mvn	r2, #0
   123cc:	e5832000 	str	r2, [r3]
    bcm2835_spi1 = MAP_FAILED;
   123d0:	e59f3040 	ldr	r3, [pc, #64]	; 12418 <bcm2835_close+0xf4>
   123d4:	e3e02000 	mvn	r2, #0
   123d8:	e5832000 	str	r2, [r3]
    return 1; /* Success */
   123dc:	e3a03001 	mov	r3, #1
}    
   123e0:	e1a00003 	mov	r0, r3
   123e4:	e8bd8800 	pop	{fp, pc}
   123e8:	00027205 	.word	0x00027205
   123ec:	000270a4 	.word	0x000270a4
   123f0:	000270a8 	.word	0x000270a8
   123f4:	000270ac 	.word	0x000270ac
   123f8:	000270b0 	.word	0x000270b0
   123fc:	000270b4 	.word	0x000270b4
   12400:	000270b8 	.word	0x000270b8
   12404:	000270bc 	.word	0x000270bc
   12408:	000270c0 	.word	0x000270c0
   1240c:	000270c4 	.word	0x000270c4
   12410:	000270c8 	.word	0x000270c8
   12414:	000270cc 	.word	0x000270cc
   12418:	000270d0 	.word	0x000270d0
   1241c:	00000000 	.word	0x00000000

00012420 <appMillis>:
/*
 * IvA: Application millis
 * The procedure returns the milliseconds after boot
 * */
uint_fast32_t appMillis(void)
{
   12420:	e92d4800 	push	{fp, lr}
   12424:	e28db004 	add	fp, sp, #4
   12428:	e24dd010 	sub	sp, sp, #16
    long            ms; // Milliseconds
    time_t          s;  // Seconds
    struct timespec spec;

    clock_gettime(CLOCK_MONOTONIC, &spec);
   1242c:	e24b3014 	sub	r3, fp, #20
   12430:	e1a01003 	mov	r1, r3
   12434:	e3a00001 	mov	r0, #1
   12438:	ebfff954 	bl	10990 <clock_gettime@plt>

    s  = spec.tv_sec;
   1243c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   12440:	e50b3008 	str	r3, [fp, #-8]
    // ms = round(spec.tv_nsec / 1.0e6); // Convert nanoseconds to milliseconds
    ms = (spec.tv_nsec / 1.0e6) + 1000 * s; // Convert nanoseconds to milliseconds
   12444:	e51b3010 	ldr	r3, [fp, #-16]
   12448:	ee073a90 	vmov	s15, r3
   1244c:	eeb87be7 	vcvt.f64.s32	d7, s15
   12450:	ed9f5b12 	vldr	d5, [pc, #72]	; 124a0 <appMillis+0x80>
   12454:	ee876b05 	vdiv.f64	d6, d7, d5
   12458:	e51b2008 	ldr	r2, [fp, #-8]
   1245c:	e1a03002 	mov	r3, r2
   12460:	e1a03283 	lsl	r3, r3, #5
   12464:	e0433002 	sub	r3, r3, r2
   12468:	e1a03103 	lsl	r3, r3, #2
   1246c:	e0833002 	add	r3, r3, r2
   12470:	e1a03183 	lsl	r3, r3, #3
   12474:	ee073a90 	vmov	s15, r3
   12478:	eeb87be7 	vcvt.f64.s32	d7, s15
   1247c:	ee367b07 	vadd.f64	d7, d6, d7
   12480:	eefd7bc7 	vcvt.s32.f64	s15, d7
   12484:	ee173a90 	vmov	r3, s15
   12488:	e50b300c 	str	r3, [fp, #-12]

    return (ms);
   1248c:	e51b300c 	ldr	r3, [fp, #-12]
}
   12490:	e1a00003 	mov	r0, r3
   12494:	e24bd004 	sub	sp, fp, #4
   12498:	e8bd8800 	pop	{fp, pc}
   1249c:	e1a00000 	nop			; (mov r0, r0)
   124a0:	00000000 	.word	0x00000000
   124a4:	412e8480 	.word	0x412e8480

000124a8 <Ind_GPIOConfig>:
extern fIndicatorLeds_Union fIndicatorLeds;

extern uint8_t  cChangingSpeed;    // Speed of varialble setting

void Ind_GPIOConfig(void)
{
   124a8:	e92d4800 	push	{fp, lr}
   124ac:	e28db004 	add	fp, sp, #4
    //output
 //  bcm2835_gpio_fsel(IND_CS_PIN, BCM2835_GPIO_FSEL_OUTP);
   bcm2835_gpio_fsel(MODUL_ISP_PIN, BCM2835_GPIO_FSEL_OUTP);
   124b0:	e3a01001 	mov	r1, #1
   124b4:	e3a00019 	mov	r0, #25
   124b8:	ebfffafc 	bl	110b0 <bcm2835_gpio_fsel>
}
   124bc:	e1a00000 	nop			; (mov r0, r0)
   124c0:	e8bd8800 	pop	{fp, pc}

000124c4 <periferal_SPI1_Init>:
function:
parameter:
Info:
******************************************************************************/
boolean periferal_SPI1_Init(void)
{
   124c4:	e92d4800 	push	{fp, lr}
   124c8:	e28db004 	add	fp, sp, #4
   124cc:	e24dd008 	sub	sp, sp, #8
    if(!bcm2835_init())
   124d0:	ebfffe37 	bl	11db4 <bcm2835_init>
   124d4:	e1a03000 	mov	r3, r0
   124d8:	e3530000 	cmp	r3, #0
   124dc:	1a000003 	bne	124f0 <periferal_SPI1_Init+0x2c>
    {
        printf("bcm2835 init failed  !!! \r\n");
   124e0:	e59f0070 	ldr	r0, [pc, #112]	; 12558 <periferal_SPI1_Init+0x94>
   124e4:	ebfff917 	bl	10948 <puts@plt>
        return (FALSE);
   124e8:	e3a03000 	mov	r3, #0
   124ec:	ea000016 	b	1254c <periferal_SPI1_Init+0x88>
    else
    {
       // printf("bcm2835 init success !!! \r\n");
    }

    Ind_GPIOConfig();
   124f0:	ebffffec 	bl	124a8 <Ind_GPIOConfig>

    uint16_t BoolFlag =
    bcm2835_aux_spi_begin();                                         //Start spi interface, set spi pin for the reuse function
   124f4:	ebfffcd4 	bl	1184c <bcm2835_aux_spi_begin>
   124f8:	e1a03000 	mov	r3, r0
    uint16_t BoolFlag =
   124fc:	e14b30b6 	strh	r3, [fp, #-6]

    if (BoolFlag)
   12500:	e15b30b6 	ldrh	r3, [fp, #-6]
   12504:	e3530000 	cmp	r3, #0
   12508:	1a000003 	bne	1251c <periferal_SPI1_Init+0x58>
    {
      // printf("spi_begin success !!! \r\n");
    }
    else
    {
       printf("spi_begin Problem !!! \r\n");
   1250c:	e59f0048 	ldr	r0, [pc, #72]	; 1255c <periferal_SPI1_Init+0x98>
   12510:	ebfff90c 	bl	10948 <puts@plt>
       return (FALSE);
   12514:	e3a03000 	mov	r3, #0
   12518:	ea00000b 	b	1254c <periferal_SPI1_Init+0x88>
    }

    bcm2835_spi_setBitOrder(BCM2835_SPI_BIT_ORDER_MSBFIRST);          //High first transmission
   1251c:	e3a00001 	mov	r0, #1
   12520:	ebfffc31 	bl	115ec <bcm2835_spi_setBitOrder>
    bcm2835_spi_setDataMode(BCM2835_SPI_MODE1);                       //spi mode 0
   12524:	e3a00001 	mov	r0, #1
   12528:	ebfffc4d 	bl	11664 <bcm2835_spi_setDataMode>
    bcm2835_spi_setClockDivider(BCM2835_SPI_CLOCK_DIVIDER_65536);     // The default
   1252c:	e3a00000 	mov	r0, #0
   12530:	ebfffc3a 	bl	11620 <bcm2835_spi_setClockDivider>
    bcm2835_spi_chipSelect(BCM2835_SPI_CS_NONE);                      // The default
   12534:	e3a00003 	mov	r0, #3
   12538:	ebfffc96 	bl	11798 <bcm2835_spi_chipSelect>
    bcm2835_spi_setChipSelectPolarity(BCM2835_SPI_CS_NONE, LOW);      // the default
   1253c:	e3a01000 	mov	r1, #0
   12540:	e3a00003 	mov	r0, #3
   12544:	ebfffca4 	bl	117dc <bcm2835_spi_setChipSelectPolarity>

    return (TRUE);
   12548:	e3a03001 	mov	r3, #1
}
   1254c:	e1a00003 	mov	r0, r3
   12550:	e24bd004 	sub	sp, fp, #4
   12554:	e8bd8800 	pop	{fp, pc}
   12558:	00016168 	.word	0x00016168
   1255c:	00016184 	.word	0x00016184

00012560 <SetIndicator>:

uint16_t SetIndicator(uint16_t Point, uint32_t Value)
{
   12560:	e92d4800 	push	{fp, lr}
   12564:	e28db004 	add	fp, sp, #4
   12568:	e24dd018 	sub	sp, sp, #24
   1256c:	e1a03000 	mov	r3, r0
   12570:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
   12574:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
#define kDigits    4
   uint16_t iDigitNumber;

   char cDataSymb;

   Error = Err_OK;
   12578:	e3a03000 	mov	r3, #0
   1257c:	e14b30b6 	strh	r3, [fp, #-6]

   if (Value > 99999)
   12580:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   12584:	e59f2174 	ldr	r2, [pc, #372]	; 12700 <SetIndicator+0x1a0>
   12588:	e1530002 	cmp	r3, r2
   1258c:	9a000003 	bls	125a0 <SetIndicator+0x40>
   {
      Value = 99999;
   12590:	e59f3168 	ldr	r3, [pc, #360]	; 12700 <SetIndicator+0x1a0>
   12594:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      Error = Err_Value;
   12598:	e3a03001 	mov	r3, #1
   1259c:	e14b30b6 	strh	r3, [fp, #-6]
   //   return(Error);
   }

   if (Point > 4)
   125a0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
   125a4:	e3530004 	cmp	r3, #4
   125a8:	9a000003 	bls	125bc <SetIndicator+0x5c>
   {
      Point = 4;
   125ac:	e3a03004 	mov	r3, #4
   125b0:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
      Error = Err_Point;
   125b4:	e3a03003 	mov	r3, #3
   125b8:	e14b30b6 	strh	r3, [fp, #-6]
   //   return(Error);
   }

   if (pTM1638board == NULL)
   125bc:	e59f3140 	ldr	r3, [pc, #320]	; 12704 <SetIndicator+0x1a4>
   125c0:	e5933000 	ldr	r3, [r3]
   125c4:	e3530000 	cmp	r3, #0
   125c8:	1a000001 	bne	125d4 <SetIndicator+0x74>
   {
      Error = Err_NoBoard;
   125cc:	e3a03004 	mov	r3, #4
   125d0:	e14b30b6 	strh	r3, [fp, #-6]
   //   return(Error);
   }

   if (bPointShifted)
   125d4:	e59f312c 	ldr	r3, [pc, #300]	; 12708 <SetIndicator+0x1a8>
   125d8:	e1d330b0 	ldrh	r3, [r3]
   125dc:	e3530000 	cmp	r3, #0
   125e0:	0a000002 	beq	125f0 <SetIndicator+0x90>
   {
      iDigitNumber = kDigits + 1;
   125e4:	e3a03005 	mov	r3, #5
   125e8:	e14b30b8 	strh	r3, [fp, #-8]
   125ec:	ea000001 	b	125f8 <SetIndicator+0x98>
   }
   else
   {
      iDigitNumber = kDigits;
   125f0:	e3a03004 	mov	r3, #4
   125f4:	e14b30b8 	strh	r3, [fp, #-8]
   }


   for (int Index = 0, Work = Value ; Index < iDigitNumber; Index++)
   125f8:	e3a03000 	mov	r3, #0
   125fc:	e50b3010 	str	r3, [fp, #-16]
   12600:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   12604:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
   12608:	ea000034 	b	126e0 <SetIndicator+0x180>
   {

      if (Work)
   1260c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   12610:	e3530000 	cmp	r3, #0
   12614:	0a00000d 	beq	12650 <SetIndicator+0xf0>
      {
         cDataSymb = Work - (Work / 10) * 10;
   12618:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
   1261c:	e59f30e8 	ldr	r3, [pc, #232]	; 1270c <SetIndicator+0x1ac>
   12620:	e0c31293 	smull	r1, r3, r3, r2
   12624:	e1a01143 	asr	r1, r3, #2
   12628:	e1a03fc2 	asr	r3, r2, #31
   1262c:	e0411003 	sub	r1, r1, r3
   12630:	e1a03001 	mov	r3, r1
   12634:	e1a03103 	lsl	r3, r3, #2
   12638:	e0833001 	add	r3, r3, r1
   1263c:	e1a03083 	lsl	r3, r3, #1
   12640:	e0421003 	sub	r1, r2, r3
   12644:	e1a03001 	mov	r3, r1
   12648:	e54b3009 	strb	r3, [fp, #-9]
   1264c:	ea000001 	b	12658 <SetIndicator+0xf8>
      }
      else
      {
         cDataSymb = 0x00;
   12650:	e3a03000 	mov	r3, #0
   12654:	e54b3009 	strb	r3, [fp, #-9]
      }

      Work = Work / 10;
   12658:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   1265c:	e59f20a8 	ldr	r2, [pc, #168]	; 1270c <SetIndicator+0x1ac>
   12660:	e0c21392 	smull	r1, r2, r2, r3
   12664:	e1a02142 	asr	r2, r2, #2
   12668:	e1a03fc3 	asr	r3, r3, #31
   1266c:	e0423003 	sub	r3, r2, r3
   12670:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

      //printf("Indicator index %d; Data %d \n", Index, cDataSymb);
      cDataSymb =  tm1638_font(cDataSymb + 48);
   12674:	e55b3009 	ldrb	r3, [fp, #-9]
   12678:	e2833030 	add	r3, r3, #48	; 0x30
   1267c:	e6ef3073 	uxtb	r3, r3
   12680:	e1a00003 	mov	r0, r3
   12684:	eb000529 	bl	13b30 <tm1638_font>
   12688:	e1a03000 	mov	r3, r0
   1268c:	e54b3009 	strb	r3, [fp, #-9]

      if (Point == Index)
   12690:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
   12694:	e51b2010 	ldr	r2, [fp, #-16]
   12698:	e1520003 	cmp	r2, r3
   1269c:	1a000003 	bne	126b0 <SetIndicator+0x150>
      {
         cDataSymb |= 0x80;
   126a0:	e55b3009 	ldrb	r3, [fp, #-9]
   126a4:	e1e03c83 	mvn	r3, r3, lsl #25
   126a8:	e1e03ca3 	mvn	r3, r3, lsr #25
   126ac:	e54b3009 	strb	r3, [fp, #-9]
      }

      tm1638_set_7seg_raw(pTM1638board, (uint8_t)(7 - Index), cDataSymb);
   126b0:	e59f304c 	ldr	r3, [pc, #76]	; 12704 <SetIndicator+0x1a4>
   126b4:	e5930000 	ldr	r0, [r3]
   126b8:	e51b3010 	ldr	r3, [fp, #-16]
   126bc:	e6ef3073 	uxtb	r3, r3
   126c0:	e2633007 	rsb	r3, r3, #7
   126c4:	e6ef3073 	uxtb	r3, r3
   126c8:	e55b2009 	ldrb	r2, [fp, #-9]
   126cc:	e1a01003 	mov	r1, r3
   126d0:	eb000460 	bl	13858 <tm1638_set_7seg_raw>
   for (int Index = 0, Work = Value ; Index < iDigitNumber; Index++)
   126d4:	e51b3010 	ldr	r3, [fp, #-16]
   126d8:	e2833001 	add	r3, r3, #1
   126dc:	e50b3010 	str	r3, [fp, #-16]
   126e0:	e15b30b8 	ldrh	r3, [fp, #-8]
   126e4:	e51b2010 	ldr	r2, [fp, #-16]
   126e8:	e1520003 	cmp	r2, r3
   126ec:	baffffc6 	blt	1260c <SetIndicator+0xac>

//      delay(100);
   }

   return Error;
   126f0:	e15b30b6 	ldrh	r3, [fp, #-6]
}
   126f4:	e1a00003 	mov	r0, r3
   126f8:	e24bd004 	sub	sp, fp, #4
   126fc:	e8bd8800 	pop	{fp, pc}
   12700:	0001869f 	.word	0x0001869f
   12704:	0002728c 	.word	0x0002728c
   12708:	00027220 	.word	0x00027220
   1270c:	66666667 	.word	0x66666667

00012710 <ledIndicator>:
/* void ledIndicator(void)
 * Procedure prepares and sends the needed states of indicator leds
 *
 * */
void ledIndicator(void)
{
   12710:	e92d4800 	push	{fp, lr}
   12714:	e28db004 	add	fp, sp, #4
   12718:	e24dd008 	sub	sp, sp, #8
   fIndicatorLeds_Union fIndicatorLedsLocal;

   fIndicatorLedsLocal.cAllLeds = 0;
   1271c:	e3a03000 	mov	r3, #0
   12720:	e54b3008 	strb	r3, [fp, #-8]

   if (bExecutiveDetected)
   12724:	e59f31d8 	ldr	r3, [pc, #472]	; 12904 <ledIndicator+0x1f4>
   12728:	e1d330b0 	ldrh	r3, [r3]
   1272c:	e3530000 	cmp	r3, #0
   12730:	0a00002a 	beq	127e0 <ledIndicator+0xd0>
   {
      //printf("Co-processor is here \r\n");

      fIndicatorLedsLocal.s.bPowerPlateNotFound = FALSE;
   12734:	e55b3008 	ldrb	r3, [fp, #-8]
   12738:	e3c33010 	bic	r3, r3, #16
   1273c:	e54b3008 	strb	r3, [fp, #-8]

      if (fPowerModulStatus.sStatus.bErrorValue1)
   12740:	e59f31c0 	ldr	r3, [pc, #448]	; 12908 <ledIndicator+0x1f8>
   12744:	e5d33000 	ldrb	r3, [r3]
   12748:	e2033002 	and	r3, r3, #2
   1274c:	e6ef3073 	uxtb	r3, r3
   12750:	e3530000 	cmp	r3, #0
   12754:	0a000003 	beq	12768 <ledIndicator+0x58>
      {
         fIndicatorLedsLocal.s.bHeaterError = TRUE;
   12758:	e55b3008 	ldrb	r3, [fp, #-8]
   1275c:	e3833080 	orr	r3, r3, #128	; 0x80
   12760:	e54b3008 	strb	r3, [fp, #-8]
   12764:	ea000002 	b	12774 <ledIndicator+0x64>
      }
      else
      {
         fIndicatorLedsLocal.s.bHeaterError = FALSE;
   12768:	e55b3008 	ldrb	r3, [fp, #-8]
   1276c:	e3c33080 	bic	r3, r3, #128	; 0x80
   12770:	e54b3008 	strb	r3, [fp, #-8]
      }

      if (fPowerModulStatus.sStatus.bErrorValue2)
   12774:	e59f318c 	ldr	r3, [pc, #396]	; 12908 <ledIndicator+0x1f8>
   12778:	e5d33000 	ldrb	r3, [r3]
   1277c:	e2033004 	and	r3, r3, #4
   12780:	e6ef3073 	uxtb	r3, r3
   12784:	e3530000 	cmp	r3, #0
   12788:	0a000003 	beq	1279c <ledIndicator+0x8c>
      {
         fIndicatorLedsLocal.s.bCoolerError = TRUE;
   1278c:	e55b3008 	ldrb	r3, [fp, #-8]
   12790:	e3833040 	orr	r3, r3, #64	; 0x40
   12794:	e54b3008 	strb	r3, [fp, #-8]
   12798:	ea000002 	b	127a8 <ledIndicator+0x98>
      }
      else
      {
         fIndicatorLedsLocal.s.bCoolerError = FALSE;
   1279c:	e55b3008 	ldrb	r3, [fp, #-8]
   127a0:	e3c33040 	bic	r3, r3, #64	; 0x40
   127a4:	e54b3008 	strb	r3, [fp, #-8]
      }

      if (fPowerModulStatus.sStatus.bErrorValue3)
   127a8:	e59f3158 	ldr	r3, [pc, #344]	; 12908 <ledIndicator+0x1f8>
   127ac:	e5d33000 	ldrb	r3, [r3]
   127b0:	e2033008 	and	r3, r3, #8
   127b4:	e6ef3073 	uxtb	r3, r3
   127b8:	e3530000 	cmp	r3, #0
   127bc:	0a000003 	beq	127d0 <ledIndicator+0xc0>
      {
         fIndicatorLedsLocal.s.bControlDiodeError = TRUE;
   127c0:	e55b3008 	ldrb	r3, [fp, #-8]
   127c4:	e3833020 	orr	r3, r3, #32
   127c8:	e54b3008 	strb	r3, [fp, #-8]
   127cc:	ea00000f 	b	12810 <ledIndicator+0x100>
      }
      else
      {
         fIndicatorLedsLocal.s.bControlDiodeError = FALSE;
   127d0:	e55b3008 	ldrb	r3, [fp, #-8]
   127d4:	e3c33020 	bic	r3, r3, #32
   127d8:	e54b3008 	strb	r3, [fp, #-8]
   127dc:	ea00000b 	b	12810 <ledIndicator+0x100>
      }
   }
   else
   {

      fIndicatorLedsLocal.s.bHeaterError = FALSE;
   127e0:	e55b3008 	ldrb	r3, [fp, #-8]
   127e4:	e3c33080 	bic	r3, r3, #128	; 0x80
   127e8:	e54b3008 	strb	r3, [fp, #-8]
      fIndicatorLedsLocal.s.bCoolerError = FALSE;
   127ec:	e55b3008 	ldrb	r3, [fp, #-8]
   127f0:	e3c33040 	bic	r3, r3, #64	; 0x40
   127f4:	e54b3008 	strb	r3, [fp, #-8]
      fIndicatorLedsLocal.s.bControlDiodeError = FALSE;
   127f8:	e55b3008 	ldrb	r3, [fp, #-8]
   127fc:	e3c33020 	bic	r3, r3, #32
   12800:	e54b3008 	strb	r3, [fp, #-8]

      fIndicatorLedsLocal.s.bPowerPlateNotFound = TRUE;
   12804:	e55b3008 	ldrb	r3, [fp, #-8]
   12808:	e3833010 	orr	r3, r3, #16
   1280c:	e54b3008 	strb	r3, [fp, #-8]
   }

   // Direction of regulator Heat/Cool
   if (lTemperatureReal > lTemperatureSet)
   12810:	e59f30f4 	ldr	r3, [pc, #244]	; 1290c <ledIndicator+0x1fc>
   12814:	e5932000 	ldr	r2, [r3]
   12818:	e59f30f0 	ldr	r3, [pc, #240]	; 12910 <ledIndicator+0x200>
   1281c:	e5933000 	ldr	r3, [r3]
   12820:	e1520003 	cmp	r2, r3
   12824:	9a000005 	bls	12840 <ledIndicator+0x130>
   {
      fIndicatorLedsLocal.s.bHeatingOrCooling = FALSE; // cooling
   12828:	e55b3008 	ldrb	r3, [fp, #-8]
   1282c:	e3c33008 	bic	r3, r3, #8
   12830:	e54b3008 	strb	r3, [fp, #-8]
      printf("bControlDiodeError \r\n");
   12834:	e59f00d8 	ldr	r0, [pc, #216]	; 12914 <ledIndicator+0x204>
   12838:	ebfff842 	bl	10948 <puts@plt>
   1283c:	ea000002 	b	1284c <ledIndicator+0x13c>
   }
   else
   {
      fIndicatorLedsLocal.s.bHeatingOrCooling = TRUE; // heating
   12840:	e55b3008 	ldrb	r3, [fp, #-8]
   12844:	e3833008 	orr	r3, r3, #8
   12848:	e54b3008 	strb	r3, [fp, #-8]

   // Celsium Or Kelvin mode of indication
#ifdef CELSIUM_MODE
   fIndicatorLedsLocal.s.bCelsiumOrKelvin = TRUE; // Celsium
#else
   fIndicatorLedsLocal.s.bCelsiumOrKelvin = FALSE; // Kelvin
   1284c:	e55b3008 	ldrb	r3, [fp, #-8]
   12850:	e3c33004 	bic	r3, r3, #4
   12854:	e54b3008 	strb	r3, [fp, #-8]
#endif

#ifdef SCANNING
   if (bScanOrSetMode)
   12858:	e59f30b8 	ldr	r3, [pc, #184]	; 12918 <ledIndicator+0x208>
   1285c:	e1d330b0 	ldrh	r3, [r3]
   12860:	e3530000 	cmp	r3, #0
   12864:	0a000012 	beq	128b4 <ledIndicator+0x1a4>
   {
      fIndicatorLedsLocal.s.bScanningMode = TRUE;
   12868:	e55b3008 	ldrb	r3, [fp, #-8]
   1286c:	e3833002 	orr	r3, r3, #2
   12870:	e54b3008 	strb	r3, [fp, #-8]
      if (bTempSetAchieved)
   12874:	e59f30a0 	ldr	r3, [pc, #160]	; 1291c <ledIndicator+0x20c>
   12878:	e1d330b0 	ldrh	r3, [r3]
   1287c:	e3530000 	cmp	r3, #0
   12880:	0a000005 	beq	1289c <ledIndicator+0x18c>
      {
         printf("Achieved \r\n");
   12884:	e59f0094 	ldr	r0, [pc, #148]	; 12920 <ledIndicator+0x210>
   12888:	ebfff82e 	bl	10948 <puts@plt>
         fIndicatorLedsLocal.s.bTemperatureAchieved = TRUE;
   1288c:	e55b3008 	ldrb	r3, [fp, #-8]
   12890:	e3833001 	orr	r3, r3, #1
   12894:	e54b3008 	strb	r3, [fp, #-8]
   12898:	ea00000d 	b	128d4 <ledIndicator+0x1c4>
      }
      else
      {
         printf("Still scanning \r\n");
   1289c:	e59f0080 	ldr	r0, [pc, #128]	; 12924 <ledIndicator+0x214>
   128a0:	ebfff828 	bl	10948 <puts@plt>
         fIndicatorLedsLocal.s.bTemperatureAchieved = FALSE;
   128a4:	e55b3008 	ldrb	r3, [fp, #-8]
   128a8:	e3c33001 	bic	r3, r3, #1
   128ac:	e54b3008 	strb	r3, [fp, #-8]
   128b0:	ea000007 	b	128d4 <ledIndicator+0x1c4>
      }
   }
   else
#endif
   {
      printf("Still scanning but here \r\n");
   128b4:	e59f006c 	ldr	r0, [pc, #108]	; 12928 <ledIndicator+0x218>
   128b8:	ebfff822 	bl	10948 <puts@plt>
      fIndicatorLedsLocal.s.bScanningMode = FALSE;
   128bc:	e55b3008 	ldrb	r3, [fp, #-8]
   128c0:	e3c33002 	bic	r3, r3, #2
   128c4:	e54b3008 	strb	r3, [fp, #-8]
      fIndicatorLedsLocal.s.bTemperatureAchieved = FALSE;
   128c8:	e55b3008 	ldrb	r3, [fp, #-8]
   128cc:	e3c33001 	bic	r3, r3, #1
   128d0:	e54b3008 	strb	r3, [fp, #-8]
   }

   // Output desired Led state
   tm1638_set_8leds(pTM1638board, fIndicatorLedsLocal.cAllLeds, 0);
   128d4:	e59f3050 	ldr	r3, [pc, #80]	; 1292c <ledIndicator+0x21c>
   128d8:	e5933000 	ldr	r3, [r3]
   128dc:	e55b1008 	ldrb	r1, [fp, #-8]
   128e0:	e3a02000 	mov	r2, #0
   128e4:	e1a00003 	mov	r0, r3
   128e8:	eb000437 	bl	139cc <tm1638_set_8leds>

   // Save global variable
   fIndicatorLeds.cAllLeds = fIndicatorLedsLocal.cAllLeds;
   128ec:	e55b2008 	ldrb	r2, [fp, #-8]
   128f0:	e59f3038 	ldr	r3, [pc, #56]	; 12930 <ledIndicator+0x220>
   128f4:	e5c32000 	strb	r2, [r3]
}
   128f8:	e1a00000 	nop			; (mov r0, r0)
   128fc:	e24bd004 	sub	sp, fp, #4
   12900:	e8bd8800 	pop	{fp, pc}
   12904:	000275d0 	.word	0x000275d0
   12908:	00027290 	.word	0x00027290
   1290c:	000271dc 	.word	0x000271dc
   12910:	000271e4 	.word	0x000271e4
   12914:	0001619c 	.word	0x0001619c
   12918:	000275ca 	.word	0x000275ca
   1291c:	000275ce 	.word	0x000275ce
   12920:	000161b4 	.word	0x000161b4
   12924:	000161c0 	.word	0x000161c0
   12928:	000161d4 	.word	0x000161d4
   1292c:	0002728c 	.word	0x0002728c
   12930:	00027288 	.word	0x00027288

00012934 <OutputVariable>:
/* ---------------------------------------------------------------------------
 * OutputVariable
 * Printing the desired variable on t1638 indicator
 * --------------------------------------------------------------------------- */
uint16_t OutputVariable(VarsForIndicator_enum eVarNumber, const sVarIndicatorDescription_struct* pIndicatorVarsTable)
{
   12934:	e92d4800 	push	{fp, lr}
   12938:	e28db004 	add	fp, sp, #4
   1293c:	e24dd018 	sub	sp, sp, #24
   12940:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
   12944:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4

   static uint32_t lBlinkTimer;
   static uint16_t iLightIntens;

   char* pcPrefix;
   boolean bResult = TRUE;
   12948:	e3a03001 	mov	r3, #1
   1294c:	e14b30ba 	strh	r3, [fp, #-10]
   uint16_t iPoint;
   uint32_t lValueToIndicator;

   lValueToIndicator = (uint32_t)((*(pIndicatorVarsTable + eVarNumber)->plVarValue));
   12950:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   12954:	e1a03203 	lsl	r3, r3, #4
   12958:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
   1295c:	e0823003 	add	r3, r2, r3
   12960:	e5933000 	ldr	r3, [r3]
   12964:	e5933000 	ldr	r3, [r3]
   12968:	e50b3010 	str	r3, [fp, #-16]

   iPoint = 1;
   1296c:	e3a03001 	mov	r3, #1
   12970:	e14b30bc 	strh	r3, [fp, #-12]
   switch (eVarNumber)
   12974:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   12978:	e3530008 	cmp	r3, #8
   1297c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   12980:	ea000072 	b	12b50 <OutputVariable+0x21c>
   12984:	000129a8 	.word	0x000129a8
   12988:	000129ec 	.word	0x000129ec
   1298c:	00012a18 	.word	0x00012a18
   12990:	00012a44 	.word	0x00012a44
   12994:	00012a70 	.word	0x00012a70
   12998:	00012aa4 	.word	0x00012aa4
   1299c:	00012abc 	.word	0x00012abc
   129a0:	00012ad4 	.word	0x00012ad4
   129a4:	00012aec 	.word	0x00012aec
   {
      case keTreal:
         pcPrefix = "Tr";
   129a8:	e59f328c 	ldr	r3, [pc, #652]	; 12c3c <OutputVariable+0x308>
   129ac:	e50b3008 	str	r3, [fp, #-8]
         if (!bPointShifted)
   129b0:	e59f3288 	ldr	r3, [pc, #648]	; 12c40 <OutputVariable+0x30c>
   129b4:	e1d330b0 	ldrh	r3, [r3]
   129b8:	e3530000 	cmp	r3, #0
   129bc:	1a000007 	bne	129e0 <OutputVariable+0xac>
         {
            lValueToIndicator = lValueToIndicator/10;
   129c0:	e51b3010 	ldr	r3, [fp, #-16]
   129c4:	e59f2278 	ldr	r2, [pc, #632]	; 12c44 <OutputVariable+0x310>
   129c8:	e0832392 	umull	r2, r3, r2, r3
   129cc:	e1a031a3 	lsr	r3, r3, #3
   129d0:	e50b3010 	str	r3, [fp, #-16]
            iPoint = 1;
   129d4:	e3a03001 	mov	r3, #1
   129d8:	e14b30bc 	strh	r3, [fp, #-12]
         }
         else
         {
            iPoint = 2;
         }
         break;
   129dc:	ea000060 	b	12b64 <OutputVariable+0x230>
            iPoint = 2;
   129e0:	e3a03002 	mov	r3, #2
   129e4:	e14b30bc 	strh	r3, [fp, #-12]
         break;
   129e8:	ea00005d 	b	12b64 <OutputVariable+0x230>

      case keTset:
         pcPrefix = "Ts";
   129ec:	e59f3254 	ldr	r3, [pc, #596]	; 12c48 <OutputVariable+0x314>
   129f0:	e50b3008 	str	r3, [fp, #-8]
         lValueToIndicator = lValueToIndicator/10;
   129f4:	e51b3010 	ldr	r3, [fp, #-16]
   129f8:	e59f2244 	ldr	r2, [pc, #580]	; 12c44 <OutputVariable+0x310>
   129fc:	e0832392 	umull	r2, r3, r2, r3
   12a00:	e1a031a3 	lsr	r3, r3, #3
   12a04:	e50b3010 	str	r3, [fp, #-16]
         bPointShifted = FALSE;
   12a08:	e59f3230 	ldr	r3, [pc, #560]	; 12c40 <OutputVariable+0x30c>
   12a0c:	e3a02000 	mov	r2, #0
   12a10:	e1c320b0 	strh	r2, [r3]
         break;
   12a14:	ea000052 	b	12b64 <OutputVariable+0x230>

      case keTcurSet:
         pcPrefix = "Tcs";
   12a18:	e59f322c 	ldr	r3, [pc, #556]	; 12c4c <OutputVariable+0x318>
   12a1c:	e50b3008 	str	r3, [fp, #-8]
         lValueToIndicator = lValueToIndicator/10;
   12a20:	e51b3010 	ldr	r3, [fp, #-16]
   12a24:	e59f2218 	ldr	r2, [pc, #536]	; 12c44 <OutputVariable+0x310>
   12a28:	e0832392 	umull	r2, r3, r2, r3
   12a2c:	e1a031a3 	lsr	r3, r3, #3
   12a30:	e50b3010 	str	r3, [fp, #-16]
         bPointShifted = FALSE;
   12a34:	e59f3204 	ldr	r3, [pc, #516]	; 12c40 <OutputVariable+0x30c>
   12a38:	e3a02000 	mov	r2, #0
   12a3c:	e1c320b0 	strh	r2, [r3]
         break;
   12a40:	ea000047 	b	12b64 <OutputVariable+0x230>

      case keDeltaT:
         pcPrefix = "dT";
   12a44:	e59f3204 	ldr	r3, [pc, #516]	; 12c50 <OutputVariable+0x31c>
   12a48:	e50b3008 	str	r3, [fp, #-8]
         lValueToIndicator = lValueToIndicator/10;
   12a4c:	e51b3010 	ldr	r3, [fp, #-16]
   12a50:	e59f21ec 	ldr	r2, [pc, #492]	; 12c44 <OutputVariable+0x310>
   12a54:	e0832392 	umull	r2, r3, r2, r3
   12a58:	e1a031a3 	lsr	r3, r3, #3
   12a5c:	e50b3010 	str	r3, [fp, #-16]
         bPointShifted = FALSE;
   12a60:	e59f31d8 	ldr	r3, [pc, #472]	; 12c40 <OutputVariable+0x30c>
   12a64:	e3a02000 	mov	r2, #0
   12a68:	e1c320b0 	strh	r2, [r3]
         break;
   12a6c:	ea00003c 	b	12b64 <OutputVariable+0x230>

      case keDeltat:
         pcPrefix = "dt";
   12a70:	e59f31dc 	ldr	r3, [pc, #476]	; 12c54 <OutputVariable+0x320>
   12a74:	e50b3008 	str	r3, [fp, #-8]
         lValueToIndicator = mDeConvIndicTime(lValueToIndicator);
   12a78:	e51b3010 	ldr	r3, [fp, #-16]
   12a7c:	e59f21d4 	ldr	r2, [pc, #468]	; 12c58 <OutputVariable+0x324>
   12a80:	e0832392 	umull	r2, r3, r2, r3
   12a84:	e1a032a3 	lsr	r3, r3, #5
   12a88:	e50b3010 	str	r3, [fp, #-16]
         iPoint = 1;
   12a8c:	e3a03001 	mov	r3, #1
   12a90:	e14b30bc 	strh	r3, [fp, #-12]
         bPointShifted = FALSE;
   12a94:	e59f31a4 	ldr	r3, [pc, #420]	; 12c40 <OutputVariable+0x30c>
   12a98:	e3a02000 	mov	r2, #0
   12a9c:	e1c320b0 	strh	r2, [r3]
         break;
   12aa0:	ea00002f 	b	12b64 <OutputVariable+0x230>

      case keKprop:
         pcPrefix = "Kpr";
   12aa4:	e59f31b0 	ldr	r3, [pc, #432]	; 12c5c <OutputVariable+0x328>
   12aa8:	e50b3008 	str	r3, [fp, #-8]
         bPointShifted = FALSE;
   12aac:	e59f318c 	ldr	r3, [pc, #396]	; 12c40 <OutputVariable+0x30c>
   12ab0:	e3a02000 	mov	r2, #0
   12ab4:	e1c320b0 	strh	r2, [r3]
         break;
   12ab8:	ea000029 	b	12b64 <OutputVariable+0x230>

      case keKint:
         pcPrefix = "Kin";
   12abc:	e59f319c 	ldr	r3, [pc, #412]	; 12c60 <OutputVariable+0x32c>
   12ac0:	e50b3008 	str	r3, [fp, #-8]
         bPointShifted = FALSE;
   12ac4:	e59f3174 	ldr	r3, [pc, #372]	; 12c40 <OutputVariable+0x30c>
   12ac8:	e3a02000 	mov	r2, #0
   12acc:	e1c320b0 	strh	r2, [r3]
         break;
   12ad0:	ea000023 	b	12b64 <OutputVariable+0x230>

      case keKdiff:
         pcPrefix = "Kdf";
   12ad4:	e59f3188 	ldr	r3, [pc, #392]	; 12c64 <OutputVariable+0x330>
   12ad8:	e50b3008 	str	r3, [fp, #-8]
         bPointShifted = FALSE;
   12adc:	e59f315c 	ldr	r3, [pc, #348]	; 12c40 <OutputVariable+0x30c>
   12ae0:	e3a02000 	mov	r2, #0
   12ae4:	e1c320b0 	strh	r2, [r3]
         break;
   12ae8:	ea00001d 	b	12b64 <OutputVariable+0x230>

      case keUreal:
         pcPrefix = "Ure";
   12aec:	e59f3174 	ldr	r3, [pc, #372]	; 12c68 <OutputVariable+0x334>
   12af0:	e50b3008 	str	r3, [fp, #-8]
         lValueToIndicator = getMicroVoltsADC(lValueToIndicator);
   12af4:	e51b0010 	ldr	r0, [fp, #-16]
   12af8:	eb0005f8 	bl	142e0 <getMicroVoltsADC>
   12afc:	e50b0010 	str	r0, [fp, #-16]

         if (bPointShifted)
   12b00:	e59f3138 	ldr	r3, [pc, #312]	; 12c40 <OutputVariable+0x30c>
   12b04:	e1d330b0 	ldrh	r3, [r3]
   12b08:	e3530000 	cmp	r3, #0
   12b0c:	0a000007 	beq	12b30 <OutputVariable+0x1fc>
         {
            lValueToIndicator = lValueToIndicator / 100;
   12b10:	e51b3010 	ldr	r3, [fp, #-16]
   12b14:	e59f213c 	ldr	r2, [pc, #316]	; 12c58 <OutputVariable+0x324>
   12b18:	e0832392 	umull	r2, r3, r2, r3
   12b1c:	e1a032a3 	lsr	r3, r3, #5
   12b20:	e50b3010 	str	r3, [fp, #-16]
            iPoint = 4;
   12b24:	e3a03004 	mov	r3, #4
   12b28:	e14b30bc 	strh	r3, [fp, #-12]
         {
            lValueToIndicator = lValueToIndicator / 1000;
            iPoint = 3;
        }

         break;
   12b2c:	ea00000c 	b	12b64 <OutputVariable+0x230>
            lValueToIndicator = lValueToIndicator / 1000;
   12b30:	e51b3010 	ldr	r3, [fp, #-16]
   12b34:	e59f2130 	ldr	r2, [pc, #304]	; 12c6c <OutputVariable+0x338>
   12b38:	e0832392 	umull	r2, r3, r2, r3
   12b3c:	e1a03323 	lsr	r3, r3, #6
   12b40:	e50b3010 	str	r3, [fp, #-16]
            iPoint = 3;
   12b44:	e3a03003 	mov	r3, #3
   12b48:	e14b30bc 	strh	r3, [fp, #-12]
         break;
   12b4c:	ea000004 	b	12b64 <OutputVariable+0x230>

      default:
         pcPrefix = "";
   12b50:	e59f3118 	ldr	r3, [pc, #280]	; 12c70 <OutputVariable+0x33c>
   12b54:	e50b3008 	str	r3, [fp, #-8]
         bResult = FALSE;
   12b58:	e3a03000 	mov	r3, #0
   12b5c:	e14b30ba 	strh	r3, [fp, #-10]
         break;
   12b60:	e1a00000 	nop			; (mov r0, r0)
   }

   if (eKeyboardState == keEnterMode)
   12b64:	e59f3108 	ldr	r3, [pc, #264]	; 12c74 <OutputVariable+0x340>
   12b68:	e5933000 	ldr	r3, [r3]
   12b6c:	e3530001 	cmp	r3, #1
   12b70:	1a00001e 	bne	12bf0 <OutputVariable+0x2bc>
   {
      if ((appMillis() - lBlinkTimer) >= kBlinkingTime)
   12b74:	ebfffe29 	bl	12420 <appMillis>
   12b78:	e1a02000 	mov	r2, r0
   12b7c:	e59f30f4 	ldr	r3, [pc, #244]	; 12c78 <OutputVariable+0x344>
   12b80:	e5933000 	ldr	r3, [r3]
   12b84:	e0423003 	sub	r3, r2, r3
   12b88:	e3530f7d 	cmp	r3, #500	; 0x1f4
   12b8c:	3a00000e 	bcc	12bcc <OutputVariable+0x298>
      {
         if (iLightIntens == kHighIntens)
   12b90:	e59f30e4 	ldr	r3, [pc, #228]	; 12c7c <OutputVariable+0x348>
   12b94:	e1d330b0 	ldrh	r3, [r3]
   12b98:	e3530007 	cmp	r3, #7
   12b9c:	1a000003 	bne	12bb0 <OutputVariable+0x27c>
         {
            iLightIntens = kLowIntens;
   12ba0:	e59f30d4 	ldr	r3, [pc, #212]	; 12c7c <OutputVariable+0x348>
   12ba4:	e3a02002 	mov	r2, #2
   12ba8:	e1c320b0 	strh	r2, [r3]
   12bac:	ea000002 	b	12bbc <OutputVariable+0x288>
         }
         else
         {
            iLightIntens = kHighIntens;
   12bb0:	e59f30c4 	ldr	r3, [pc, #196]	; 12c7c <OutputVariable+0x348>
   12bb4:	e3a02007 	mov	r2, #7
   12bb8:	e1c320b0 	strh	r2, [r3]
         }
         lBlinkTimer = appMillis();
   12bbc:	ebfffe17 	bl	12420 <appMillis>
   12bc0:	e1a02000 	mov	r2, r0
   12bc4:	e59f30ac 	ldr	r3, [pc, #172]	; 12c78 <OutputVariable+0x344>
   12bc8:	e5832000 	str	r2, [r3]
      } // else nothing to do -> waiting

      tm1638_set_intensity(pTM1638board, iLightIntens);
   12bcc:	e59f30ac 	ldr	r3, [pc, #172]	; 12c80 <OutputVariable+0x34c>
   12bd0:	e5932000 	ldr	r2, [r3]
   12bd4:	e59f30a0 	ldr	r3, [pc, #160]	; 12c7c <OutputVariable+0x348>
   12bd8:	e1d330b0 	ldrh	r3, [r3]
   12bdc:	e6ef3073 	uxtb	r3, r3
   12be0:	e1a01003 	mov	r1, r3
   12be4:	e1a00002 	mov	r0, r2
   12be8:	eb00022f 	bl	134ac <tm1638_set_intensity>
   12bec:	ea000004 	b	12c04 <OutputVariable+0x2d0>

   }
   else
   {
      tm1638_set_intensity(pTM1638board, kNormalIntens);
   12bf0:	e59f3088 	ldr	r3, [pc, #136]	; 12c80 <OutputVariable+0x34c>
   12bf4:	e5933000 	ldr	r3, [r3]
   12bf8:	e3a01005 	mov	r1, #5
   12bfc:	e1a00003 	mov	r0, r3
   12c00:	eb000229 	bl	134ac <tm1638_set_intensity>
   }


   tm1638_set_7seg_text(pTM1638board, pcPrefix, 0x00);
   12c04:	e59f3074 	ldr	r3, [pc, #116]	; 12c80 <OutputVariable+0x34c>
   12c08:	e5933000 	ldr	r3, [r3]
   12c0c:	e3a02000 	mov	r2, #0
   12c10:	e51b1008 	ldr	r1, [fp, #-8]
   12c14:	e1a00003 	mov	r0, r3
   12c18:	eb000320 	bl	138a0 <tm1638_set_7seg_text>
   SetIndicator(iPoint, lValueToIndicator);
   12c1c:	e15b30bc 	ldrh	r3, [fp, #-12]
   12c20:	e51b1010 	ldr	r1, [fp, #-16]
   12c24:	e1a00003 	mov	r0, r3
   12c28:	ebfffe4c 	bl	12560 <SetIndicator>

 return(bResult);
   12c2c:	e15b30ba 	ldrh	r3, [fp, #-10]
}
   12c30:	e1a00003 	mov	r0, r3
   12c34:	e24bd004 	sub	sp, fp, #4
   12c38:	e8bd8800 	pop	{fp, pc}
   12c3c:	000161f0 	.word	0x000161f0
   12c40:	00027220 	.word	0x00027220
   12c44:	cccccccd 	.word	0xcccccccd
   12c48:	000161f4 	.word	0x000161f4
   12c4c:	000161f8 	.word	0x000161f8
   12c50:	000161fc 	.word	0x000161fc
   12c54:	00016200 	.word	0x00016200
   12c58:	51eb851f 	.word	0x51eb851f
   12c5c:	00016204 	.word	0x00016204
   12c60:	00016208 	.word	0x00016208
   12c64:	0001620c 	.word	0x0001620c
   12c68:	00016210 	.word	0x00016210
   12c6c:	10624dd3 	.word	0x10624dd3
   12c70:	00016214 	.word	0x00016214
   12c74:	0002721c 	.word	0x0002721c
   12c78:	0002720c 	.word	0x0002720c
   12c7c:	00027210 	.word	0x00027210
   12c80:	0002728c 	.word	0x0002728c

00012c84 <OutCurrentVariable>:

void OutCurrentVariable(void)
{
   12c84:	e92d4800 	push	{fp, lr}
   12c88:	e28db004 	add	fp, sp, #4

   OutputVariable(eVarNumber, &VarForIndication[0]);
   12c8c:	e59f3018 	ldr	r3, [pc, #24]	; 12cac <OutCurrentVariable+0x28>
   12c90:	e5933000 	ldr	r3, [r3]
   12c94:	e59f1014 	ldr	r1, [pc, #20]	; 12cb0 <OutCurrentVariable+0x2c>
   12c98:	e1a00003 	mov	r0, r3
   12c9c:	ebffff24 	bl	12934 <OutputVariable>

   ledIndicator();
   12ca0:	ebfffe9a 	bl	12710 <ledIndicator>
}
   12ca4:	e1a00000 	nop			; (mov r0, r0)
   12ca8:	e8bd8800 	pop	{fp, pc}
   12cac:	00027218 	.word	0x00027218
   12cb0:	00016218 	.word	0x00016218

00012cb4 <GetKeyPressedWithDuration>:
 * The procedure returns the structure of pressed
 * The procedure should be every 100ms called
 * Only released key is taken into account
 * ---------------------------------------------------- */
KeyPressed_struct GetKeyPressedWithDuration(void)
{
   12cb4:	e92d4800 	push	{fp, lr}
   12cb8:	e28db004 	add	fp, sp, #4
   12cbc:	e24dd018 	sub	sp, sp, #24
   12cc0:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
   static uint8_t CurrentKey;

   // Output value
   KeyPressed_struct sLocalKeyPressed;

   KeyboardKeys_enum  x = GetKeyPressed();
   12cc4:	eb00007f 	bl	12ec8 <GetKeyPressed>
   12cc8:	e50b0008 	str	r0, [fp, #-8]

   if (eKeyboardState != keEnterMode)
   12ccc:	e59f31e0 	ldr	r3, [pc, #480]	; 12eb4 <GetKeyPressedWithDuration+0x200>
   12cd0:	e5933000 	ldr	r3, [r3]
   12cd4:	e3530001 	cmp	r3, #1
   12cd8:	0a000034 	beq	12db0 <GetKeyPressedWithDuration+0xfc>
   {  // if not Enter mode the reaction on released button

      if ((x)&&(x != keUnknown))
   12cdc:	e51b3008 	ldr	r3, [fp, #-8]
   12ce0:	e3530000 	cmp	r3, #0
   12ce4:	0a000017 	beq	12d48 <GetKeyPressedWithDuration+0x94>
   12ce8:	e51b3008 	ldr	r3, [fp, #-8]
   12cec:	e3530018 	cmp	r3, #24
   12cf0:	0a000014 	beq	12d48 <GetKeyPressedWithDuration+0x94>
      {
         if (x == CurrentKey)
   12cf4:	e59f31bc 	ldr	r3, [pc, #444]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12cf8:	e5d33000 	ldrb	r3, [r3]
   12cfc:	e1a02003 	mov	r2, r3
   12d00:	e51b3008 	ldr	r3, [fp, #-8]
   12d04:	e1530002 	cmp	r3, r2
   12d08:	0a000007 	beq	12d2c <GetKeyPressedWithDuration+0x78>
         {
            // TimePressing still running
         }
         else
         {
            CurrentKey = x;
   12d0c:	e51b3008 	ldr	r3, [fp, #-8]
   12d10:	e6ef2073 	uxtb	r2, r3
   12d14:	e59f319c 	ldr	r3, [pc, #412]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12d18:	e5c32000 	strb	r2, [r3]
            TimePressing = appMillis();
   12d1c:	ebfffdbf 	bl	12420 <appMillis>
   12d20:	e1a02000 	mov	r2, r0
   12d24:	e59f3190 	ldr	r3, [pc, #400]	; 12ebc <GetKeyPressedWithDuration+0x208>
   12d28:	e5832000 	str	r2, [r3]
         }

         // The key still pressed -> nothing to return
         sLocalKeyPressed.eKeyNumber = 0;
   12d2c:	e3a03000 	mov	r3, #0
   12d30:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
         sLocalKeyPressed.cLongTimePressing = FALSE;
   12d34:	e3a03000 	mov	r3, #0
   12d38:	e54b3010 	strb	r3, [fp, #-16]

         sLocalKeyPressed.bCurrentlyPressed = TRUE;
   12d3c:	e3a03001 	mov	r3, #1
   12d40:	e14b30be 	strh	r3, [fp, #-14]
   12d44:	ea000052 	b	12e94 <GetKeyPressedWithDuration+0x1e0>
      }
      else
      {
         // Key is released - therefore prepare output
         sLocalKeyPressed.eKeyNumber = CurrentKey;
   12d48:	e59f3168 	ldr	r3, [pc, #360]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12d4c:	e5d33000 	ldrb	r3, [r3]
   12d50:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
         TimeDelta = (appMillis() - TimePressing);
   12d54:	ebfffdb1 	bl	12420 <appMillis>
   12d58:	e1a02000 	mov	r2, r0
   12d5c:	e59f3158 	ldr	r3, [pc, #344]	; 12ebc <GetKeyPressedWithDuration+0x208>
   12d60:	e5933000 	ldr	r3, [r3]
   12d64:	e0423003 	sub	r3, r2, r3
   12d68:	e50b300c 	str	r3, [fp, #-12]
         if (TimeDelta < Time_to_get_entering)
   12d6c:	e51b300c 	ldr	r3, [fp, #-12]
   12d70:	e3530f7d 	cmp	r3, #500	; 0x1f4
   12d74:	2a000002 	bcs	12d84 <GetKeyPressedWithDuration+0xd0>
         {
            sLocalKeyPressed.cLongTimePressing = FALSE;
   12d78:	e3a03000 	mov	r3, #0
   12d7c:	e54b3010 	strb	r3, [fp, #-16]
   12d80:	ea000001 	b	12d8c <GetKeyPressedWithDuration+0xd8>
         }
         else
         {
            sLocalKeyPressed.cLongTimePressing = TRUE;
   12d84:	e3a03001 	mov	r3, #1
   12d88:	e54b3010 	strb	r3, [fp, #-16]
         }

         // Initial values for future
         CurrentKey = 0;
   12d8c:	e59f3124 	ldr	r3, [pc, #292]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12d90:	e3a02000 	mov	r2, #0
   12d94:	e5c32000 	strb	r2, [r3]
         TimePressing = 0;
   12d98:	e59f311c 	ldr	r3, [pc, #284]	; 12ebc <GetKeyPressedWithDuration+0x208>
   12d9c:	e3a02000 	mov	r2, #0
   12da0:	e5832000 	str	r2, [r3]
         sLocalKeyPressed.bCurrentlyPressed = FALSE;
   12da4:	e3a03000 	mov	r3, #0
   12da8:	e14b30be 	strh	r3, [fp, #-14]
   12dac:	ea000038 	b	12e94 <GetKeyPressedWithDuration+0x1e0>
      }
   }
   else
   {  // In Enter mode the reaction on pressed button and the time of pressing calculation
      if ((x)&&(x != keUnknown))
   12db0:	e51b3008 	ldr	r3, [fp, #-8]
   12db4:	e3530000 	cmp	r3, #0
   12db8:	0a000029 	beq	12e64 <GetKeyPressedWithDuration+0x1b0>
   12dbc:	e51b3008 	ldr	r3, [fp, #-8]
   12dc0:	e3530018 	cmp	r3, #24
   12dc4:	0a000026 	beq	12e64 <GetKeyPressedWithDuration+0x1b0>
      {
         if (x == CurrentKey)
   12dc8:	e59f30e8 	ldr	r3, [pc, #232]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12dcc:	e5d33000 	ldrb	r3, [r3]
   12dd0:	e1a02003 	mov	r2, r3
   12dd4:	e51b3008 	ldr	r3, [fp, #-8]
   12dd8:	e1530002 	cmp	r3, r2
   12ddc:	0a000007 	beq	12e00 <GetKeyPressedWithDuration+0x14c>
         {
            // TimePressing still running
         }
         else
         {
            CurrentKey = x;
   12de0:	e51b3008 	ldr	r3, [fp, #-8]
   12de4:	e6ef2073 	uxtb	r2, r3
   12de8:	e59f30c8 	ldr	r3, [pc, #200]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12dec:	e5c32000 	strb	r2, [r3]
            TimePressing = appMillis();
   12df0:	ebfffd8a 	bl	12420 <appMillis>
   12df4:	e1a02000 	mov	r2, r0
   12df8:	e59f30bc 	ldr	r3, [pc, #188]	; 12ebc <GetKeyPressedWithDuration+0x208>
   12dfc:	e5832000 	str	r2, [r3]
         }

         // The key still pressed -> take over the value
         sLocalKeyPressed.eKeyNumber = CurrentKey;
   12e00:	e59f30b0 	ldr	r3, [pc, #176]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12e04:	e5d33000 	ldrb	r3, [r3]
   12e08:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
         TimeDelta = (appMillis() - TimePressing);
   12e0c:	ebfffd83 	bl	12420 <appMillis>
   12e10:	e1a02000 	mov	r2, r0
   12e14:	e59f30a0 	ldr	r3, [pc, #160]	; 12ebc <GetKeyPressedWithDuration+0x208>
   12e18:	e5933000 	ldr	r3, [r3]
   12e1c:	e0423003 	sub	r3, r2, r3
   12e20:	e50b300c 	str	r3, [fp, #-12]
         if (TimeDelta >= MaxTime_to_get_entering)
   12e24:	e51b300c 	ldr	r3, [fp, #-12]
   12e28:	e59f2090 	ldr	r2, [pc, #144]	; 12ec0 <GetKeyPressedWithDuration+0x20c>
   12e2c:	e1530002 	cmp	r3, r2
   12e30:	9a000002 	bls	12e40 <GetKeyPressedWithDuration+0x18c>
         {
            sLocalKeyPressed.cLongTimePressing = (uint8_t)(MaxTime_to_get_entering / Time_to_get_entering);
   12e34:	e3a0300a 	mov	r3, #10
   12e38:	e54b3010 	strb	r3, [fp, #-16]
   12e3c:	ea000005 	b	12e58 <GetKeyPressedWithDuration+0x1a4>
         }
         else
         {
            sLocalKeyPressed.cLongTimePressing = (uint8_t)(TimeDelta / Time_to_get_entering);
   12e40:	e51b300c 	ldr	r3, [fp, #-12]
   12e44:	e59f2078 	ldr	r2, [pc, #120]	; 12ec4 <GetKeyPressedWithDuration+0x210>
   12e48:	e0832392 	umull	r2, r3, r2, r3
   12e4c:	e1a032a3 	lsr	r3, r3, #5
   12e50:	e6ef3073 	uxtb	r3, r3
   12e54:	e54b3010 	strb	r3, [fp, #-16]
         }
         sLocalKeyPressed.bCurrentlyPressed = TRUE;
   12e58:	e3a03001 	mov	r3, #1
   12e5c:	e14b30be 	strh	r3, [fp, #-14]
   12e60:	ea00000b 	b	12e94 <GetKeyPressedWithDuration+0x1e0>
      }
      else
      {
         CurrentKey = 0;
   12e64:	e59f304c 	ldr	r3, [pc, #76]	; 12eb8 <GetKeyPressedWithDuration+0x204>
   12e68:	e3a02000 	mov	r2, #0
   12e6c:	e5c32000 	strb	r2, [r3]
         TimePressing = 0;
   12e70:	e59f3044 	ldr	r3, [pc, #68]	; 12ebc <GetKeyPressedWithDuration+0x208>
   12e74:	e3a02000 	mov	r2, #0
   12e78:	e5832000 	str	r2, [r3]

         sLocalKeyPressed.eKeyNumber = 0;
   12e7c:	e3a03000 	mov	r3, #0
   12e80:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
         sLocalKeyPressed.cLongTimePressing = 0;
   12e84:	e3a03000 	mov	r3, #0
   12e88:	e54b3010 	strb	r3, [fp, #-16]
         sLocalKeyPressed.bCurrentlyPressed = FALSE;
   12e8c:	e3a03000 	mov	r3, #0
   12e90:	e14b30be 	strh	r3, [fp, #-14]
      }

   }

   return(sLocalKeyPressed);
   12e94:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   12e98:	e1a02003 	mov	r2, r3
   12e9c:	e24b3014 	sub	r3, fp, #20
   12ea0:	e8930003 	ldm	r3, {r0, r1}
   12ea4:	e8820003 	stm	r2, {r0, r1}
};
   12ea8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
   12eac:	e24bd004 	sub	sp, fp, #4
   12eb0:	e8bd8800 	pop	{fp, pc}
   12eb4:	0002721c 	.word	0x0002721c
   12eb8:	00027212 	.word	0x00027212
   12ebc:	00027214 	.word	0x00027214
   12ec0:	00001387 	.word	0x00001387
   12ec4:	10624dd3 	.word	0x10624dd3

00012ec8 <GetKeyPressed>:

/* --------------------------------------------------------------------------
 * GetKeyPressed
 * -------------------------------------------------------------------------- */
KeyboardKeys_enum GetKeyPressed(void)
{
   12ec8:	e92d4800 	push	{fp, lr}
   12ecc:	e28db004 	add	fp, sp, #4
   12ed0:	e24dd008 	sub	sp, sp, #8
   KeyboardKeys_enum Result;
   uint8_t KeybChar;

   if (pTM1638board != NULL)
   12ed4:	e59f30b8 	ldr	r3, [pc, #184]	; 12f94 <GetKeyPressed+0xcc>
   12ed8:	e5933000 	ldr	r3, [r3]
   12edc:	e3530000 	cmp	r3, #0
   12ee0:	0a000023 	beq	12f74 <GetKeyPressed+0xac>
   {
      KeybChar = tm1638_read_8buttons(pTM1638board);
   12ee4:	e59f30a8 	ldr	r3, [pc, #168]	; 12f94 <GetKeyPressed+0xcc>
   12ee8:	e5933000 	ldr	r3, [r3]
   12eec:	e1a00003 	mov	r0, r3
   12ef0:	eb000356 	bl	13c50 <tm1638_read_8buttons>
   12ef4:	e1a03000 	mov	r3, r0
   12ef8:	e54b3009 	strb	r3, [fp, #-9]

      // Check whether it is known key
      switch(KeybChar)
   12efc:	e55b3009 	ldrb	r3, [fp, #-9]
   12f00:	e3530008 	cmp	r3, #8
   12f04:	0a000013 	beq	12f58 <GetKeyPressed+0x90>
   12f08:	e3530008 	cmp	r3, #8
   12f0c:	ca000006 	bgt	12f2c <GetKeyPressed+0x64>
   12f10:	e3530000 	cmp	r3, #0
   12f14:	da000012 	ble	12f64 <GetKeyPressed+0x9c>
   12f18:	e3530002 	cmp	r3, #2
   12f1c:	da00000d 	ble	12f58 <GetKeyPressed+0x90>
   12f20:	e3530004 	cmp	r3, #4
   12f24:	0a00000b 	beq	12f58 <GetKeyPressed+0x90>
   12f28:	ea00000d 	b	12f64 <GetKeyPressed+0x9c>
   12f2c:	e3530020 	cmp	r3, #32
   12f30:	0a000008 	beq	12f58 <GetKeyPressed+0x90>
   12f34:	e3530020 	cmp	r3, #32
   12f38:	ca000002 	bgt	12f48 <GetKeyPressed+0x80>
   12f3c:	e3530010 	cmp	r3, #16
   12f40:	0a000004 	beq	12f58 <GetKeyPressed+0x90>
   12f44:	ea000006 	b	12f64 <GetKeyPressed+0x9c>
   12f48:	e3530040 	cmp	r3, #64	; 0x40
   12f4c:	0a000001 	beq	12f58 <GetKeyPressed+0x90>
   12f50:	e3530080 	cmp	r3, #128	; 0x80
   12f54:	1a000002 	bne	12f64 <GetKeyPressed+0x9c>
         case keKey3_Delta_time:
         case keKey4_Shift:
         case keKey5_Enter:
         case keKey6_Down:
         case keKey7_Up:
            Result = KeybChar;
   12f58:	e55b3009 	ldrb	r3, [fp, #-9]
   12f5c:	e50b3008 	str	r3, [fp, #-8]
            break;
   12f60:	ea000007 	b	12f84 <GetKeyPressed+0xbc>

         default:
            Result = keUnknown;
   12f64:	e3a03018 	mov	r3, #24
   12f68:	e50b3008 	str	r3, [fp, #-8]
            break;
   12f6c:	e1a00000 	nop			; (mov r0, r0)
   12f70:	ea000003 	b	12f84 <GetKeyPressed+0xbc>
      }

   }
   else
   {
      KeybChar= 0;
   12f74:	e3a03000 	mov	r3, #0
   12f78:	e54b3009 	strb	r3, [fp, #-9]
      Result = keUnknown;
   12f7c:	e3a03018 	mov	r3, #24
   12f80:	e50b3008 	str	r3, [fp, #-8]
   }


   return(Result);
   12f84:	e51b3008 	ldr	r3, [fp, #-8]
}
   12f88:	e1a00003 	mov	r0, r3
   12f8c:	e24bd004 	sub	sp, fp, #4
   12f90:	e8bd8800 	pop	{fp, pc}
   12f94:	0002728c 	.word	0x0002728c

00012f98 <KeyboardProcess>:

void KeyboardProcess(void)
{
   12f98:	e92d4800 	push	{fp, lr}
   12f9c:	e28db004 	add	fp, sp, #4
   12fa0:	e24dd010 	sub	sp, sp, #16
   uint32_t lLocalWork;
   KeyPressed_struct sLocalKeyPressed;

   sLocalKeyPressed = GetKeyPressedWithDuration();
   12fa4:	e24b3010 	sub	r3, fp, #16
   12fa8:	e1a00003 	mov	r0, r3
   12fac:	ebffff40 	bl	12cb4 <GetKeyPressedWithDuration>

   switch (eKeyboardState)
   12fb0:	e59f33d0 	ldr	r3, [pc, #976]	; 13388 <KeyboardProcess+0x3f0>
   12fb4:	e5933000 	ldr	r3, [r3]
   12fb8:	e3530003 	cmp	r3, #3
   12fbc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   12fc0:	ea0000ec 	b	13378 <KeyboardProcess+0x3e0>
   12fc4:	00012fd4 	.word	0x00012fd4
   12fc8:	000131bc 	.word	0x000131bc
   12fcc:	00013368 	.word	0x00013368
   12fd0:	0001333c 	.word	0x0001333c
   {
      case keWaitForCommand:

         switch (sLocalKeyPressed.eKeyNumber)
   12fd4:	e51b3010 	ldr	r3, [fp, #-16]
   12fd8:	e3530010 	cmp	r3, #16
   12fdc:	0a000060 	beq	13164 <KeyboardProcess+0x1cc>
   12fe0:	e3530010 	cmp	r3, #16
   12fe4:	8a000006 	bhi	13004 <KeyboardProcess+0x6c>
   12fe8:	e3530002 	cmp	r3, #2
   12fec:	0a00004e 	beq	1312c <KeyboardProcess+0x194>
   12ff0:	e3530004 	cmp	r3, #4
   12ff4:	0a000053 	beq	13148 <KeyboardProcess+0x1b0>
   12ff8:	e3530001 	cmp	r3, #1
   12ffc:	0a000043 	beq	13110 <KeyboardProcess+0x178>
            case keKey_Exit:
               exit(0);
               break;

            default:
               break;
   13000:	ea00006c 	b	131b8 <KeyboardProcess+0x220>
   13004:	e3530020 	cmp	r3, #32
   13008:	0a00002b 	beq	130bc <KeyboardProcess+0x124>
   1300c:	e3530020 	cmp	r3, #32
   13010:	8a000002 	bhi	13020 <KeyboardProcess+0x88>
   13014:	e3530017 	cmp	r3, #23
   13018:	0a000063 	beq	131ac <KeyboardProcess+0x214>
   1301c:	ea000065 	b	131b8 <KeyboardProcess+0x220>
   13020:	e3530040 	cmp	r3, #64	; 0x40
   13024:	0a000002 	beq	13034 <KeyboardProcess+0x9c>
   13028:	e3530080 	cmp	r3, #128	; 0x80
   1302c:	0a000011 	beq	13078 <KeyboardProcess+0xe0>
   13030:	ea000060 	b	131b8 <KeyboardProcess+0x220>
               if (eVarNumber > 0)
   13034:	e59f3350 	ldr	r3, [pc, #848]	; 1338c <KeyboardProcess+0x3f4>
   13038:	e5933000 	ldr	r3, [r3]
   1303c:	e3530000 	cmp	r3, #0
   13040:	0a000005 	beq	1305c <KeyboardProcess+0xc4>
                  eVarNumber = eVarNumber - 1;
   13044:	e59f3340 	ldr	r3, [pc, #832]	; 1338c <KeyboardProcess+0x3f4>
   13048:	e5933000 	ldr	r3, [r3]
   1304c:	e2433001 	sub	r3, r3, #1
   13050:	e59f2334 	ldr	r2, [pc, #820]	; 1338c <KeyboardProcess+0x3f4>
   13054:	e5823000 	str	r3, [r2]
   13058:	ea000002 	b	13068 <KeyboardProcess+0xd0>
                  eVarNumber = keMaxVariableNum - 1;
   1305c:	e59f3328 	ldr	r3, [pc, #808]	; 1338c <KeyboardProcess+0x3f4>
   13060:	e3a02008 	mov	r2, #8
   13064:	e5832000 	str	r2, [r3]
               bPointShifted = FALSE;
   13068:	e59f3320 	ldr	r3, [pc, #800]	; 13390 <KeyboardProcess+0x3f8>
   1306c:	e3a02000 	mov	r2, #0
   13070:	e1c320b0 	strh	r2, [r3]
               break;
   13074:	ea00004f 	b	131b8 <KeyboardProcess+0x220>
               if (eVarNumber < (keMaxVariableNum - 1))
   13078:	e59f330c 	ldr	r3, [pc, #780]	; 1338c <KeyboardProcess+0x3f4>
   1307c:	e5933000 	ldr	r3, [r3]
   13080:	e3530007 	cmp	r3, #7
   13084:	8a000005 	bhi	130a0 <KeyboardProcess+0x108>
                  eVarNumber = eVarNumber + 1;
   13088:	e59f32fc 	ldr	r3, [pc, #764]	; 1338c <KeyboardProcess+0x3f4>
   1308c:	e5933000 	ldr	r3, [r3]
   13090:	e2833001 	add	r3, r3, #1
   13094:	e59f22f0 	ldr	r2, [pc, #752]	; 1338c <KeyboardProcess+0x3f4>
   13098:	e5823000 	str	r3, [r2]
   1309c:	ea000002 	b	130ac <KeyboardProcess+0x114>
                  eVarNumber = 0;
   130a0:	e59f32e4 	ldr	r3, [pc, #740]	; 1338c <KeyboardProcess+0x3f4>
   130a4:	e3a02000 	mov	r2, #0
   130a8:	e5832000 	str	r2, [r3]
               bPointShifted = FALSE;
   130ac:	e59f32dc 	ldr	r3, [pc, #732]	; 13390 <KeyboardProcess+0x3f8>
   130b0:	e3a02000 	mov	r2, #0
   130b4:	e1c320b0 	strh	r2, [r3]
               break;
   130b8:	ea00003e 	b	131b8 <KeyboardProcess+0x220>
               if (VarForIndication[eVarNumber].lVarStep)
   130bc:	e59f32c8 	ldr	r3, [pc, #712]	; 1338c <KeyboardProcess+0x3f4>
   130c0:	e5933000 	ldr	r3, [r3]
   130c4:	e59f22c8 	ldr	r2, [pc, #712]	; 13394 <KeyboardProcess+0x3fc>
   130c8:	e1a03203 	lsl	r3, r3, #4
   130cc:	e0823003 	add	r3, r2, r3
   130d0:	e5933004 	ldr	r3, [r3, #4]
   130d4:	e3530000 	cmp	r3, #0
   130d8:	0a000008 	beq	13100 <KeyboardProcess+0x168>
                  eKeyboardState = keEnterMode;
   130dc:	e59f32a4 	ldr	r3, [pc, #676]	; 13388 <KeyboardProcess+0x3f0>
   130e0:	e3a02001 	mov	r2, #1
   130e4:	e5832000 	str	r2, [r3]
                  sLocalKeyPressed.eKeyNumber = 0;
   130e8:	e3a03000 	mov	r3, #0
   130ec:	e50b3010 	str	r3, [fp, #-16]
                  sLocalKeyPressed.bCurrentlyPressed = FALSE;
   130f0:	e3a03000 	mov	r3, #0
   130f4:	e14b30ba 	strh	r3, [fp, #-10]
                  sLocalKeyPressed.cLongTimePressing = 0;
   130f8:	e3a03000 	mov	r3, #0
   130fc:	e54b300c 	strb	r3, [fp, #-12]
               bPointShifted = FALSE;
   13100:	e59f3288 	ldr	r3, [pc, #648]	; 13390 <KeyboardProcess+0x3f8>
   13104:	e3a02000 	mov	r2, #0
   13108:	e1c320b0 	strh	r2, [r3]
               break;
   1310c:	ea000029 	b	131b8 <KeyboardProcess+0x220>
               eVarNumber = keTreal;
   13110:	e59f3274 	ldr	r3, [pc, #628]	; 1338c <KeyboardProcess+0x3f4>
   13114:	e3a02000 	mov	r2, #0
   13118:	e5832000 	str	r2, [r3]
               bPointShifted = FALSE;
   1311c:	e59f326c 	ldr	r3, [pc, #620]	; 13390 <KeyboardProcess+0x3f8>
   13120:	e3a02000 	mov	r2, #0
   13124:	e1c320b0 	strh	r2, [r3]
               break;
   13128:	ea000022 	b	131b8 <KeyboardProcess+0x220>
               eVarNumber = keTset;
   1312c:	e59f3258 	ldr	r3, [pc, #600]	; 1338c <KeyboardProcess+0x3f4>
   13130:	e3a02001 	mov	r2, #1
   13134:	e5832000 	str	r2, [r3]
               bPointShifted = FALSE;
   13138:	e59f3250 	ldr	r3, [pc, #592]	; 13390 <KeyboardProcess+0x3f8>
   1313c:	e3a02000 	mov	r2, #0
   13140:	e1c320b0 	strh	r2, [r3]
               break;
   13144:	ea00001b 	b	131b8 <KeyboardProcess+0x220>
               eVarNumber = keDeltaT;
   13148:	e59f323c 	ldr	r3, [pc, #572]	; 1338c <KeyboardProcess+0x3f4>
   1314c:	e3a02003 	mov	r2, #3
   13150:	e5832000 	str	r2, [r3]
               bPointShifted = FALSE;
   13154:	e59f3234 	ldr	r3, [pc, #564]	; 13390 <KeyboardProcess+0x3f8>
   13158:	e3a02000 	mov	r2, #0
   1315c:	e1c320b0 	strh	r2, [r3]
               break;
   13160:	ea000014 	b	131b8 <KeyboardProcess+0x220>
               if ((eVarNumber == keTreal) || (eVarNumber == keUreal))
   13164:	e59f3220 	ldr	r3, [pc, #544]	; 1338c <KeyboardProcess+0x3f4>
   13168:	e5933000 	ldr	r3, [r3]
   1316c:	e3530000 	cmp	r3, #0
   13170:	0a000003 	beq	13184 <KeyboardProcess+0x1ec>
   13174:	e59f3210 	ldr	r3, [pc, #528]	; 1338c <KeyboardProcess+0x3f4>
   13178:	e5933000 	ldr	r3, [r3]
   1317c:	e3530008 	cmp	r3, #8
   13180:	1a00000b 	bne	131b4 <KeyboardProcess+0x21c>
                  bPointShifted = !bPointShifted;
   13184:	e59f3204 	ldr	r3, [pc, #516]	; 13390 <KeyboardProcess+0x3f8>
   13188:	e1d330b0 	ldrh	r3, [r3]
   1318c:	e3530000 	cmp	r3, #0
   13190:	03a03001 	moveq	r3, #1
   13194:	13a03000 	movne	r3, #0
   13198:	e6ef3073 	uxtb	r3, r3
   1319c:	e6ff3073 	uxth	r3, r3
   131a0:	e59f21e8 	ldr	r2, [pc, #488]	; 13390 <KeyboardProcess+0x3f8>
   131a4:	e1c230b0 	strh	r3, [r2]
               break;
   131a8:	ea000001 	b	131b4 <KeyboardProcess+0x21c>
               exit(0);
   131ac:	e3a00000 	mov	r0, #0
   131b0:	ebfff5db 	bl	10924 <exit@plt>
               break;
   131b4:	e1a00000 	nop			; (mov r0, r0)
         }

         break;
   131b8:	ea00006f 	b	1337c <KeyboardProcess+0x3e4>

      case keEnterMode:

         switch (sLocalKeyPressed.eKeyNumber)
   131bc:	e51b3010 	ldr	r3, [fp, #-16]
   131c0:	e3530040 	cmp	r3, #64	; 0x40
   131c4:	0a000004 	beq	131dc <KeyboardProcess+0x244>
   131c8:	e3530080 	cmp	r3, #128	; 0x80
   131cc:	0a000028 	beq	13274 <KeyboardProcess+0x2dc>
   131d0:	e3530020 	cmp	r3, #32
   131d4:	0a00004c 	beq	1330c <KeyboardProcess+0x374>
               eKeyboardState = keEnterInterlock;
               saveSettings();
               break;

            default:
               break;
   131d8:	ea000053 	b	1332c <KeyboardProcess+0x394>
               lLocalWork = VarForIndication[eVarNumber].lVarStep * (sLocalKeyPressed.cLongTimePressing + 1);
   131dc:	e59f31a8 	ldr	r3, [pc, #424]	; 1338c <KeyboardProcess+0x3f4>
   131e0:	e5933000 	ldr	r3, [r3]
   131e4:	e59f21a8 	ldr	r2, [pc, #424]	; 13394 <KeyboardProcess+0x3fc>
   131e8:	e1a03203 	lsl	r3, r3, #4
   131ec:	e0823003 	add	r3, r2, r3
   131f0:	e5933004 	ldr	r3, [r3, #4]
   131f4:	e55b200c 	ldrb	r2, [fp, #-12]
   131f8:	e2822001 	add	r2, r2, #1
   131fc:	e0030392 	mul	r3, r2, r3
   13200:	e50b3008 	str	r3, [fp, #-8]
               if ((*VarForIndication[eVarNumber].plVarValue) >= (VarForIndication[eVarNumber].lVarMin + lLocalWork))
   13204:	e59f3180 	ldr	r3, [pc, #384]	; 1338c <KeyboardProcess+0x3f4>
   13208:	e5933000 	ldr	r3, [r3]
   1320c:	e59f2180 	ldr	r2, [pc, #384]	; 13394 <KeyboardProcess+0x3fc>
   13210:	e7923203 	ldr	r3, [r2, r3, lsl #4]
   13214:	e5932000 	ldr	r2, [r3]
   13218:	e59f316c 	ldr	r3, [pc, #364]	; 1338c <KeyboardProcess+0x3f4>
   1321c:	e5933000 	ldr	r3, [r3]
   13220:	e59f116c 	ldr	r1, [pc, #364]	; 13394 <KeyboardProcess+0x3fc>
   13224:	e1a03203 	lsl	r3, r3, #4
   13228:	e0813003 	add	r3, r1, r3
   1322c:	e5931008 	ldr	r1, [r3, #8]
   13230:	e51b3008 	ldr	r3, [fp, #-8]
   13234:	e0813003 	add	r3, r1, r3
   13238:	e1520003 	cmp	r2, r3
   1323c:	3a000037 	bcc	13320 <KeyboardProcess+0x388>
                  *VarForIndication[eVarNumber].plVarValue -= lLocalWork;
   13240:	e59f3144 	ldr	r3, [pc, #324]	; 1338c <KeyboardProcess+0x3f4>
   13244:	e5933000 	ldr	r3, [r3]
   13248:	e59f2144 	ldr	r2, [pc, #324]	; 13394 <KeyboardProcess+0x3fc>
   1324c:	e7923203 	ldr	r3, [r2, r3, lsl #4]
   13250:	e5931000 	ldr	r1, [r3]
   13254:	e59f3130 	ldr	r3, [pc, #304]	; 1338c <KeyboardProcess+0x3f4>
   13258:	e5933000 	ldr	r3, [r3]
   1325c:	e59f2130 	ldr	r2, [pc, #304]	; 13394 <KeyboardProcess+0x3fc>
   13260:	e7923203 	ldr	r3, [r2, r3, lsl #4]
   13264:	e51b2008 	ldr	r2, [fp, #-8]
   13268:	e0412002 	sub	r2, r1, r2
   1326c:	e5832000 	str	r2, [r3]
               break;
   13270:	ea00002a 	b	13320 <KeyboardProcess+0x388>
               lLocalWork = VarForIndication[eVarNumber].lVarStep * (sLocalKeyPressed.cLongTimePressing + 1);
   13274:	e59f3110 	ldr	r3, [pc, #272]	; 1338c <KeyboardProcess+0x3f4>
   13278:	e5933000 	ldr	r3, [r3]
   1327c:	e59f2110 	ldr	r2, [pc, #272]	; 13394 <KeyboardProcess+0x3fc>
   13280:	e1a03203 	lsl	r3, r3, #4
   13284:	e0823003 	add	r3, r2, r3
   13288:	e5933004 	ldr	r3, [r3, #4]
   1328c:	e55b200c 	ldrb	r2, [fp, #-12]
   13290:	e2822001 	add	r2, r2, #1
   13294:	e0030392 	mul	r3, r2, r3
   13298:	e50b3008 	str	r3, [fp, #-8]
               if ((*VarForIndication[eVarNumber].plVarValue + lLocalWork) <= VarForIndication[eVarNumber].lVarMax)
   1329c:	e59f30e8 	ldr	r3, [pc, #232]	; 1338c <KeyboardProcess+0x3f4>
   132a0:	e5933000 	ldr	r3, [r3]
   132a4:	e59f20e8 	ldr	r2, [pc, #232]	; 13394 <KeyboardProcess+0x3fc>
   132a8:	e7923203 	ldr	r3, [r2, r3, lsl #4]
   132ac:	e5932000 	ldr	r2, [r3]
   132b0:	e51b3008 	ldr	r3, [fp, #-8]
   132b4:	e0822003 	add	r2, r2, r3
   132b8:	e59f30cc 	ldr	r3, [pc, #204]	; 1338c <KeyboardProcess+0x3f4>
   132bc:	e5933000 	ldr	r3, [r3]
   132c0:	e59f10cc 	ldr	r1, [pc, #204]	; 13394 <KeyboardProcess+0x3fc>
   132c4:	e1a03203 	lsl	r3, r3, #4
   132c8:	e0813003 	add	r3, r1, r3
   132cc:	e593300c 	ldr	r3, [r3, #12]
   132d0:	e1520003 	cmp	r2, r3
   132d4:	8a000013 	bhi	13328 <KeyboardProcess+0x390>
                  *VarForIndication[eVarNumber].plVarValue += lLocalWork;
   132d8:	e59f30ac 	ldr	r3, [pc, #172]	; 1338c <KeyboardProcess+0x3f4>
   132dc:	e5933000 	ldr	r3, [r3]
   132e0:	e59f20ac 	ldr	r2, [pc, #172]	; 13394 <KeyboardProcess+0x3fc>
   132e4:	e7923203 	ldr	r3, [r2, r3, lsl #4]
   132e8:	e5931000 	ldr	r1, [r3]
   132ec:	e59f3098 	ldr	r3, [pc, #152]	; 1338c <KeyboardProcess+0x3f4>
   132f0:	e5933000 	ldr	r3, [r3]
   132f4:	e59f2098 	ldr	r2, [pc, #152]	; 13394 <KeyboardProcess+0x3fc>
   132f8:	e7923203 	ldr	r3, [r2, r3, lsl #4]
   132fc:	e51b2008 	ldr	r2, [fp, #-8]
   13300:	e0812002 	add	r2, r1, r2
   13304:	e5832000 	str	r2, [r3]
               break;
   13308:	ea000006 	b	13328 <KeyboardProcess+0x390>
               eKeyboardState = keEnterInterlock;
   1330c:	e59f3074 	ldr	r3, [pc, #116]	; 13388 <KeyboardProcess+0x3f0>
   13310:	e3a02003 	mov	r2, #3
   13314:	e5832000 	str	r2, [r3]
               saveSettings();
   13318:	eb00099a 	bl	15988 <saveSettings>
               break;
   1331c:	ea000002 	b	1332c <KeyboardProcess+0x394>
               break;
   13320:	e1a00000 	nop			; (mov r0, r0)
   13324:	ea000000 	b	1332c <KeyboardProcess+0x394>
               break;
   13328:	e1a00000 	nop			; (mov r0, r0)
         }
         bPointShifted = FALSE;
   1332c:	e59f305c 	ldr	r3, [pc, #92]	; 13390 <KeyboardProcess+0x3f8>
   13330:	e3a02000 	mov	r2, #0
   13334:	e1c320b0 	strh	r2, [r3]

         break;
   13338:	ea00000f 	b	1337c <KeyboardProcess+0x3e4>

      case keEnterInterlock:
         if (!sLocalKeyPressed.bCurrentlyPressed)
   1333c:	e15b30ba 	ldrh	r3, [fp, #-10]
   13340:	e3530000 	cmp	r3, #0
   13344:	1a000003 	bne	13358 <KeyboardProcess+0x3c0>
         {
            eKeyboardState = keWaitForCommand;
   13348:	e59f3038 	ldr	r3, [pc, #56]	; 13388 <KeyboardProcess+0x3f0>
   1334c:	e3a02000 	mov	r2, #0
   13350:	e5832000 	str	r2, [r3]
            saveSettings();
   13354:	eb00098b 	bl	15988 <saveSettings>
         }

         bPointShifted = FALSE;
   13358:	e59f3030 	ldr	r3, [pc, #48]	; 13390 <KeyboardProcess+0x3f8>
   1335c:	e3a02000 	mov	r2, #0
   13360:	e1c320b0 	strh	r2, [r3]
         break;
   13364:	ea000004 	b	1337c <KeyboardProcess+0x3e4>

      case keSensorShow:
         bPointShifted = FALSE;
   13368:	e59f3020 	ldr	r3, [pc, #32]	; 13390 <KeyboardProcess+0x3f8>
   1336c:	e3a02000 	mov	r2, #0
   13370:	e1c320b0 	strh	r2, [r3]
         break;
   13374:	ea000000 	b	1337c <KeyboardProcess+0x3e4>

      default:
         break;
   13378:	e1a00000 	nop			; (mov r0, r0)

   }

}
   1337c:	e1a00000 	nop			; (mov r0, r0)
   13380:	e24bd004 	sub	sp, fp, #4
   13384:	e8bd8800 	pop	{fp, pc}
   13388:	0002721c 	.word	0x0002721c
   1338c:	00027218 	.word	0x00027218
   13390:	00027220 	.word	0x00027220
   13394:	00016218 	.word	0x00016218

00013398 <tm1638_alloc>:
static void tm1638_send_config(const tm1638_p t);
static uint8_t tm1638_calc_config(const tm1638_p t);

/* See tm1638.h */
tm1638_p tm1638_alloc(uint8_t data, uint8_t clock, uint8_t strobe)
{
   13398:	e92d4800 	push	{fp, lr}
   1339c:	e28db004 	add	fp, sp, #4
   133a0:	e24dd010 	sub	sp, sp, #16
   133a4:	e1a03000 	mov	r3, r0
   133a8:	e54b300d 	strb	r3, [fp, #-13]
   133ac:	e1a03001 	mov	r3, r1
   133b0:	e54b300e 	strb	r3, [fp, #-14]
   133b4:	e1a03002 	mov	r3, r2
   133b8:	e54b300f 	strb	r3, [fp, #-15]
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */

  tm1638_p t = malloc(sizeof(tm1638));
   133bc:	e3a00005 	mov	r0, #5
   133c0:	ebfff593 	bl	10a14 <malloc@plt>
   133c4:	e1a03000 	mov	r3, r0
   133c8:	e50b3008 	str	r3, [fp, #-8]
  if (!t)
   133cc:	e51b3008 	ldr	r3, [fp, #-8]
   133d0:	e3530000 	cmp	r3, #0
   133d4:	1a000001 	bne	133e0 <tm1638_alloc+0x48>
    return NULL;
   133d8:	e3a03000 	mov	r3, #0
   133dc:	ea00002f 	b	134a0 <tm1638_alloc+0x108>

  t->data   = data;
   133e0:	e51b3008 	ldr	r3, [fp, #-8]
   133e4:	e55b200d 	ldrb	r2, [fp, #-13]
   133e8:	e5c32000 	strb	r2, [r3]
  t->clock  = clock;
   133ec:	e51b3008 	ldr	r3, [fp, #-8]
   133f0:	e55b200e 	ldrb	r2, [fp, #-14]
   133f4:	e5c32001 	strb	r2, [r3, #1]
  t->strobe = strobe;
   133f8:	e51b3008 	ldr	r3, [fp, #-8]
   133fc:	e55b200f 	ldrb	r2, [fp, #-15]
   13400:	e5c32002 	strb	r2, [r3, #2]
  
  t->intensity = 7;
   13404:	e51b3008 	ldr	r3, [fp, #-8]
   13408:	e3a02007 	mov	r2, #7
   1340c:	e5c32003 	strb	r2, [r3, #3]
  t->enable    = true;
   13410:	e51b3008 	ldr	r3, [fp, #-8]
   13414:	e3a02001 	mov	r2, #1
   13418:	e5c32004 	strb	r2, [r3, #4]

  bcm2835_gpio_fsel(t->data, BCM2835_GPIO_FSEL_OUTP);
   1341c:	e51b3008 	ldr	r3, [fp, #-8]
   13420:	e5d33000 	ldrb	r3, [r3]
   13424:	e3a01001 	mov	r1, #1
   13428:	e1a00003 	mov	r0, r3
   1342c:	ebfff71f 	bl	110b0 <bcm2835_gpio_fsel>
  bcm2835_gpio_fsel(t->clock,    BCM2835_GPIO_FSEL_OUTP);
   13430:	e51b3008 	ldr	r3, [fp, #-8]
   13434:	e5d33001 	ldrb	r3, [r3, #1]
   13438:	e3a01001 	mov	r1, #1
   1343c:	e1a00003 	mov	r0, r3
   13440:	ebfff71a 	bl	110b0 <bcm2835_gpio_fsel>
  bcm2835_gpio_fsel(t->strobe,   BCM2835_GPIO_FSEL_OUTP);
   13444:	e51b3008 	ldr	r3, [fp, #-8]
   13448:	e5d33002 	ldrb	r3, [r3, #2]
   1344c:	e3a01001 	mov	r1, #1
   13450:	e1a00003 	mov	r0, r3
   13454:	ebfff715 	bl	110b0 <bcm2835_gpio_fsel>

  bcm2835_gpio_write(t->strobe, HIGH);
   13458:	e51b3008 	ldr	r3, [fp, #-8]
   1345c:	e5d33002 	ldrb	r3, [r3, #2]
   13460:	e3a01001 	mov	r1, #1
   13464:	e1a00003 	mov	r0, r3
   13468:	ebfff7fd 	bl	11464 <bcm2835_gpio_write>
  bcm2835_gpio_write(t->clock,  HIGH);
   1346c:	e51b3008 	ldr	r3, [fp, #-8]
   13470:	e5d33001 	ldrb	r3, [r3, #1]
   13474:	e3a01001 	mov	r1, #1
   13478:	e1a00003 	mov	r0, r3
   1347c:	ebfff7f8 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   13480:	e3a00001 	mov	r0, #1
   13484:	e3a01000 	mov	r1, #0
   13488:	ebfff7b7 	bl	1136c <bcm2835_delayMicroseconds>
  
  tm1638_send_config(t);
   1348c:	e51b0008 	ldr	r0, [fp, #-8]
   13490:	eb000018 	bl	134f8 <tm1638_send_config>

  tm1638_send_cls(t);
   13494:	e51b0008 	ldr	r0, [fp, #-8]
   13498:	eb00017b 	bl	13a8c <tm1638_send_cls>

  return t;
   1349c:	e51b3008 	ldr	r3, [fp, #-8]
}
   134a0:	e1a00003 	mov	r0, r3
   134a4:	e24bd004 	sub	sp, fp, #4
   134a8:	e8bd8800 	pop	{fp, pc}

000134ac <tm1638_set_intensity>:
  tm1638_send_config(t);
}

/* See tm1638.h */
void tm1638_set_intensity(tm1638_p t, uint8_t intensity)
{
   134ac:	e92d4800 	push	{fp, lr}
   134b0:	e28db004 	add	fp, sp, #4
   134b4:	e24dd008 	sub	sp, sp, #8
   134b8:	e50b0008 	str	r0, [fp, #-8]
   134bc:	e1a03001 	mov	r3, r1
   134c0:	e54b3009 	strb	r3, [fp, #-9]
  /* maximum intensity is 7 */
  if (intensity > 7)
   134c4:	e55b3009 	ldrb	r3, [fp, #-9]
   134c8:	e3530007 	cmp	r3, #7
   134cc:	9a000001 	bls	134d8 <tm1638_set_intensity+0x2c>
    intensity = 7;
   134d0:	e3a03007 	mov	r3, #7
   134d4:	e54b3009 	strb	r3, [fp, #-9]

  t->intensity = intensity;
   134d8:	e51b3008 	ldr	r3, [fp, #-8]
   134dc:	e55b2009 	ldrb	r2, [fp, #-9]
   134e0:	e5c32003 	strb	r2, [r3, #3]

  tm1638_send_config(t);
   134e4:	e51b0008 	ldr	r0, [fp, #-8]
   134e8:	eb000002 	bl	134f8 <tm1638_send_config>
}
   134ec:	e1a00000 	nop			; (mov r0, r0)
   134f0:	e24bd004 	sub	sp, fp, #4
   134f4:	e8bd8800 	pop	{fp, pc}

000134f8 <tm1638_send_config>:
 * Send the settings in t to the actual hardware.
 *
 * @param t  Pointer to the tm1638 of interest.
 */
static void tm1638_send_config(const tm1638_p t)
{
   134f8:	e92d4800 	push	{fp, lr}
   134fc:	e28db004 	add	fp, sp, #4
   13500:	e24dd008 	sub	sp, sp, #8
   13504:	e50b0008 	str	r0, [fp, #-8]
  tm1638_send_command(t, tm1638_calc_config(t));
   13508:	e51b0008 	ldr	r0, [fp, #-8]
   1350c:	eb000006 	bl	1352c <tm1638_calc_config>
   13510:	e1a03000 	mov	r3, r0
   13514:	e1a01003 	mov	r1, r3
   13518:	e51b0008 	ldr	r0, [fp, #-8]
   1351c:	eb000087 	bl	13740 <tm1638_send_command>
}
   13520:	e1a00000 	nop			; (mov r0, r0)
   13524:	e24bd004 	sub	sp, fp, #4
   13528:	e8bd8800 	pop	{fp, pc}

0001352c <tm1638_calc_config>:
 * @param t  Pointer to the tm1638 of interest.
 *
 * @return   The byte of config data we need to send.
 */
static uint8_t tm1638_calc_config(const tm1638_p t)
{
   1352c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   13530:	e28db000 	add	fp, sp, #0
   13534:	e24dd00c 	sub	sp, sp, #12
   13538:	e50b0008 	str	r0, [fp, #-8]
  return 0x80 | (t->enable ? 8 : 0) | t->intensity;
   1353c:	e51b3008 	ldr	r3, [fp, #-8]
   13540:	e5d33004 	ldrb	r3, [r3, #4]
   13544:	e3530000 	cmp	r3, #0
   13548:	0a000001 	beq	13554 <tm1638_calc_config+0x28>
   1354c:	e3e02077 	mvn	r2, #119	; 0x77
   13550:	ea000000 	b	13558 <tm1638_calc_config+0x2c>
   13554:	e3e0207f 	mvn	r2, #127	; 0x7f
   13558:	e51b3008 	ldr	r3, [fp, #-8]
   1355c:	e5d33003 	ldrb	r3, [r3, #3]
   13560:	e6af3073 	sxtb	r3, r3
   13564:	e1823003 	orr	r3, r2, r3
   13568:	e6af3073 	sxtb	r3, r3
   1356c:	e6ef3073 	uxtb	r3, r3
}
   13570:	e1a00003 	mov	r0, r3
   13574:	e28bd000 	add	sp, fp, #0
   13578:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1357c:	e12fff1e 	bx	lr

00013580 <tm1638_send_raw>:
 *
 * @param t  Pointer to the tm1638 of interest.
 * @param x  The byte to send.
 */
static void tm1638_send_raw(const tm1638_p t, uint8_t x)
{
   13580:	e92d4800 	push	{fp, lr}
   13584:	e28db004 	add	fp, sp, #4
   13588:	e24dd010 	sub	sp, sp, #16
   1358c:	e50b0010 	str	r0, [fp, #-16]
   13590:	e1a03001 	mov	r3, r1
   13594:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */
  for(int i = 0; i < 8; i++)
   13598:	e3a03000 	mov	r3, #0
   1359c:	e50b3008 	str	r3, [fp, #-8]
   135a0:	ea000020 	b	13628 <tm1638_send_raw+0xa8>
    {
      bcm2835_gpio_write(t->clock, LOW);
   135a4:	e51b3010 	ldr	r3, [fp, #-16]
   135a8:	e5d33001 	ldrb	r3, [r3, #1]
   135ac:	e3a01000 	mov	r1, #0
   135b0:	e1a00003 	mov	r0, r3
   135b4:	ebfff7aa 	bl	11464 <bcm2835_gpio_write>
      delayMicroseconds(1);
   135b8:	e3a00001 	mov	r0, #1
   135bc:	e3a01000 	mov	r1, #0
   135c0:	ebfff769 	bl	1136c <bcm2835_delayMicroseconds>

      bcm2835_gpio_write(t->data, x & 1 ? HIGH : LOW);
   135c4:	e51b3010 	ldr	r3, [fp, #-16]
   135c8:	e5d32000 	ldrb	r2, [r3]
   135cc:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
   135d0:	e2033001 	and	r3, r3, #1
   135d4:	e6ef3073 	uxtb	r3, r3
   135d8:	e1a01003 	mov	r1, r3
   135dc:	e1a00002 	mov	r0, r2
   135e0:	ebfff79f 	bl	11464 <bcm2835_gpio_write>
      delayMicroseconds(1);
   135e4:	e3a00001 	mov	r0, #1
   135e8:	e3a01000 	mov	r1, #0
   135ec:	ebfff75e 	bl	1136c <bcm2835_delayMicroseconds>

      x  >>= 1;
   135f0:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
   135f4:	e1a030a3 	lsr	r3, r3, #1
   135f8:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
      bcm2835_gpio_write(t->clock, HIGH);
   135fc:	e51b3010 	ldr	r3, [fp, #-16]
   13600:	e5d33001 	ldrb	r3, [r3, #1]
   13604:	e3a01001 	mov	r1, #1
   13608:	e1a00003 	mov	r0, r3
   1360c:	ebfff794 	bl	11464 <bcm2835_gpio_write>
      delayMicroseconds(1);
   13610:	e3a00001 	mov	r0, #1
   13614:	e3a01000 	mov	r1, #0
   13618:	ebfff753 	bl	1136c <bcm2835_delayMicroseconds>
  for(int i = 0; i < 8; i++)
   1361c:	e51b3008 	ldr	r3, [fp, #-8]
   13620:	e2833001 	add	r3, r3, #1
   13624:	e50b3008 	str	r3, [fp, #-8]
   13628:	e51b3008 	ldr	r3, [fp, #-8]
   1362c:	e3530007 	cmp	r3, #7
   13630:	daffffdb 	ble	135a4 <tm1638_send_raw+0x24>
    }
}
   13634:	e1a00000 	nop			; (mov r0, r0)
   13638:	e24bd004 	sub	sp, fp, #4
   1363c:	e8bd8800 	pop	{fp, pc}

00013640 <tm1638_receive_raw>:
 * @param t  Pointer to the tm1638 of interest.
 *
 * @return   The byte we read.
 */
static uint8_t tm1638_receive_raw(const tm1638_p t)
{
   13640:	e92d4800 	push	{fp, lr}
   13644:	e28db004 	add	fp, sp, #4
   13648:	e24dd018 	sub	sp, sp, #24
   1364c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */

  uint8_t x = 0;
   13650:	e3a03000 	mov	r3, #0
   13654:	e54b3005 	strb	r3, [fp, #-5]

  /* Turn GPIO pin into an input */
  bcm2835_gpio_fsel(t->data, BCM2835_GPIO_FSEL_INPT);
   13658:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   1365c:	e5d33000 	ldrb	r3, [r3]
   13660:	e3a01000 	mov	r1, #0
   13664:	e1a00003 	mov	r0, r3
   13668:	ebfff690 	bl	110b0 <bcm2835_gpio_fsel>
    
  for(int i = 0; i < 8; i++)
   1366c:	e3a03000 	mov	r3, #0
   13670:	e50b300c 	str	r3, [fp, #-12]
   13674:	ea000025 	b	13710 <tm1638_receive_raw+0xd0>
    {
      x <<= 1;
   13678:	e55b3005 	ldrb	r3, [fp, #-5]
   1367c:	e1a03083 	lsl	r3, r3, #1
   13680:	e54b3005 	strb	r3, [fp, #-5]

      bcm2835_gpio_write(t->clock, LOW);
   13684:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   13688:	e5d33001 	ldrb	r3, [r3, #1]
   1368c:	e3a01000 	mov	r1, #0
   13690:	e1a00003 	mov	r0, r3
   13694:	ebfff772 	bl	11464 <bcm2835_gpio_write>
      delayMicroseconds(1);
   13698:	e3a00001 	mov	r0, #1
   1369c:	e3a01000 	mov	r1, #0
   136a0:	ebfff731 	bl	1136c <bcm2835_delayMicroseconds>

      uint8_t y = bcm2835_gpio_lev(t->data);
   136a4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   136a8:	e5d33000 	ldrb	r3, [r3]
   136ac:	e1a00003 	mov	r0, r3
   136b0:	ebfff6e5 	bl	1124c <bcm2835_gpio_lev>
   136b4:	e1a03000 	mov	r3, r0
   136b8:	e54b300d 	strb	r3, [fp, #-13]

      if (y & 1)
   136bc:	e55b300d 	ldrb	r3, [fp, #-13]
   136c0:	e2033001 	and	r3, r3, #1
   136c4:	e3530000 	cmp	r3, #0
   136c8:	0a000002 	beq	136d8 <tm1638_receive_raw+0x98>
	x |= 1;
   136cc:	e55b3005 	ldrb	r3, [fp, #-5]
   136d0:	e3833001 	orr	r3, r3, #1
   136d4:	e54b3005 	strb	r3, [fp, #-5]
      delayMicroseconds(1);
   136d8:	e3a00001 	mov	r0, #1
   136dc:	e3a01000 	mov	r1, #0
   136e0:	ebfff721 	bl	1136c <bcm2835_delayMicroseconds>

      bcm2835_gpio_write(t->clock, HIGH);
   136e4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   136e8:	e5d33001 	ldrb	r3, [r3, #1]
   136ec:	e3a01001 	mov	r1, #1
   136f0:	e1a00003 	mov	r0, r3
   136f4:	ebfff75a 	bl	11464 <bcm2835_gpio_write>
      delayMicroseconds(1);
   136f8:	e3a00001 	mov	r0, #1
   136fc:	e3a01000 	mov	r1, #0
   13700:	ebfff719 	bl	1136c <bcm2835_delayMicroseconds>
  for(int i = 0; i < 8; i++)
   13704:	e51b300c 	ldr	r3, [fp, #-12]
   13708:	e2833001 	add	r3, r3, #1
   1370c:	e50b300c 	str	r3, [fp, #-12]
   13710:	e51b300c 	ldr	r3, [fp, #-12]
   13714:	e3530007 	cmp	r3, #7
   13718:	daffffd6 	ble	13678 <tm1638_receive_raw+0x38>
    }

  /* Turn GPIO pin back into an output */
  bcm2835_gpio_fsel(t->data, BCM2835_GPIO_FSEL_OUTP);
   1371c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   13720:	e5d33000 	ldrb	r3, [r3]
   13724:	e3a01001 	mov	r1, #1
   13728:	e1a00003 	mov	r0, r3
   1372c:	ebfff65f 	bl	110b0 <bcm2835_gpio_fsel>

  return x;
   13730:	e55b3005 	ldrb	r3, [fp, #-5]
}
   13734:	e1a00003 	mov	r0, r3
   13738:	e24bd004 	sub	sp, fp, #4
   1373c:	e8bd8800 	pop	{fp, pc}

00013740 <tm1638_send_command>:
 *
 * @param t  Pointer to the tm1638 of interest.
 * @param x  The command to send.
 */
static void tm1638_send_command(const tm1638_p t, uint8_t x)
{
   13740:	e92d4800 	push	{fp, lr}
   13744:	e28db004 	add	fp, sp, #4
   13748:	e24dd008 	sub	sp, sp, #8
   1374c:	e50b0008 	str	r0, [fp, #-8]
   13750:	e1a03001 	mov	r3, r1
   13754:	e54b3009 	strb	r3, [fp, #-9]
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */
  bcm2835_gpio_write(t->strobe, LOW);
   13758:	e51b3008 	ldr	r3, [fp, #-8]
   1375c:	e5d33002 	ldrb	r3, [r3, #2]
   13760:	e3a01000 	mov	r1, #0
   13764:	e1a00003 	mov	r0, r3
   13768:	ebfff73d 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   1376c:	e3a00001 	mov	r0, #1
   13770:	e3a01000 	mov	r1, #0
   13774:	ebfff6fc 	bl	1136c <bcm2835_delayMicroseconds>

  tm1638_send_raw(t, x);
   13778:	e55b3009 	ldrb	r3, [fp, #-9]
   1377c:	e1a01003 	mov	r1, r3
   13780:	e51b0008 	ldr	r0, [fp, #-8]
   13784:	ebffff7d 	bl	13580 <tm1638_send_raw>

  bcm2835_gpio_write(t->strobe, HIGH);
   13788:	e51b3008 	ldr	r3, [fp, #-8]
   1378c:	e5d33002 	ldrb	r3, [r3, #2]
   13790:	e3a01001 	mov	r1, #1
   13794:	e1a00003 	mov	r0, r3
   13798:	ebfff731 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   1379c:	e3a00001 	mov	r0, #1
   137a0:	e3a01000 	mov	r1, #0
   137a4:	ebfff6f0 	bl	1136c <bcm2835_delayMicroseconds>
}
   137a8:	e1a00000 	nop			; (mov r0, r0)
   137ac:	e24bd004 	sub	sp, fp, #4
   137b0:	e8bd8800 	pop	{fp, pc}

000137b4 <tm1638_send_data>:
 * @param t    Pointer to the tm1638 of interest.
 * @param addr The address to write.
 * @param data The data to write.
 */
static void tm1638_send_data(const tm1638_p t, uint8_t addr, uint8_t data)
{
   137b4:	e92d4800 	push	{fp, lr}
   137b8:	e28db004 	add	fp, sp, #4
   137bc:	e24dd008 	sub	sp, sp, #8
   137c0:	e50b0008 	str	r0, [fp, #-8]
   137c4:	e1a03001 	mov	r3, r1
   137c8:	e54b3009 	strb	r3, [fp, #-9]
   137cc:	e1a03002 	mov	r3, r2
   137d0:	e54b300a 	strb	r3, [fp, #-10]
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */
  tm1638_send_command(t, 0x44);
   137d4:	e3a01044 	mov	r1, #68	; 0x44
   137d8:	e51b0008 	ldr	r0, [fp, #-8]
   137dc:	ebffffd7 	bl	13740 <tm1638_send_command>
  
  bcm2835_gpio_write(t->strobe, LOW);
   137e0:	e51b3008 	ldr	r3, [fp, #-8]
   137e4:	e5d33002 	ldrb	r3, [r3, #2]
   137e8:	e3a01000 	mov	r1, #0
   137ec:	e1a00003 	mov	r0, r3
   137f0:	ebfff71b 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   137f4:	e3a00001 	mov	r0, #1
   137f8:	e3a01000 	mov	r1, #0
   137fc:	ebfff6da 	bl	1136c <bcm2835_delayMicroseconds>

  tm1638_send_raw(t, 0xc0 | addr);
   13800:	e55b3009 	ldrb	r3, [fp, #-9]
   13804:	e1e03d03 	mvn	r3, r3, lsl #26
   13808:	e1e03d23 	mvn	r3, r3, lsr #26
   1380c:	e6ef3073 	uxtb	r3, r3
   13810:	e1a01003 	mov	r1, r3
   13814:	e51b0008 	ldr	r0, [fp, #-8]
   13818:	ebffff58 	bl	13580 <tm1638_send_raw>
  tm1638_send_raw(t, data);
   1381c:	e55b300a 	ldrb	r3, [fp, #-10]
   13820:	e1a01003 	mov	r1, r3
   13824:	e51b0008 	ldr	r0, [fp, #-8]
   13828:	ebffff54 	bl	13580 <tm1638_send_raw>

  bcm2835_gpio_write(t->strobe, HIGH);
   1382c:	e51b3008 	ldr	r3, [fp, #-8]
   13830:	e5d33002 	ldrb	r3, [r3, #2]
   13834:	e3a01001 	mov	r1, #1
   13838:	e1a00003 	mov	r0, r3
   1383c:	ebfff708 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   13840:	e3a00001 	mov	r0, #1
   13844:	e3a01000 	mov	r1, #0
   13848:	ebfff6c7 	bl	1136c <bcm2835_delayMicroseconds>
}
   1384c:	e1a00000 	nop			; (mov r0, r0)
   13850:	e24bd004 	sub	sp, fp, #4
   13854:	e8bd8800 	pop	{fp, pc}

00013858 <tm1638_set_7seg_raw>:
    
/* See tm1638.h */
void tm1638_set_7seg_raw(const tm1638_p t, uint8_t digit, uint8_t n)
{
   13858:	e92d4800 	push	{fp, lr}
   1385c:	e28db004 	add	fp, sp, #4
   13860:	e24dd008 	sub	sp, sp, #8
   13864:	e50b0008 	str	r0, [fp, #-8]
   13868:	e1a03001 	mov	r3, r1
   1386c:	e54b3009 	strb	r3, [fp, #-9]
   13870:	e1a03002 	mov	r3, r2
   13874:	e54b300a 	strb	r3, [fp, #-10]
  tm1638_send_data(t, digit << 1, n);
   13878:	e55b3009 	ldrb	r3, [fp, #-9]
   1387c:	e1a03083 	lsl	r3, r3, #1
   13880:	e6ef3073 	uxtb	r3, r3
   13884:	e55b200a 	ldrb	r2, [fp, #-10]
   13888:	e1a01003 	mov	r1, r3
   1388c:	e51b0008 	ldr	r0, [fp, #-8]
   13890:	ebffffc7 	bl	137b4 <tm1638_send_data>
}
   13894:	e1a00000 	nop			; (mov r0, r0)
   13898:	e24bd004 	sub	sp, fp, #4
   1389c:	e8bd8800 	pop	{fp, pc}

000138a0 <tm1638_set_7seg_text>:

/* See tm1638.h */
void tm1638_set_7seg_text(const tm1638_p t, const char *str, uint8_t dots)
{
   138a0:	e92d4800 	push	{fp, lr}
   138a4:	e28db004 	add	fp, sp, #4
   138a8:	e24dd020 	sub	sp, sp, #32
   138ac:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
   138b0:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
   138b4:	e1a03002 	mov	r3, r2
   138b8:	e54b301d 	strb	r3, [fp, #-29]	; 0xffffffe3
  const char *p = str;
   138bc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   138c0:	e50b3008 	str	r3, [fp, #-8]

  for(int i = 0, j = 1; i < 8; i++, j <<= 1)
   138c4:	e3a03000 	mov	r3, #0
   138c8:	e50b300c 	str	r3, [fp, #-12]
   138cc:	e3a03001 	mov	r3, #1
   138d0:	e50b3010 	str	r3, [fp, #-16]
   138d4:	ea000022 	b	13964 <tm1638_set_7seg_text+0xc4>
    {
      // We want the loop to finish, but don't walk over the end of the string
      char c = *p;
   138d8:	e51b3008 	ldr	r3, [fp, #-8]
   138dc:	e5d33000 	ldrb	r3, [r3]
   138e0:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
      if (c)
   138e4:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
   138e8:	e3530000 	cmp	r3, #0
   138ec:	0a000002 	beq	138fc <tm1638_set_7seg_text+0x5c>
	p++;
   138f0:	e51b3008 	ldr	r3, [fp, #-8]
   138f4:	e2833001 	add	r3, r3, #1
   138f8:	e50b3008 	str	r3, [fp, #-8]
      
      uint8_t f =  tm1638_font(c);
   138fc:	e55b3012 	ldrb	r3, [fp, #-18]	; 0xffffffee
   13900:	e1a00003 	mov	r0, r3
   13904:	eb000089 	bl	13b30 <tm1638_font>
   13908:	e1a03000 	mov	r3, r0
   1390c:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef

      if (dots & j)
   13910:	e55b201d 	ldrb	r2, [fp, #-29]	; 0xffffffe3
   13914:	e51b3010 	ldr	r3, [fp, #-16]
   13918:	e0033002 	and	r3, r3, r2
   1391c:	e3530000 	cmp	r3, #0
   13920:	0a000003 	beq	13934 <tm1638_set_7seg_text+0x94>
	f |= 128;
   13924:	e55b3011 	ldrb	r3, [fp, #-17]	; 0xffffffef
   13928:	e1e03c83 	mvn	r3, r3, lsl #25
   1392c:	e1e03ca3 	mvn	r3, r3, lsr #25
   13930:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef

      tm1638_set_7seg_raw(t, i, f);
   13934:	e51b300c 	ldr	r3, [fp, #-12]
   13938:	e6ef3073 	uxtb	r3, r3
   1393c:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
   13940:	e1a01003 	mov	r1, r3
   13944:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
   13948:	ebffffc2 	bl	13858 <tm1638_set_7seg_raw>
  for(int i = 0, j = 1; i < 8; i++, j <<= 1)
   1394c:	e51b300c 	ldr	r3, [fp, #-12]
   13950:	e2833001 	add	r3, r3, #1
   13954:	e50b300c 	str	r3, [fp, #-12]
   13958:	e51b3010 	ldr	r3, [fp, #-16]
   1395c:	e1a03083 	lsl	r3, r3, #1
   13960:	e50b3010 	str	r3, [fp, #-16]
   13964:	e51b300c 	ldr	r3, [fp, #-12]
   13968:	e3530007 	cmp	r3, #7
   1396c:	daffffd9 	ble	138d8 <tm1638_set_7seg_text+0x38>
    }
}
   13970:	e1a00000 	nop			; (mov r0, r0)
   13974:	e24bd004 	sub	sp, fp, #4
   13978:	e8bd8800 	pop	{fp, pc}

0001397c <tm1638_set_led>:

/* See tm1638.h */
void tm1638_set_led(const tm1638_p t, uint8_t led, uint8_t cols)
{
   1397c:	e92d4800 	push	{fp, lr}
   13980:	e28db004 	add	fp, sp, #4
   13984:	e24dd008 	sub	sp, sp, #8
   13988:	e50b0008 	str	r0, [fp, #-8]
   1398c:	e1a03001 	mov	r3, r1
   13990:	e54b3009 	strb	r3, [fp, #-9]
   13994:	e1a03002 	mov	r3, r2
   13998:	e54b300a 	strb	r3, [fp, #-10]
  tm1638_send_data(t, (led << 1) + 1, cols);
   1399c:	e55b3009 	ldrb	r3, [fp, #-9]
   139a0:	e1a03083 	lsl	r3, r3, #1
   139a4:	e6ef3073 	uxtb	r3, r3
   139a8:	e2833001 	add	r3, r3, #1
   139ac:	e6ef3073 	uxtb	r3, r3
   139b0:	e55b200a 	ldrb	r2, [fp, #-10]
   139b4:	e1a01003 	mov	r1, r3
   139b8:	e51b0008 	ldr	r0, [fp, #-8]
   139bc:	ebffff7c 	bl	137b4 <tm1638_send_data>
}
   139c0:	e1a00000 	nop			; (mov r0, r0)
   139c4:	e24bd004 	sub	sp, fp, #4
   139c8:	e8bd8800 	pop	{fp, pc}

000139cc <tm1638_set_8leds>:

/* See tm1638.h */
void tm1638_set_8leds(const tm1638_p t, uint8_t red, uint8_t green)
{
   139cc:	e92d4800 	push	{fp, lr}
   139d0:	e28db004 	add	fp, sp, #4
   139d4:	e24dd010 	sub	sp, sp, #16
   139d8:	e50b0010 	str	r0, [fp, #-16]
   139dc:	e1a03001 	mov	r3, r1
   139e0:	e54b3011 	strb	r3, [fp, #-17]	; 0xffffffef
   139e4:	e1a03002 	mov	r3, r2
   139e8:	e54b3012 	strb	r3, [fp, #-18]	; 0xffffffee
  for(int i = 0, j = 128; i < 8; i++, j >>= 1)
   139ec:	e3a03000 	mov	r3, #0
   139f0:	e50b3008 	str	r3, [fp, #-8]
   139f4:	e3a03080 	mov	r3, #128	; 0x80
   139f8:	e50b300c 	str	r3, [fp, #-12]
   139fc:	ea00001c 	b	13a74 <tm1638_set_8leds+0xa8>
    tm1638_set_led(t, i, ((red & j) ? 1 : 0) + ((green & j) ? 2 : 0));
   13a00:	e51b3008 	ldr	r3, [fp, #-8]
   13a04:	e6ef1073 	uxtb	r1, r3
   13a08:	e55b2011 	ldrb	r2, [fp, #-17]	; 0xffffffef
   13a0c:	e51b300c 	ldr	r3, [fp, #-12]
   13a10:	e0033002 	and	r3, r3, r2
   13a14:	e3530000 	cmp	r3, #0
   13a18:	13a03001 	movne	r3, #1
   13a1c:	03a03000 	moveq	r3, #0
   13a20:	e6ef3073 	uxtb	r3, r3
   13a24:	e1a00003 	mov	r0, r3
   13a28:	e55b2012 	ldrb	r2, [fp, #-18]	; 0xffffffee
   13a2c:	e51b300c 	ldr	r3, [fp, #-12]
   13a30:	e0033002 	and	r3, r3, r2
   13a34:	e3530000 	cmp	r3, #0
   13a38:	0a000001 	beq	13a44 <tm1638_set_8leds+0x78>
   13a3c:	e3a03002 	mov	r3, #2
   13a40:	ea000000 	b	13a48 <tm1638_set_8leds+0x7c>
   13a44:	e3a03000 	mov	r3, #0
   13a48:	e0833000 	add	r3, r3, r0
   13a4c:	e6ef3073 	uxtb	r3, r3
   13a50:	e1a02003 	mov	r2, r3
   13a54:	e51b0010 	ldr	r0, [fp, #-16]
   13a58:	ebffffc7 	bl	1397c <tm1638_set_led>
  for(int i = 0, j = 128; i < 8; i++, j >>= 1)
   13a5c:	e51b3008 	ldr	r3, [fp, #-8]
   13a60:	e2833001 	add	r3, r3, #1
   13a64:	e50b3008 	str	r3, [fp, #-8]
   13a68:	e51b300c 	ldr	r3, [fp, #-12]
   13a6c:	e1a030c3 	asr	r3, r3, #1
   13a70:	e50b300c 	str	r3, [fp, #-12]
   13a74:	e51b3008 	ldr	r3, [fp, #-8]
   13a78:	e3530007 	cmp	r3, #7
   13a7c:	daffffdf 	ble	13a00 <tm1638_set_8leds+0x34>
}
   13a80:	e1a00000 	nop			; (mov r0, r0)
   13a84:	e24bd004 	sub	sp, fp, #4
   13a88:	e8bd8800 	pop	{fp, pc}

00013a8c <tm1638_send_cls>:

/* See tm1638.h */
void tm1638_send_cls(const tm1638_p t)
{
   13a8c:	e92d4800 	push	{fp, lr}
   13a90:	e28db004 	add	fp, sp, #4
   13a94:	e24dd010 	sub	sp, sp, #16
   13a98:	e50b0010 	str	r0, [fp, #-16]
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */
  tm1638_send_command(t, 0x40);
   13a9c:	e3a01040 	mov	r1, #64	; 0x40
   13aa0:	e51b0010 	ldr	r0, [fp, #-16]
   13aa4:	ebffff25 	bl	13740 <tm1638_send_command>

  bcm2835_gpio_write(t->strobe, LOW);
   13aa8:	e51b3010 	ldr	r3, [fp, #-16]
   13aac:	e5d33002 	ldrb	r3, [r3, #2]
   13ab0:	e3a01000 	mov	r1, #0
   13ab4:	e1a00003 	mov	r0, r3
   13ab8:	ebfff669 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   13abc:	e3a00001 	mov	r0, #1
   13ac0:	e3a01000 	mov	r1, #0
   13ac4:	ebfff628 	bl	1136c <bcm2835_delayMicroseconds>
  
  tm1638_send_raw(t, 0xc0);
   13ac8:	e3a010c0 	mov	r1, #192	; 0xc0
   13acc:	e51b0010 	ldr	r0, [fp, #-16]
   13ad0:	ebfffeaa 	bl	13580 <tm1638_send_raw>
  for(int i = 0; i < 16; i++)
   13ad4:	e3a03000 	mov	r3, #0
   13ad8:	e50b3008 	str	r3, [fp, #-8]
   13adc:	ea000005 	b	13af8 <tm1638_send_cls+0x6c>
    tm1638_send_raw(t, 0x00);
   13ae0:	e3a01000 	mov	r1, #0
   13ae4:	e51b0010 	ldr	r0, [fp, #-16]
   13ae8:	ebfffea4 	bl	13580 <tm1638_send_raw>
  for(int i = 0; i < 16; i++)
   13aec:	e51b3008 	ldr	r3, [fp, #-8]
   13af0:	e2833001 	add	r3, r3, #1
   13af4:	e50b3008 	str	r3, [fp, #-8]
   13af8:	e51b3008 	ldr	r3, [fp, #-8]
   13afc:	e353000f 	cmp	r3, #15
   13b00:	dafffff6 	ble	13ae0 <tm1638_send_cls+0x54>

  bcm2835_gpio_write(t->strobe, HIGH);
   13b04:	e51b3010 	ldr	r3, [fp, #-16]
   13b08:	e5d33002 	ldrb	r3, [r3, #2]
   13b0c:	e3a01001 	mov	r1, #1
   13b10:	e1a00003 	mov	r0, r3
   13b14:	ebfff652 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1); 
   13b18:	e3a00001 	mov	r0, #1
   13b1c:	e3a01000 	mov	r1, #0
   13b20:	ebfff611 	bl	1136c <bcm2835_delayMicroseconds>
}
   13b24:	e1a00000 	nop			; (mov r0, r0)
   13b28:	e24bd004 	sub	sp, fp, #4
   13b2c:	e8bd8800 	pop	{fp, pc}

00013b30 <tm1638_font>:

/* See tm1638.h */
uint8_t tm1638_font(char c)
{
   13b30:	e92d4800 	push	{fp, lr}
   13b34:	e28db004 	add	fp, sp, #4
   13b38:	e24dd088 	sub	sp, sp, #136	; 0x88
   13b3c:	e1a03000 	mov	r3, r0
   13b40:	e54b3085 	strb	r3, [fp, #-133]	; 0xffffff7b
  const uint8_t f[] = {
   13b44:	e59f2040 	ldr	r2, [pc, #64]	; 13b8c <tm1638_font+0x5c>
   13b48:	e24b3084 	sub	r3, fp, #132	; 0x84
   13b4c:	e1a01002 	mov	r1, r2
   13b50:	e3a02080 	mov	r2, #128	; 0x80
   13b54:	e1a00003 	mov	r0, r3
   13b58:	ebfff3a7 	bl	109fc <memcpy@plt>
    0x73, 0x67, 0x50, 0x6d,  0x78, 0x1c, 0x2a, 0x1d,

    0x76, 0x6e, 0x47, 0x46,  0x06, 0x70, 0x01, 0x00
  };

  return (c > 127) ? 0 : f[(unsigned char)c];
   13b5c:	e15b38d5 	ldrsb	r3, [fp, #-133]	; 0xffffff7b
   13b60:	e3530000 	cmp	r3, #0
   13b64:	ba000004 	blt	13b7c <tm1638_font+0x4c>
   13b68:	e55b3085 	ldrb	r3, [fp, #-133]	; 0xffffff7b
   13b6c:	e24b2004 	sub	r2, fp, #4
   13b70:	e0823003 	add	r3, r2, r3
   13b74:	e5533080 	ldrb	r3, [r3, #-128]	; 0xffffff80
   13b78:	ea000000 	b	13b80 <tm1638_font+0x50>
   13b7c:	e3a03000 	mov	r3, #0
}
   13b80:	e1a00003 	mov	r0, r3
   13b84:	e24bd004 	sub	sp, fp, #4
   13b88:	e8bd8800 	pop	{fp, pc}
   13b8c:	000162a8 	.word	0x000162a8

00013b90 <tm1638_read_buttons>:

/* See tm1638.h */
uint32_t tm1638_read_buttons(const tm1638_p t)
{
   13b90:	e92d4800 	push	{fp, lr}
   13b94:	e28db004 	add	fp, sp, #4
   13b98:	e24dd010 	sub	sp, sp, #16
   13b9c:	e50b0010 	str	r0, [fp, #-16]
  /* The delays in this code are somewhat arbitrary: they work for me
     but I make no claims that they are optimal or robust */
  bcm2835_gpio_write(t->strobe, LOW);
   13ba0:	e51b3010 	ldr	r3, [fp, #-16]
   13ba4:	e5d33002 	ldrb	r3, [r3, #2]
   13ba8:	e3a01000 	mov	r1, #0
   13bac:	e1a00003 	mov	r0, r3
   13bb0:	ebfff62b 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   13bb4:	e3a00001 	mov	r0, #1
   13bb8:	e3a01000 	mov	r1, #0
   13bbc:	ebfff5ea 	bl	1136c <bcm2835_delayMicroseconds>

  tm1638_send_raw(t, 0x42);
   13bc0:	e3a01042 	mov	r1, #66	; 0x42
   13bc4:	e51b0010 	ldr	r0, [fp, #-16]
   13bc8:	ebfffe6c 	bl	13580 <tm1638_send_raw>
  
  uint32_t x = 0;
   13bcc:	e3a03000 	mov	r3, #0
   13bd0:	e50b3008 	str	r3, [fp, #-8]
  for(int i = 0; i < 4; i++)
   13bd4:	e3a03000 	mov	r3, #0
   13bd8:	e50b300c 	str	r3, [fp, #-12]
   13bdc:	ea00000c 	b	13c14 <tm1638_read_buttons+0x84>
    {
      x <<= 8;
   13be0:	e51b3008 	ldr	r3, [fp, #-8]
   13be4:	e1a03403 	lsl	r3, r3, #8
   13be8:	e50b3008 	str	r3, [fp, #-8]
      x |= tm1638_receive_raw(t);
   13bec:	e51b0010 	ldr	r0, [fp, #-16]
   13bf0:	ebfffe92 	bl	13640 <tm1638_receive_raw>
   13bf4:	e1a03000 	mov	r3, r0
   13bf8:	e1a02003 	mov	r2, r3
   13bfc:	e51b3008 	ldr	r3, [fp, #-8]
   13c00:	e1833002 	orr	r3, r3, r2
   13c04:	e50b3008 	str	r3, [fp, #-8]
  for(int i = 0; i < 4; i++)
   13c08:	e51b300c 	ldr	r3, [fp, #-12]
   13c0c:	e2833001 	add	r3, r3, #1
   13c10:	e50b300c 	str	r3, [fp, #-12]
   13c14:	e51b300c 	ldr	r3, [fp, #-12]
   13c18:	e3530003 	cmp	r3, #3
   13c1c:	daffffef 	ble	13be0 <tm1638_read_buttons+0x50>
    }

  bcm2835_gpio_write(t->strobe, HIGH);
   13c20:	e51b3010 	ldr	r3, [fp, #-16]
   13c24:	e5d33002 	ldrb	r3, [r3, #2]
   13c28:	e3a01001 	mov	r1, #1
   13c2c:	e1a00003 	mov	r0, r3
   13c30:	ebfff60b 	bl	11464 <bcm2835_gpio_write>
  delayMicroseconds(1);
   13c34:	e3a00001 	mov	r0, #1
   13c38:	e3a01000 	mov	r1, #0
   13c3c:	ebfff5ca 	bl	1136c <bcm2835_delayMicroseconds>

  return x;
   13c40:	e51b3008 	ldr	r3, [fp, #-8]
}
   13c44:	e1a00003 	mov	r0, r3
   13c48:	e24bd004 	sub	sp, fp, #4
   13c4c:	e8bd8800 	pop	{fp, pc}

00013c50 <tm1638_read_8buttons>:

/* See tm1638.h */
uint8_t tm1638_read_8buttons(const tm1638_p t)
{
   13c50:	e92d4800 	push	{fp, lr}
   13c54:	e28db004 	add	fp, sp, #4
   13c58:	e24dd018 	sub	sp, sp, #24
   13c5c:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
  uint32_t x = tm1638_read_buttons(t);
   13c60:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
   13c64:	ebffffc9 	bl	13b90 <tm1638_read_buttons>
   13c68:	e50b0008 	str	r0, [fp, #-8]
  uint8_t  y = 0;
   13c6c:	e3a03000 	mov	r3, #0
   13c70:	e54b3009 	strb	r3, [fp, #-9]
  
  for(int i = 0; i < 4; i++)
   13c74:	e3a03000 	mov	r3, #0
   13c78:	e50b3010 	str	r3, [fp, #-16]
   13c7c:	ea000015 	b	13cd8 <tm1638_read_8buttons+0x88>
    {
      y <<= 1;
   13c80:	e55b3009 	ldrb	r3, [fp, #-9]
   13c84:	e1a03083 	lsl	r3, r3, #1
   13c88:	e54b3009 	strb	r3, [fp, #-9]

      if (x & 0x80000000)
   13c8c:	e51b3008 	ldr	r3, [fp, #-8]
   13c90:	e3530000 	cmp	r3, #0
   13c94:	aa000002 	bge	13ca4 <tm1638_read_8buttons+0x54>
	y |= 0x10;
   13c98:	e55b3009 	ldrb	r3, [fp, #-9]
   13c9c:	e3833010 	orr	r3, r3, #16
   13ca0:	e54b3009 	strb	r3, [fp, #-9]

      if (x & 0x08000000)
   13ca4:	e51b3008 	ldr	r3, [fp, #-8]
   13ca8:	e2033302 	and	r3, r3, #134217728	; 0x8000000
   13cac:	e3530000 	cmp	r3, #0
   13cb0:	0a000002 	beq	13cc0 <tm1638_read_8buttons+0x70>
	y |= 0x01;
   13cb4:	e55b3009 	ldrb	r3, [fp, #-9]
   13cb8:	e3833001 	orr	r3, r3, #1
   13cbc:	e54b3009 	strb	r3, [fp, #-9]

      x <<= 8;
   13cc0:	e51b3008 	ldr	r3, [fp, #-8]
   13cc4:	e1a03403 	lsl	r3, r3, #8
   13cc8:	e50b3008 	str	r3, [fp, #-8]
  for(int i = 0; i < 4; i++)
   13ccc:	e51b3010 	ldr	r3, [fp, #-16]
   13cd0:	e2833001 	add	r3, r3, #1
   13cd4:	e50b3010 	str	r3, [fp, #-16]
   13cd8:	e51b3010 	ldr	r3, [fp, #-16]
   13cdc:	e3530003 	cmp	r3, #3
   13ce0:	daffffe6 	ble	13c80 <tm1638_read_8buttons+0x30>
    }

  return y;
   13ce4:	e55b3009 	ldrb	r3, [fp, #-9]
}
   13ce8:	e1a00003 	mov	r0, r3
   13cec:	e24bd004 	sub	sp, fp, #4
   13cf0:	e8bd8800 	pop	{fp, pc}

00013cf4 <transferAndWait>:

/*
  Procedure to transfer/receive 1 uint8_t
*/
uint8_t transferAndWait(const uint8_t what)
{
   13cf4:	e92d4800 	push	{fp, lr}
   13cf8:	e28db004 	add	fp, sp, #4
   13cfc:	e24dd010 	sub	sp, sp, #16
   13d00:	e1a03000 	mov	r3, r0
   13d04:	e54b300d 	strb	r3, [fp, #-13]
  uint8_t a = bcm2835_aux_spi_transfer(what);
   13d08:	e55b300d 	ldrb	r3, [fp, #-13]
   13d0c:	e1a00003 	mov	r0, r3
   13d10:	ebfff73b 	bl	11a04 <bcm2835_aux_spi_transfer>
   13d14:	e1a03000 	mov	r3, r0
   13d18:	e54b3005 	strb	r3, [fp, #-5]
  delay (1);
   13d1c:	e3a00001 	mov	r0, #1
   13d20:	ebfff56b 	bl	112d4 <bcm2835_delay>
  return a;
   13d24:	e55b3005 	ldrb	r3, [fp, #-5]
} // end of transferAndWait
   13d28:	e1a00003 	mov	r0, r3
   13d2c:	e24bd004 	sub	sp, fp, #4
   13d30:	e8bd8800 	pop	{fp, pc}

00013d34 <transferMsG>:

/*
  Procedure to transfer/receive Message
*/
void transferMsG(uint8_t* pMsgRec , uint8_t* pMsgTr)
{
   13d34:	e92d4800 	push	{fp, lr}
   13d38:	e28db004 	add	fp, sp, #4
   13d3c:	e24dd010 	sub	sp, sp, #16
   13d40:	e50b0010 	str	r0, [fp, #-16]
   13d44:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
#define MinTime  1000 // More than 1 s
  static uint32_t LastTime;
  uint16_t TimeDelta;

  bcm2835_gpio_clr(MODUL_ISP_PIN);
   13d48:	e3a00019 	mov	r0, #25
   13d4c:	ebfff523 	bl	111e0 <bcm2835_gpio_clr>

  (void)transferAndWait(*pMsgTr); // First uint8_t without receiving
   13d50:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   13d54:	e5d33000 	ldrb	r3, [r3]
   13d58:	e1a00003 	mov	r0, r3
   13d5c:	ebffffe4 	bl	13cf4 <transferAndWait>

  //Serial.print(*pMsgTr); Serial.print("; "); Serial.println(*pMsgRec);
///  delay (1);
  pMsgTr++;
   13d60:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   13d64:	e2833001 	add	r3, r3, #1
   13d68:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
  for (uint8_t Index = 1; Index < kMsgLength; Index++, pMsgRec++, pMsgTr++)
   13d6c:	e3a03001 	mov	r3, #1
   13d70:	e54b3005 	strb	r3, [fp, #-5]
   13d74:	ea000010 	b	13dbc <transferMsG+0x88>
  {
    *pMsgRec = transferAndWait(*pMsgTr);
   13d78:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   13d7c:	e5d33000 	ldrb	r3, [r3]
   13d80:	e1a00003 	mov	r0, r3
   13d84:	ebffffda 	bl	13cf4 <transferAndWait>
   13d88:	e1a03000 	mov	r3, r0
   13d8c:	e1a02003 	mov	r2, r3
   13d90:	e51b3010 	ldr	r3, [fp, #-16]
   13d94:	e5c32000 	strb	r2, [r3]
  for (uint8_t Index = 1; Index < kMsgLength; Index++, pMsgRec++, pMsgTr++)
   13d98:	e55b3005 	ldrb	r3, [fp, #-5]
   13d9c:	e2833001 	add	r3, r3, #1
   13da0:	e54b3005 	strb	r3, [fp, #-5]
   13da4:	e51b3010 	ldr	r3, [fp, #-16]
   13da8:	e2833001 	add	r3, r3, #1
   13dac:	e50b3010 	str	r3, [fp, #-16]
   13db0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   13db4:	e2833001 	add	r3, r3, #1
   13db8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
   13dbc:	e55b3005 	ldrb	r3, [fp, #-5]
   13dc0:	e3530009 	cmp	r3, #9
   13dc4:	9affffeb 	bls	13d78 <transferMsG+0x44>
    //Serial.print(*pMsgTr); Serial.print("; "); Serial.println(*pMsgRec);
  }
  *pMsgRec = transferAndWait(77);// Last uint8_t only for receiving
   13dc8:	e3a0004d 	mov	r0, #77	; 0x4d
   13dcc:	ebffffc8 	bl	13cf4 <transferAndWait>
   13dd0:	e1a03000 	mov	r3, r0
   13dd4:	e1a02003 	mov	r2, r3
   13dd8:	e51b3010 	ldr	r3, [fp, #-16]
   13ddc:	e5c32000 	strb	r2, [r3]

  bcm2835_gpio_set(MODUL_ISP_PIN);
   13de0:	e3a00019 	mov	r0, #25
   13de4:	ebfff4e2 	bl	11174 <bcm2835_gpio_set>

  return;
   13de8:	e1a00000 	nop			; (mov r0, r0)
}
   13dec:	e24bd004 	sub	sp, fp, #4
   13df0:	e8bd8800 	pop	{fp, pc}

00013df4 <setExecuteModule>:

/* boolean setExecuteModule(void)
 * The function prepares
 * */
boolean setExecuteModule(void)
{
   13df4:	e92d4800 	push	{fp, lr}
   13df8:	e28db004 	add	fp, sp, #4
   13dfc:	e24dd020 	sub	sp, sp, #32
   uint16_t iLocalWork;

   boolean Result;

   // FALSE if error
   Result = FALSE;
   13e00:	e3a03000 	mov	r3, #0
   13e04:	e14b30b8 	strh	r3, [fp, #-8]

   for (iLocalWork = 0; iLocalWork < kMsgLength; iLocalWork++)
   13e08:	e3a03000 	mov	r3, #0
   13e0c:	e14b30b6 	strh	r3, [fp, #-6]
   13e10:	ea00000c 	b	13e48 <setExecuteModule+0x54>
   {
      fLocalTxObject.cTxData[iLocalWork] = 0;
   13e14:	e15b30b6 	ldrh	r3, [fp, #-6]
   13e18:	e24b2004 	sub	r2, fp, #4
   13e1c:	e0823003 	add	r3, r2, r3
   13e20:	e3a02000 	mov	r2, #0
   13e24:	e5432010 	strb	r2, [r3, #-16]
      fLocalRxObject.cRxData[iLocalWork] = 0;
   13e28:	e15b30b6 	ldrh	r3, [fp, #-6]
   13e2c:	e24b2004 	sub	r2, fp, #4
   13e30:	e0823003 	add	r3, r2, r3
   13e34:	e3a02000 	mov	r2, #0
   13e38:	e543201c 	strb	r2, [r3, #-28]	; 0xffffffe4
   for (iLocalWork = 0; iLocalWork < kMsgLength; iLocalWork++)
   13e3c:	e15b30b6 	ldrh	r3, [fp, #-6]
   13e40:	e2833001 	add	r3, r3, #1
   13e44:	e14b30b6 	strh	r3, [fp, #-6]
   13e48:	e15b30b6 	ldrh	r3, [fp, #-6]
   13e4c:	e3530009 	cmp	r3, #9
   13e50:	9affffef 	bls	13e14 <setExecuteModule+0x20>
   }

   if (eSystemState != keIdle)
   13e54:	e59f30a4 	ldr	r3, [pc, #164]	; 13f00 <setExecuteModule+0x10c>
   13e58:	e5933000 	ldr	r3, [r3]
   13e5c:	e3530003 	cmp	r3, #3
   13e60:	0a000003 	beq	13e74 <setExecuteModule+0x80>
   {
      // If the State is not "Idle" the setting is allowed
      fLocalTxObject.TxObj.FlagCommand.sFlagCommand.bStartSetting = TRUE;
   13e64:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
   13e68:	e3833080 	orr	r3, r3, #128	; 0x80
   13e6c:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
   13e70:	ea000002 	b	13e80 <setExecuteModule+0x8c>
   }
   else
   {
      fLocalTxObject.TxObj.FlagCommand.sFlagCommand.bStartSetting = FALSE;
   13e74:	e55b3013 	ldrb	r3, [fp, #-19]	; 0xffffffed
   13e78:	e3c33080 	bic	r3, r3, #128	; 0x80
   13e7c:	e54b3013 	strb	r3, [fp, #-19]	; 0xffffffed
   }

   fLocalTxObject.TxObj.HeaterCommand = GetHeaterSetpoint();;
   13e80:	eb00051b 	bl	152f4 <GetHeaterSetpoint>
   13e84:	e1a03000 	mov	r3, r0
   13e88:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee

   fLocalTxObject.TxObj.CoolerCommand = GetCoolerSetpoint();
   13e8c:	eb000521 	bl	15318 <GetCoolerSetpoint>
   13e90:	e1a03000 	mov	r3, r0
   13e94:	e14b31b0 	strh	r3, [fp, #-16]

#ifdef VALVE_CONTROL
    fLocalTxObject.TxObj.ValveCommand = GetCoolerSetpoint();
   13e98:	eb00051e 	bl	15318 <GetCoolerSetpoint>
   13e9c:	e1a03000 	mov	r3, r0
   13ea0:	e14b30be 	strh	r3, [fp, #-14]
#endif

   fLocalTxObject.TxObj.startSymbol = '>';
   13ea4:	e3a0303e 	mov	r3, #62	; 0x3e
   13ea8:	e54b3014 	strb	r3, [fp, #-20]	; 0xffffffec
   fLocalTxObject.TxObj.checkSum = Tx_CheckSumCalcul(&fLocalTxObject);
   13eac:	e24b3014 	sub	r3, fp, #20
   13eb0:	e1a00003 	mov	r0, r3
   13eb4:	eb000035 	bl	13f90 <Tx_CheckSumCalcul>
   13eb8:	e1a03000 	mov	r3, r0
   13ebc:	e54b300c 	strb	r3, [fp, #-12]
   fLocalTxObject.TxObj.stopSymbol = '<';
   13ec0:	e3a0303c 	mov	r3, #60	; 0x3c
   13ec4:	e54b300b 	strb	r3, [fp, #-11]

   transferMsG(&fLocalRxObject.cRxData[0], &fLocalTxObject.cTxData[0]);
   13ec8:	e24b2014 	sub	r2, fp, #20
   13ecc:	e24b3020 	sub	r3, fp, #32
   13ed0:	e1a01002 	mov	r1, r2
   13ed4:	e1a00003 	mov	r0, r3
   13ed8:	ebffff95 	bl	13d34 <transferMsG>

   Result = ProcessReceived(&fLocalRxObject);
   13edc:	e24b3020 	sub	r3, fp, #32
   13ee0:	e1a00003 	mov	r0, r3
   13ee4:	eb000006 	bl	13f04 <ProcessReceived>
   13ee8:	e1a03000 	mov	r3, r0
   13eec:	e14b30b8 	strh	r3, [fp, #-8]

   return(Result);
   13ef0:	e15b30b8 	ldrh	r3, [fp, #-8]
}
   13ef4:	e1a00003 	mov	r0, r3
   13ef8:	e24bd004 	sub	sp, fp, #4
   13efc:	e8bd8800 	pop	{fp, pc}
   13f00:	00027268 	.word	0x00027268

00013f04 <ProcessReceived>:

boolean ProcessReceived(fExecutive_RxObj_Union* pReceivedObject)
{
   13f04:	e92d4800 	push	{fp, lr}
   13f08:	e28db004 	add	fp, sp, #4
   13f0c:	e24dd010 	sub	sp, sp, #16
   13f10:	e50b0010 	str	r0, [fp, #-16]
   boolean Result;
   uint16_t ReceivedCheckSum;

   ReceivedCheckSum = Rx_CheckSumCalcul(pReceivedObject);
   13f14:	e51b0010 	ldr	r0, [fp, #-16]
   13f18:	eb000036 	bl	13ff8 <Rx_CheckSumCalcul>
   13f1c:	e1a03000 	mov	r3, r0
   13f20:	e14b30b8 	strh	r3, [fp, #-8]

   if (ReceivedCheckSum == pReceivedObject->RxObj.checkSum)
   13f24:	e51b3010 	ldr	r3, [fp, #-16]
   13f28:	e5d33009 	ldrb	r3, [r3, #9]
   13f2c:	e6ff3073 	uxth	r3, r3
   13f30:	e15b20b8 	ldrh	r2, [fp, #-8]
   13f34:	e1520003 	cmp	r2, r3
   13f38:	1a000006 	bne	13f58 <ProcessReceived+0x54>
   {
      Result = TRUE;
   13f3c:	e3a03001 	mov	r3, #1
   13f40:	e14b30b6 	strh	r3, [fp, #-6]

      // Status of power plate
      fPowerModulStatus.cStatusByte = pReceivedObject->RxObj.Status.cStatusByte;
   13f44:	e51b3010 	ldr	r3, [fp, #-16]
   13f48:	e5d32002 	ldrb	r2, [r3, #2]
   13f4c:	e59f3030 	ldr	r3, [pc, #48]	; 13f84 <ProcessReceived+0x80>
   13f50:	e5c32000 	strb	r2, [r3]
   13f54:	ea000003 	b	13f68 <ProcessReceived+0x64>

   }
   else
   {
      Result = FALSE;
   13f58:	e3a03000 	mov	r3, #0
   13f5c:	e14b30b6 	strh	r3, [fp, #-6]
      printf("Something wrong\r\n");
   13f60:	e59f0020 	ldr	r0, [pc, #32]	; 13f88 <ProcessReceived+0x84>
   13f64:	ebfff277 	bl	10948 <puts@plt>

   }

   // Save state of the executive (Power plate)
   bExecutiveDetected = Result;
   13f68:	e59f201c 	ldr	r2, [pc, #28]	; 13f8c <ProcessReceived+0x88>
   13f6c:	e15b30b6 	ldrh	r3, [fp, #-6]
   13f70:	e1c230b0 	strh	r3, [r2]

   return(Result);
   13f74:	e15b30b6 	ldrh	r3, [fp, #-6]
}
   13f78:	e1a00003 	mov	r0, r3
   13f7c:	e24bd004 	sub	sp, fp, #4
   13f80:	e8bd8800 	pop	{fp, pc}
   13f84:	00027290 	.word	0x00027290
   13f88:	00016328 	.word	0x00016328
   13f8c:	000275d0 	.word	0x000275d0

00013f90 <Tx_CheckSumCalcul>:

uint8_t Tx_CheckSumCalcul(fExecutive_TxObj_Union* pTransmitObject)
{
   13f90:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   13f94:	e28db000 	add	fp, sp, #0
   13f98:	e24dd014 	sub	sp, sp, #20
   13f9c:	e50b0010 	str	r0, [fp, #-16]
   uint8_t  cCheckSum;
   uint16_t iIndex;

   cCheckSum = 0;
   13fa0:	e3a03000 	mov	r3, #0
   13fa4:	e54b3005 	strb	r3, [fp, #-5]

   for (iIndex = 0; iIndex < kMsgLength - 2; iIndex++)
   13fa8:	e3a03000 	mov	r3, #0
   13fac:	e14b30b8 	strh	r3, [fp, #-8]
   13fb0:	ea000008 	b	13fd8 <Tx_CheckSumCalcul+0x48>
   {
      cCheckSum += pTransmitObject->cTxData[iIndex];
   13fb4:	e15b30b8 	ldrh	r3, [fp, #-8]
   13fb8:	e51b2010 	ldr	r2, [fp, #-16]
   13fbc:	e7d22003 	ldrb	r2, [r2, r3]
   13fc0:	e55b3005 	ldrb	r3, [fp, #-5]
   13fc4:	e0823003 	add	r3, r2, r3
   13fc8:	e54b3005 	strb	r3, [fp, #-5]
   for (iIndex = 0; iIndex < kMsgLength - 2; iIndex++)
   13fcc:	e15b30b8 	ldrh	r3, [fp, #-8]
   13fd0:	e2833001 	add	r3, r3, #1
   13fd4:	e14b30b8 	strh	r3, [fp, #-8]
   13fd8:	e15b30b8 	ldrh	r3, [fp, #-8]
   13fdc:	e3530007 	cmp	r3, #7
   13fe0:	9afffff3 	bls	13fb4 <Tx_CheckSumCalcul+0x24>
   }

   return(cCheckSum);
   13fe4:	e55b3005 	ldrb	r3, [fp, #-5]
};
   13fe8:	e1a00003 	mov	r0, r3
   13fec:	e28bd000 	add	sp, fp, #0
   13ff0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   13ff4:	e12fff1e 	bx	lr

00013ff8 <Rx_CheckSumCalcul>:

uint8_t Rx_CheckSumCalcul(fExecutive_RxObj_Union* pReceiveObject)
{
   13ff8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   13ffc:	e28db000 	add	fp, sp, #0
   14000:	e24dd014 	sub	sp, sp, #20
   14004:	e50b0010 	str	r0, [fp, #-16]
   uint8_t  cCheckSum;
   uint16_t iIndex;

   cCheckSum = 0;
   14008:	e3a03000 	mov	r3, #0
   1400c:	e54b3005 	strb	r3, [fp, #-5]

   for (iIndex = 0; iIndex < kMsgLength-1; iIndex++)
   14010:	e3a03000 	mov	r3, #0
   14014:	e14b30b8 	strh	r3, [fp, #-8]
   14018:	ea000008 	b	14040 <Rx_CheckSumCalcul+0x48>
   {
      cCheckSum += pReceiveObject->cRxData[iIndex];
   1401c:	e15b30b8 	ldrh	r3, [fp, #-8]
   14020:	e51b2010 	ldr	r2, [fp, #-16]
   14024:	e7d22003 	ldrb	r2, [r2, r3]
   14028:	e55b3005 	ldrb	r3, [fp, #-5]
   1402c:	e0823003 	add	r3, r2, r3
   14030:	e54b3005 	strb	r3, [fp, #-5]
   for (iIndex = 0; iIndex < kMsgLength-1; iIndex++)
   14034:	e15b30b8 	ldrh	r3, [fp, #-8]
   14038:	e2833001 	add	r3, r3, #1
   1403c:	e14b30b8 	strh	r3, [fp, #-8]
   14040:	e15b30b8 	ldrh	r3, [fp, #-8]
   14044:	e3530008 	cmp	r3, #8
   14048:	9afffff3 	bls	1401c <Rx_CheckSumCalcul+0x24>
   }

   return(cCheckSum);
   1404c:	e55b3005 	ldrb	r3, [fp, #-5]
};
   14050:	e1a00003 	mov	r0, r3
   14054:	e28bd000 	add	sp, fp, #0
   14058:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1405c:	e12fff1e 	bx	lr

00014060 <executeModulControl>:


void executeModulControl(void)
{
   14060:	e92d4800 	push	{fp, lr}
   14064:	e28db004 	add	fp, sp, #4

   setExecuteModule();
   14068:	ebffff61 	bl	13df4 <setExecuteModule>

}
   1406c:	e1a00000 	nop			; (mov r0, r0)
   14070:	e8bd8800 	pop	{fp, pc}

00014074 <Handler>:


int ADC_Init(void);

void  Handler(int signo)
{
   14074:	e92d4800 	push	{fp, lr}
   14078:	e28db004 	add	fp, sp, #4
   1407c:	e24dd008 	sub	sp, sp, #8
   14080:	e50b0008 	str	r0, [fp, #-8]
    //System Exit
    printf("\r\nEND                  \r\n");
   14084:	e59f000c 	ldr	r0, [pc, #12]	; 14098 <Handler+0x24>
   14088:	ebfff22e 	bl	10948 <puts@plt>
    DEV_ModuleExit();
   1408c:	ebfff37b 	bl	10e80 <DEV_ModuleExit>

    exit(0);
   14090:	e3a00000 	mov	r0, #0
   14094:	ebfff222 	bl	10924 <exit@plt>
   14098:	0001633c 	.word	0x0001633c

0001409c <ADC_Init>:
}

int ADC_Init(void)
{
   1409c:	e92d4800 	push	{fp, lr}
   140a0:	e28db004 	add	fp, sp, #4
    DEV_ModuleInit();
   140a4:	ebfff35f 	bl	10e28 <DEV_ModuleInit>

    // Exception handling:ctrl + c
    signal(SIGINT, Handler);
   140a8:	e59f1034 	ldr	r1, [pc, #52]	; 140e4 <ADC_Init+0x48>
   140ac:	e3a00002 	mov	r0, #2
   140b0:	ebfff212 	bl	10900 <signal@plt>

    if(ADS1256_init() == 1)
   140b4:	eb0001a9 	bl	14760 <ADS1256_init>
   140b8:	e1a03000 	mov	r3, r0
   140bc:	e3530001 	cmp	r3, #1
   140c0:	1a000004 	bne	140d8 <ADC_Init+0x3c>
    {
       // It means erroneous initialize,
       // so the Program exits
        printf("\r\nEND                  \r\n");
   140c4:	e59f001c 	ldr	r0, [pc, #28]	; 140e8 <ADC_Init+0x4c>
   140c8:	ebfff21e 	bl	10948 <puts@plt>
        DEV_ModuleExit();
   140cc:	ebfff36b 	bl	10e80 <DEV_ModuleExit>
        exit(0);
   140d0:	e3a00000 	mov	r0, #0
   140d4:	ebfff212 	bl	10924 <exit@plt>
    }

    return TRUE;
   140d8:	e3a03001 	mov	r3, #1
}
   140dc:	e1a00003 	mov	r0, r3
   140e0:	e8bd8800 	pop	{fp, pc}
   140e4:	00014074 	.word	0x00014074
   140e8:	0001633c 	.word	0x0001633c

000140ec <GetADCData>:

UDOUBLE GetADCData(uint16_t ChannelNumber)
{
   140ec:	e92d4800 	push	{fp, lr}
   140f0:	e28db004 	add	fp, sp, #4
   140f4:	e24dd030 	sub	sp, sp, #48	; 0x30
   140f8:	e1a03000 	mov	r3, r0
   140fc:	e14b32be 	strh	r3, [fp, #-46]	; 0xffffffd2
   UDOUBLE Result;
   UDOUBLE ADC[8];
   //float x;

   Result = ADS1256_GetChannalValue(ChannelNumber);
   14100:	e15b32be 	ldrh	r3, [fp, #-46]	; 0xffffffd2
   14104:	e6ef3073 	uxtb	r3, r3
   14108:	e1a00003 	mov	r0, r3
   1410c:	eb0001e9 	bl	148b8 <ADS1256_GetChannalValue>
   14110:	e50b0008 	str	r0, [fp, #-8]

   return(Result);
   14114:	e51b3008 	ldr	r3, [fp, #-8]
}
   14118:	e1a00003 	mov	r0, r3
   1411c:	e24bd004 	sub	sp, fp, #4
   14120:	e8bd8800 	pop	{fp, pc}

00014124 <updateCurrentVoltages>:
 *  New measured value Uz
 *  Ucurrent = Uz
 *  Ulast    = Ux
 * ------------------------------------------------------------------------------------ */
void updateCurrentVoltages(void)
{
   14124:	e92d4800 	push	{fp, lr}
   14128:	e28db004 	add	fp, sp, #4
   1412c:	e24dd020 	sub	sp, sp, #32
   static struct timespec spec;
   struct timespec specLocal;
   uint64_t llWorkLocal;
   uint32_t lMilliSeconds;

   UDOUBLE lLocalADCValue = GetADCData(kSensorInput);
   14130:	e3a00000 	mov	r0, #0
   14134:	ebffffec 	bl	140ec <GetADCData>
   14138:	e50b0008 	str	r0, [fp, #-8]
   float NewVoltageValue  = convertCodeADC(lLocalADCValue);
   1413c:	e51b0008 	ldr	r0, [fp, #-8]
   14140:	eb00004c 	bl	14278 <convertCodeADC>
   14144:	ed0b0a03 	vstr	s0, [fp, #-12]

   clock_gettime(CLOCK_MONOTONIC, &specLocal);
   14148:	e24b3020 	sub	r3, fp, #32
   1414c:	e1a01003 	mov	r1, r3
   14150:	e3a00001 	mov	r0, #1
   14154:	ebfff20d 	bl	10990 <clock_gettime@plt>
   llWorkLocal = 1000000000*(specLocal.tv_sec - spec.tv_sec) + (specLocal.tv_nsec - spec.tv_nsec);
   14158:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   1415c:	e59f30c0 	ldr	r3, [pc, #192]	; 14224 <updateCurrentVoltages+0x100>
   14160:	e5933000 	ldr	r3, [r3]
   14164:	e0423003 	sub	r3, r2, r3
   14168:	e59f20b8 	ldr	r2, [pc, #184]	; 14228 <updateCurrentVoltages+0x104>
   1416c:	e0020392 	mul	r2, r2, r3
   14170:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
   14174:	e59f30a8 	ldr	r3, [pc, #168]	; 14224 <updateCurrentVoltages+0x100>
   14178:	e5933004 	ldr	r3, [r3, #4]
   1417c:	e0413003 	sub	r3, r1, r3
   14180:	e0823003 	add	r3, r2, r3
   14184:	e1a02003 	mov	r2, r3
   14188:	e1a03fc2 	asr	r3, r2, #31
   1418c:	e14b21f4 	strd	r2, [fp, #-20]	; 0xffffffec
   lMilliSeconds = llWorkLocal / 1000000;
   14190:	e14b01d4 	ldrd	r0, [fp, #-20]	; 0xffffffec
   14194:	e59f2090 	ldr	r2, [pc, #144]	; 1422c <updateCurrentVoltages+0x108>
   14198:	e3a03000 	mov	r3, #0
   1419c:	eb0006f6 	bl	15d7c <__aeabi_uldivmod>
   141a0:	e1a02000 	mov	r2, r0
   141a4:	e1a03001 	mov	r3, r1
   141a8:	e1a03002 	mov	r3, r2
   141ac:	e50b3018 	str	r3, [fp, #-24]	; 0xffffffe8
   spec = specLocal;
   141b0:	e59f306c 	ldr	r3, [pc, #108]	; 14224 <updateCurrentVoltages+0x100>
   141b4:	e1a02003 	mov	r2, r3
   141b8:	e24b3020 	sub	r3, fp, #32
   141bc:	e8930003 	ldm	r3, {r0, r1}
   141c0:	e8820003 	stm	r2, {r0, r1}

   pthread_mutex_lock(&data_lock);
   141c4:	e59f0064 	ldr	r0, [pc, #100]	; 14230 <updateCurrentVoltages+0x10c>
   141c8:	ebfff1cf 	bl	1090c <pthread_mutex_lock@plt>

   sSensorData.fVoltageLast    = sSensorData.fVoltageCurrent;
   141cc:	e59f3060 	ldr	r3, [pc, #96]	; 14234 <updateCurrentVoltages+0x110>
   141d0:	e5933000 	ldr	r3, [r3]
   141d4:	e59f2058 	ldr	r2, [pc, #88]	; 14234 <updateCurrentVoltages+0x110>
   141d8:	e5823004 	str	r3, [r2, #4]
   sSensorData.fVoltageCurrent = NewVoltageValue;
   141dc:	e59f2050 	ldr	r2, [pc, #80]	; 14234 <updateCurrentVoltages+0x110>
   141e0:	e51b300c 	ldr	r3, [fp, #-12]
   141e4:	e5823000 	str	r3, [r2]
   sSensorData.lUlast          = sSensorData.lUcurrent;
   141e8:	e59f3044 	ldr	r3, [pc, #68]	; 14234 <updateCurrentVoltages+0x110>
   141ec:	e5933010 	ldr	r3, [r3, #16]
   141f0:	e59f203c 	ldr	r2, [pc, #60]	; 14234 <updateCurrentVoltages+0x110>
   141f4:	e582300c 	str	r3, [r2, #12]
   sSensorData.lUcurrent       = lLocalADCValue;
   141f8:	e59f2034 	ldr	r2, [pc, #52]	; 14234 <updateCurrentVoltages+0x110>
   141fc:	e51b3008 	ldr	r3, [fp, #-8]
   14200:	e5823010 	str	r3, [r2, #16]

   sSensorData.lTimeDelta = lMilliSeconds;
   14204:	e59f2028 	ldr	r2, [pc, #40]	; 14234 <updateCurrentVoltages+0x110>
   14208:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   1420c:	e5823008 	str	r3, [r2, #8]
   pthread_mutex_unlock(&data_lock);
   14210:	e59f0018 	ldr	r0, [pc, #24]	; 14230 <updateCurrentVoltages+0x10c>
   14214:	ebfff222 	bl	10aa4 <pthread_mutex_unlock@plt>

}
   14218:	e1a00000 	nop			; (mov r0, r0)
   1421c:	e24bd004 	sub	sp, fp, #4
   14220:	e8bd8800 	pop	{fp, pc}
   14224:	0002723c 	.word	0x0002723c
   14228:	3b9aca00 	.word	0x3b9aca00
   1422c:	000f4240 	.word	0x000f4240
   14230:	00027224 	.word	0x00027224
   14234:	00027294 	.word	0x00027294

00014238 <getSensorData>:
 * sSensorVoltageDataStruct getSensorData(void)
 * Global procedure to get the current state of sensor measurements in any time
 *
 * ----------------------------------------------------------------- */
sSensorVoltageDataStruct getSensorData(void)
{
   14238:	e92d4800 	push	{fp, lr}
   1423c:	e28db004 	add	fp, sp, #4
   14240:	e24dd008 	sub	sp, sp, #8
   14244:	e50b0008 	str	r0, [fp, #-8]
   return(sSensorData);
   14248:	e51b3008 	ldr	r3, [fp, #-8]
   1424c:	e59f2020 	ldr	r2, [pc, #32]	; 14274 <getSensorData+0x3c>
   14250:	e1a0c003 	mov	ip, r3
   14254:	e1a0e002 	mov	lr, r2
   14258:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
   1425c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
   14260:	e59e3000 	ldr	r3, [lr]
   14264:	e58c3000 	str	r3, [ip]
}
   14268:	e51b0008 	ldr	r0, [fp, #-8]
   1426c:	e24bd004 	sub	sp, fp, #4
   14270:	e8bd8800 	pop	{fp, pc}
   14274:	00027294 	.word	0x00027294

00014278 <convertCodeADC>:
/* -----------------------------------------------------------------
 * float_t convertCodeADC(uint32_t)
 * Procedure returns the float value according to input ADC Code
 * -----------------------------------------------------------------*/
float convertCodeADC(uint32_t ADCCode)
{
   14278:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1427c:	e28db000 	add	fp, sp, #0
   14280:	e24dd014 	sub	sp, sp, #20
   14284:	e50b0010 	str	r0, [fp, #-16]
   UDOUBLE WorkLocal = ADCCode;
   14288:	e51b3010 	ldr	r3, [fp, #-16]
   1428c:	e50b3008 	str	r3, [fp, #-8]

   float x = WorkLocal * kfUmax / 0x7fffff;
   14290:	e51b3008 	ldr	r3, [fp, #-8]
   14294:	ee073a90 	vmov	s15, r3
   14298:	eeb87b67 	vcvt.f64.u32	d7, s15
   1429c:	ed9f6b0b 	vldr	d6, [pc, #44]	; 142d0 <convertCodeADC+0x58>
   142a0:	ee276b06 	vmul.f64	d6, d7, d6
   142a4:	ed9f5b0b 	vldr	d5, [pc, #44]	; 142d8 <convertCodeADC+0x60>
   142a8:	ee867b05 	vdiv.f64	d7, d6, d5
   142ac:	eef77bc7 	vcvt.f32.f64	s15, d7
   142b0:	ed4b7a03 	vstr	s15, [fp, #-12]

   return(x);
   142b4:	e51b300c 	ldr	r3, [fp, #-12]
   142b8:	ee073a90 	vmov	s15, r3
}
   142bc:	eeb00a67 	vmov.f32	s0, s15
   142c0:	e28bd000 	add	sp, fp, #0
   142c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   142c8:	e12fff1e 	bx	lr
   142cc:	e1a00000 	nop			; (mov r0, r0)
   142d0:	00000000 	.word	0x00000000
   142d4:	40140000 	.word	0x40140000
   142d8:	c0000000 	.word	0xc0000000
   142dc:	415fffff 	.word	0x415fffff

000142e0 <getMicroVoltsADC>:
/* -----------------------------------------------------------------
 * uint32_t getMicroVoltsADC(uint32_t)
 * Procedure returns the float value according to input ADC Code
 * -----------------------------------------------------------------*/
uint32_t getMicroVoltsADC(uint32_t ADCCode)
{
   142e0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   142e4:	e28db000 	add	fp, sp, #0
   142e8:	e24dd014 	sub	sp, sp, #20
   142ec:	e50b0010 	str	r0, [fp, #-16]
   uint32_t WorkLocal = ADCCode;
   142f0:	e51b3010 	ldr	r3, [fp, #-16]
   142f4:	e50b3008 	str	r3, [fp, #-8]

   WorkLocal = (uint32_t)(((uint64_t)WorkLocal * (kfUmax * 1000000)) / 0x7fffff);
   142f8:	e51b3008 	ldr	r3, [fp, #-8]
   142fc:	ee073a90 	vmov	s15, r3
   14300:	eeb87b67 	vcvt.f64.u32	d7, s15
   14304:	ed9f6b0b 	vldr	d6, [pc, #44]	; 14338 <getMicroVoltsADC+0x58>
   14308:	ee276b06 	vmul.f64	d6, d7, d6
   1430c:	ed9f5b0b 	vldr	d5, [pc, #44]	; 14340 <getMicroVoltsADC+0x60>
   14310:	ee867b05 	vdiv.f64	d7, d6, d5
   14314:	eefc7bc7 	vcvt.u32.f64	s15, d7
   14318:	ee173a90 	vmov	r3, s15
   1431c:	e50b3008 	str	r3, [fp, #-8]

   return(WorkLocal);
   14320:	e51b3008 	ldr	r3, [fp, #-8]
}
   14324:	e1a00003 	mov	r0, r3
   14328:	e28bd000 	add	sp, fp, #0
   1432c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   14330:	e12fff1e 	bx	lr
   14334:	e1a00000 	nop			; (mov r0, r0)
   14338:	00000000 	.word	0x00000000
   1433c:	415312d0 	.word	0x415312d0
   14340:	c0000000 	.word	0xc0000000
   14344:	415fffff 	.word	0x415fffff

00014348 <ADS1256_reset>:
function:   Module reset
parameter:
Info:
******************************************************************************/
static void ADS1256_reset(void)
{
   14348:	e92d4800 	push	{fp, lr}
   1434c:	e28db004 	add	fp, sp, #4
    DEV_Digital_Write(DEV_RST_PIN, 1);
   14350:	e3a01001 	mov	r1, #1
   14354:	e3a00012 	mov	r0, #18
   14358:	ebfff441 	bl	11464 <bcm2835_gpio_write>
    DEV_Delay_ms(200);
   1435c:	e3a000c8 	mov	r0, #200	; 0xc8
   14360:	ebfff3db 	bl	112d4 <bcm2835_delay>
    DEV_Digital_Write(DEV_RST_PIN, 0);
   14364:	e3a01000 	mov	r1, #0
   14368:	e3a00012 	mov	r0, #18
   1436c:	ebfff43c 	bl	11464 <bcm2835_gpio_write>
    DEV_Delay_ms(200);
   14370:	e3a000c8 	mov	r0, #200	; 0xc8
   14374:	ebfff3d6 	bl	112d4 <bcm2835_delay>
    DEV_Digital_Write(DEV_RST_PIN, 1);
   14378:	e3a01001 	mov	r1, #1
   1437c:	e3a00012 	mov	r0, #18
   14380:	ebfff437 	bl	11464 <bcm2835_gpio_write>
}
   14384:	e1a00000 	nop			; (mov r0, r0)
   14388:	e8bd8800 	pop	{fp, pc}

0001438c <ADS1256_WriteCmd>:
parameter: 
        Cmd: command
Info:
******************************************************************************/
static void ADS1256_WriteCmd(UBYTE Cmd)
{
   1438c:	e92d4800 	push	{fp, lr}
   14390:	e28db004 	add	fp, sp, #4
   14394:	e24dd008 	sub	sp, sp, #8
   14398:	e1a03000 	mov	r3, r0
   1439c:	e54b3005 	strb	r3, [fp, #-5]
    DEV_Digital_Write(DEV_CS_PIN, 0);
   143a0:	e3a01000 	mov	r1, #0
   143a4:	e3a00016 	mov	r0, #22
   143a8:	ebfff42d 	bl	11464 <bcm2835_gpio_write>
    DEV_SPI_WriteByte(Cmd);
   143ac:	e55b3005 	ldrb	r3, [fp, #-5]
   143b0:	e1a00003 	mov	r0, r3
   143b4:	ebfff4bc 	bl	116ac <bcm2835_spi_transfer>
    DEV_Digital_Write(DEV_CS_PIN, 1);
   143b8:	e3a01001 	mov	r1, #1
   143bc:	e3a00016 	mov	r0, #22
   143c0:	ebfff427 	bl	11464 <bcm2835_gpio_write>
}
   143c4:	e1a00000 	nop			; (mov r0, r0)
   143c8:	e24bd004 	sub	sp, fp, #4
   143cc:	e8bd8800 	pop	{fp, pc}

000143d0 <ADS1256_WriteReg>:
        Reg : Target register
        data: Written data
Info:
******************************************************************************/
static void ADS1256_WriteReg(UBYTE Reg, UBYTE data)
{
   143d0:	e92d4800 	push	{fp, lr}
   143d4:	e28db004 	add	fp, sp, #4
   143d8:	e24dd008 	sub	sp, sp, #8
   143dc:	e1a03000 	mov	r3, r0
   143e0:	e1a02001 	mov	r2, r1
   143e4:	e54b3005 	strb	r3, [fp, #-5]
   143e8:	e1a03002 	mov	r3, r2
   143ec:	e54b3006 	strb	r3, [fp, #-6]
    DEV_Digital_Write(DEV_CS_PIN, 0);
   143f0:	e3a01000 	mov	r1, #0
   143f4:	e3a00016 	mov	r0, #22
   143f8:	ebfff419 	bl	11464 <bcm2835_gpio_write>
    DEV_SPI_WriteByte(CMD_WREG | Reg);
   143fc:	e55b3005 	ldrb	r3, [fp, #-5]
   14400:	e3833050 	orr	r3, r3, #80	; 0x50
   14404:	e6ef3073 	uxtb	r3, r3
   14408:	e1a00003 	mov	r0, r3
   1440c:	ebfff4a6 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(0x00);
   14410:	e3a00000 	mov	r0, #0
   14414:	ebfff4a4 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(data);
   14418:	e55b3006 	ldrb	r3, [fp, #-6]
   1441c:	e1a00003 	mov	r0, r3
   14420:	ebfff4a1 	bl	116ac <bcm2835_spi_transfer>
    DEV_Digital_Write(DEV_CS_PIN, 1);
   14424:	e3a01001 	mov	r1, #1
   14428:	e3a00016 	mov	r0, #22
   1442c:	ebfff40c 	bl	11464 <bcm2835_gpio_write>
}
   14430:	e1a00000 	nop			; (mov r0, r0)
   14434:	e24bd004 	sub	sp, fp, #4
   14438:	e8bd8800 	pop	{fp, pc}

0001443c <ADS1256_Read_data>:
        Reg : Target register
Info:
    Return the read data
******************************************************************************/
static UBYTE ADS1256_Read_data(UBYTE Reg)
{
   1443c:	e92d4800 	push	{fp, lr}
   14440:	e28db004 	add	fp, sp, #4
   14444:	e24dd010 	sub	sp, sp, #16
   14448:	e1a03000 	mov	r3, r0
   1444c:	e54b300d 	strb	r3, [fp, #-13]
    UBYTE temp = 0;
   14450:	e3a03000 	mov	r3, #0
   14454:	e54b3005 	strb	r3, [fp, #-5]
    DEV_Digital_Write(DEV_CS_PIN, 0);
   14458:	e3a01000 	mov	r1, #0
   1445c:	e3a00016 	mov	r0, #22
   14460:	ebfff3ff 	bl	11464 <bcm2835_gpio_write>
    DEV_SPI_WriteByte(CMD_RREG | Reg);
   14464:	e55b300d 	ldrb	r3, [fp, #-13]
   14468:	e3833010 	orr	r3, r3, #16
   1446c:	e6ef3073 	uxtb	r3, r3
   14470:	e1a00003 	mov	r0, r3
   14474:	ebfff48c 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(0x00);
   14478:	e3a00000 	mov	r0, #0
   1447c:	ebfff48a 	bl	116ac <bcm2835_spi_transfer>
    DEV_Delay_ms(1);
   14480:	e3a00001 	mov	r0, #1
   14484:	ebfff392 	bl	112d4 <bcm2835_delay>
    temp = DEV_SPI_ReadByte();
   14488:	e3a000ff 	mov	r0, #255	; 0xff
   1448c:	ebfff486 	bl	116ac <bcm2835_spi_transfer>
   14490:	e1a03000 	mov	r3, r0
   14494:	e54b3005 	strb	r3, [fp, #-5]
    DEV_Digital_Write(DEV_CS_PIN, 1);
   14498:	e3a01001 	mov	r1, #1
   1449c:	e3a00016 	mov	r0, #22
   144a0:	ebfff3ef 	bl	11464 <bcm2835_gpio_write>
    return temp;
   144a4:	e55b3005 	ldrb	r3, [fp, #-5]
}
   144a8:	e1a00003 	mov	r0, r3
   144ac:	e24bd004 	sub	sp, fp, #4
   144b0:	e8bd8800 	pop	{fp, pc}

000144b4 <ADS1256_WaitDRDY>:
parameter: 
Info:
    Timeout indicates that the operation is not working properly.
******************************************************************************/
static void ADS1256_WaitDRDY(void)
{   
   144b4:	e92d4800 	push	{fp, lr}
   144b8:	e28db004 	add	fp, sp, #4
   144bc:	e24dd008 	sub	sp, sp, #8
    UDOUBLE i = 0;
   144c0:	e3a03000 	mov	r3, #0
   144c4:	e50b3008 	str	r3, [fp, #-8]
    for(i=0;i<400000000;i++){
   144c8:	e3a03000 	mov	r3, #0
   144cc:	e50b3008 	str	r3, [fp, #-8]
   144d0:	ea000007 	b	144f4 <ADS1256_WaitDRDY+0x40>
        if(DEV_Digital_Read(DEV_DRDY_PIN) == 0)
   144d4:	e3a00011 	mov	r0, #17
   144d8:	ebfff35b 	bl	1124c <bcm2835_gpio_lev>
   144dc:	e1a03000 	mov	r3, r0
   144e0:	e3530000 	cmp	r3, #0
   144e4:	0a000007 	beq	14508 <ADS1256_WaitDRDY+0x54>
    for(i=0;i<400000000;i++){
   144e8:	e51b3008 	ldr	r3, [fp, #-8]
   144ec:	e2833001 	add	r3, r3, #1
   144f0:	e50b3008 	str	r3, [fp, #-8]
   144f4:	e51b3008 	ldr	r3, [fp, #-8]
   144f8:	e59f2030 	ldr	r2, [pc, #48]	; 14530 <ADS1256_WaitDRDY+0x7c>
   144fc:	e1530002 	cmp	r3, r2
   14500:	9afffff3 	bls	144d4 <ADS1256_WaitDRDY+0x20>
   14504:	ea000000 	b	1450c <ADS1256_WaitDRDY+0x58>
            break;
   14508:	e1a00000 	nop			; (mov r0, r0)
    }
    if(i >= 400000000){
   1450c:	e51b3008 	ldr	r3, [fp, #-8]
   14510:	e59f2018 	ldr	r2, [pc, #24]	; 14530 <ADS1256_WaitDRDY+0x7c>
   14514:	e1530002 	cmp	r3, r2
   14518:	9a000001 	bls	14524 <ADS1256_WaitDRDY+0x70>
       printf("Time Out ...\r\n"); 
   1451c:	e59f0010 	ldr	r0, [pc, #16]	; 14534 <ADS1256_WaitDRDY+0x80>
   14520:	ebfff108 	bl	10948 <puts@plt>
    }
}
   14524:	e1a00000 	nop			; (mov r0, r0)
   14528:	e24bd004 	sub	sp, fp, #4
   1452c:	e8bd8800 	pop	{fp, pc}
   14530:	17d783ff 	.word	0x17d783ff
   14534:	00016368 	.word	0x00016368

00014538 <ADS1256_ReadChipID>:
function:  Read device ID
parameter: 
Info:
******************************************************************************/
UBYTE ADS1256_ReadChipID(void)
{
   14538:	e92d4800 	push	{fp, lr}
   1453c:	e28db004 	add	fp, sp, #4
   14540:	e24dd008 	sub	sp, sp, #8
    UBYTE id;
    ADS1256_WaitDRDY();
   14544:	ebffffda 	bl	144b4 <ADS1256_WaitDRDY>
    id = ADS1256_Read_data(REG_STATUS);
   14548:	e3a00000 	mov	r0, #0
   1454c:	ebffffba 	bl	1443c <ADS1256_Read_data>
   14550:	e1a03000 	mov	r3, r0
   14554:	e54b3005 	strb	r3, [fp, #-5]
    return id>>4;
   14558:	e55b3005 	ldrb	r3, [fp, #-5]
   1455c:	e1a03223 	lsr	r3, r3, #4
   14560:	e6ef3073 	uxtb	r3, r3
}
   14564:	e1a00003 	mov	r0, r3
   14568:	e24bd004 	sub	sp, fp, #4
   1456c:	e8bd8800 	pop	{fp, pc}

00014570 <ADS1256_ConfigADC>:
    gain : Enumeration type gain
    drate: Enumeration type sampling speed
Info:
******************************************************************************/
void ADS1256_ConfigADC(ADS1256_GAIN gain, ADS1256_DRATE drate)
{
   14570:	e92d4800 	push	{fp, lr}
   14574:	e28db004 	add	fp, sp, #4
   14578:	e24dd010 	sub	sp, sp, #16
   1457c:	e50b0010 	str	r0, [fp, #-16]
   14580:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    ADS1256_WaitDRDY();
   14584:	ebffffca 	bl	144b4 <ADS1256_WaitDRDY>
    UBYTE buf[4] = {0,0,0,0};
   14588:	e3a03000 	mov	r3, #0
   1458c:	e50b3008 	str	r3, [fp, #-8]
    buf[0] = (0<<3) | (1<<2) | (0<<1);
   14590:	e3a03004 	mov	r3, #4
   14594:	e54b3008 	strb	r3, [fp, #-8]
    buf[1] = 0x08;
   14598:	e3a03008 	mov	r3, #8
   1459c:	e54b3007 	strb	r3, [fp, #-7]
    buf[2] = (0<<5) | (0<<3) | (gain<<0);
   145a0:	e51b3010 	ldr	r3, [fp, #-16]
   145a4:	e6ef3073 	uxtb	r3, r3
   145a8:	e54b3006 	strb	r3, [fp, #-6]
    buf[3] = ADS1256_DRATE_E[drate];
   145ac:	e59f2078 	ldr	r2, [pc, #120]	; 1462c <ADS1256_ConfigADC+0xbc>
   145b0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   145b4:	e0823003 	add	r3, r2, r3
   145b8:	e5d33000 	ldrb	r3, [r3]
   145bc:	e54b3005 	strb	r3, [fp, #-5]
    DEV_Digital_Write(DEV_CS_PIN, 0);
   145c0:	e3a01000 	mov	r1, #0
   145c4:	e3a00016 	mov	r0, #22
   145c8:	ebfff3a5 	bl	11464 <bcm2835_gpio_write>
    DEV_SPI_WriteByte(CMD_WREG | 0);
   145cc:	e3a00050 	mov	r0, #80	; 0x50
   145d0:	ebfff435 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(0x03);
   145d4:	e3a00003 	mov	r0, #3
   145d8:	ebfff433 	bl	116ac <bcm2835_spi_transfer>
    
    DEV_SPI_WriteByte(buf[0]);
   145dc:	e55b3008 	ldrb	r3, [fp, #-8]
   145e0:	e1a00003 	mov	r0, r3
   145e4:	ebfff430 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(buf[1]);
   145e8:	e55b3007 	ldrb	r3, [fp, #-7]
   145ec:	e1a00003 	mov	r0, r3
   145f0:	ebfff42d 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(buf[2]);
   145f4:	e55b3006 	ldrb	r3, [fp, #-6]
   145f8:	e1a00003 	mov	r0, r3
   145fc:	ebfff42a 	bl	116ac <bcm2835_spi_transfer>
    DEV_SPI_WriteByte(buf[3]);
   14600:	e55b3005 	ldrb	r3, [fp, #-5]
   14604:	e1a00003 	mov	r0, r3
   14608:	ebfff427 	bl	116ac <bcm2835_spi_transfer>
    DEV_Digital_Write(DEV_CS_PIN, 1);
   1460c:	e3a01001 	mov	r1, #1
   14610:	e3a00016 	mov	r0, #22
   14614:	ebfff392 	bl	11464 <bcm2835_gpio_write>
    DEV_Delay_ms(1);
   14618:	e3a00001 	mov	r0, #1
   1461c:	ebfff32c 	bl	112d4 <bcm2835_delay>
}
   14620:	e1a00000 	nop			; (mov r0, r0)
   14624:	e24bd004 	sub	sp, fp, #4
   14628:	e8bd8800 	pop	{fp, pc}
   1462c:	00016358 	.word	0x00016358

00014630 <ADS1256_SetChannal>:
parameter: 
    Channal : Set channel number
Info:
******************************************************************************/
static void ADS1256_SetChannal(UBYTE Channal)
{
   14630:	e92d4800 	push	{fp, lr}
   14634:	e28db004 	add	fp, sp, #4
   14638:	e24dd008 	sub	sp, sp, #8
   1463c:	e1a03000 	mov	r3, r0
   14640:	e54b3005 	strb	r3, [fp, #-5]
    if(Channal > 7){
   14644:	e55b3005 	ldrb	r3, [fp, #-5]
   14648:	e3530007 	cmp	r3, #7
   1464c:	8a000009 	bhi	14678 <ADS1256_SetChannal+0x48>
        return ;
    }
    ADS1256_WriteReg(REG_MUX, (Channal<<4) | (1<<3));
   14650:	e55b3005 	ldrb	r3, [fp, #-5]
   14654:	e1a03203 	lsl	r3, r3, #4
   14658:	e6af3073 	sxtb	r3, r3
   1465c:	e3833008 	orr	r3, r3, #8
   14660:	e6af3073 	sxtb	r3, r3
   14664:	e6ef3073 	uxtb	r3, r3
   14668:	e1a01003 	mov	r1, r3
   1466c:	e3a00001 	mov	r0, #1
   14670:	ebffff56 	bl	143d0 <ADS1256_WriteReg>
   14674:	ea000000 	b	1467c <ADS1256_SetChannal+0x4c>
        return ;
   14678:	e1a00000 	nop			; (mov r0, r0)
} 
   1467c:	e24bd004 	sub	sp, fp, #4
   14680:	e8bd8800 	pop	{fp, pc}

00014684 <ADS1256_SetDiffChannal>:

void ADS1256_SetDiffChannal(UBYTE Channal)
{
   14684:	e92d4800 	push	{fp, lr}
   14688:	e28db004 	add	fp, sp, #4
   1468c:	e24dd008 	sub	sp, sp, #8
   14690:	e1a03000 	mov	r3, r0
   14694:	e54b3005 	strb	r3, [fp, #-5]
    if (Channal == 0){
   14698:	e55b3005 	ldrb	r3, [fp, #-5]
   1469c:	e3530000 	cmp	r3, #0
   146a0:	1a000003 	bne	146b4 <ADS1256_SetDiffChannal+0x30>
        ADS1256_WriteReg(REG_MUX, (0 << 4) | 1);	//DiffChannal  AIN0-AIN1
   146a4:	e3a01001 	mov	r1, #1
   146a8:	e3a00001 	mov	r0, #1
   146ac:	ebffff47 	bl	143d0 <ADS1256_WriteReg>
        ADS1256_WriteReg(REG_MUX, (4 << 4) | 5); 	//DiffChannal    AIN4-AIN5
    }
    else if(Channal == 3){
        ADS1256_WriteReg(REG_MUX, (6 << 4) | 7); 	//DiffChannal   AIN6-AIN7
    }
}
   146b0:	ea000013 	b	14704 <ADS1256_SetDiffChannal+0x80>
    else if(Channal == 1){
   146b4:	e55b3005 	ldrb	r3, [fp, #-5]
   146b8:	e3530001 	cmp	r3, #1
   146bc:	1a000003 	bne	146d0 <ADS1256_SetDiffChannal+0x4c>
        ADS1256_WriteReg(REG_MUX, (2 << 4) | 3);	//DiffChannal   AIN2-AIN3
   146c0:	e3a01023 	mov	r1, #35	; 0x23
   146c4:	e3a00001 	mov	r0, #1
   146c8:	ebffff40 	bl	143d0 <ADS1256_WriteReg>
}
   146cc:	ea00000c 	b	14704 <ADS1256_SetDiffChannal+0x80>
    else if(Channal == 2){
   146d0:	e55b3005 	ldrb	r3, [fp, #-5]
   146d4:	e3530002 	cmp	r3, #2
   146d8:	1a000003 	bne	146ec <ADS1256_SetDiffChannal+0x68>
        ADS1256_WriteReg(REG_MUX, (4 << 4) | 5); 	//DiffChannal    AIN4-AIN5
   146dc:	e3a01045 	mov	r1, #69	; 0x45
   146e0:	e3a00001 	mov	r0, #1
   146e4:	ebffff39 	bl	143d0 <ADS1256_WriteReg>
}
   146e8:	ea000005 	b	14704 <ADS1256_SetDiffChannal+0x80>
    else if(Channal == 3){
   146ec:	e55b3005 	ldrb	r3, [fp, #-5]
   146f0:	e3530003 	cmp	r3, #3
   146f4:	1a000002 	bne	14704 <ADS1256_SetDiffChannal+0x80>
        ADS1256_WriteReg(REG_MUX, (6 << 4) | 7); 	//DiffChannal   AIN6-AIN7
   146f8:	e3a01067 	mov	r1, #103	; 0x67
   146fc:	e3a00001 	mov	r0, #1
   14700:	ebffff32 	bl	143d0 <ADS1256_WriteReg>
}
   14704:	e1a00000 	nop			; (mov r0, r0)
   14708:	e24bd004 	sub	sp, fp, #4
   1470c:	e8bd8800 	pop	{fp, pc}

00014710 <ADS1256_SetMode>:
    Mode : 0 Single-ended input
           1 channel1 Differential input
Info:
******************************************************************************/
void ADS1256_SetMode(UBYTE Mode)
{
   14710:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   14714:	e28db000 	add	fp, sp, #0
   14718:	e24dd00c 	sub	sp, sp, #12
   1471c:	e1a03000 	mov	r3, r0
   14720:	e54b3005 	strb	r3, [fp, #-5]
    if(Mode == 0){
   14724:	e55b3005 	ldrb	r3, [fp, #-5]
   14728:	e3530000 	cmp	r3, #0
   1472c:	1a000003 	bne	14740 <ADS1256_SetMode+0x30>
        ScanMode = 0;
   14730:	e59f3024 	ldr	r3, [pc, #36]	; 1475c <ADS1256_SetMode+0x4c>
   14734:	e3a02000 	mov	r2, #0
   14738:	e5c32000 	strb	r2, [r3]
    }
    else{ 
        ScanMode = 1;
    }
}
   1473c:	ea000002 	b	1474c <ADS1256_SetMode+0x3c>
        ScanMode = 1;
   14740:	e59f3014 	ldr	r3, [pc, #20]	; 1475c <ADS1256_SetMode+0x4c>
   14744:	e3a02001 	mov	r2, #1
   14748:	e5c32000 	strb	r2, [r3]
}
   1474c:	e1a00000 	nop			; (mov r0, r0)
   14750:	e28bd000 	add	sp, fp, #0
   14754:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   14758:	e12fff1e 	bx	lr
   1475c:	00027244 	.word	0x00027244

00014760 <ADS1256_init>:
function:  Device initialization
parameter: 
Info:
******************************************************************************/
UBYTE ADS1256_init(void)
{
   14760:	e92d4800 	push	{fp, lr}
   14764:	e28db004 	add	fp, sp, #4
   14768:	e24dd008 	sub	sp, sp, #8
    ADS1256_reset();
   1476c:	ebfffef5 	bl	14348 <ADS1256_reset>
    int outError = ADS1256_ReadChipID();
   14770:	ebffff70 	bl	14538 <ADS1256_ReadChipID>
   14774:	e1a03000 	mov	r3, r0
   14778:	e50b3008 	str	r3, [fp, #-8]
    if(outError == 3)
   1477c:	e51b3008 	ldr	r3, [fp, #-8]
   14780:	e3530003 	cmp	r3, #3
   14784:	0a000004 	beq	1479c <ADS1256_init+0x3c>
    {
   //     printf("ID Read success \r\n");
    }
    else
    {
        printf("ID Read failed. Error: %u \r\n", outError);
   14788:	e51b1008 	ldr	r1, [fp, #-8]
   1478c:	e59f002c 	ldr	r0, [pc, #44]	; 147c0 <ADS1256_init+0x60>
   14790:	ebfff066 	bl	10930 <printf@plt>
        return 1;
   14794:	e3a03001 	mov	r3, #1
   14798:	ea000005 	b	147b4 <ADS1256_init+0x54>
    }
    ADS1256_ConfigADC(ADS1256_GAIN_1, ADS1256_2d5SPS);
   1479c:	e3a0100f 	mov	r1, #15
   147a0:	e3a00000 	mov	r0, #0
   147a4:	ebffff71 	bl	14570 <ADS1256_ConfigADC>
    
    // Differential input
    ADS1256_SetMode(1);
   147a8:	e3a00001 	mov	r0, #1
   147ac:	ebffffd7 	bl	14710 <ADS1256_SetMode>

    return 0;
   147b0:	e3a03000 	mov	r3, #0
}
   147b4:	e1a00003 	mov	r0, r3
   147b8:	e24bd004 	sub	sp, fp, #4
   147bc:	e8bd8800 	pop	{fp, pc}
   147c0:	00016378 	.word	0x00016378

000147c4 <ADS1256_Read_ADC_Data>:
function:  Read ADC data
parameter: 
Info:
******************************************************************************/
static UDOUBLE ADS1256_Read_ADC_Data(void)
{
   147c4:	e92d4800 	push	{fp, lr}
   147c8:	e28db004 	add	fp, sp, #4
   147cc:	e24dd008 	sub	sp, sp, #8
    UDOUBLE read = 0;
   147d0:	e3a03000 	mov	r3, #0
   147d4:	e50b3008 	str	r3, [fp, #-8]
    UBYTE buf[3] = {0,0,0};
   147d8:	e3a03000 	mov	r3, #0
   147dc:	e54b300c 	strb	r3, [fp, #-12]
   147e0:	e3a03000 	mov	r3, #0
   147e4:	e54b300b 	strb	r3, [fp, #-11]
   147e8:	e3a03000 	mov	r3, #0
   147ec:	e54b300a 	strb	r3, [fp, #-10]
    
    ADS1256_WaitDRDY();
   147f0:	ebffff2f 	bl	144b4 <ADS1256_WaitDRDY>
    DEV_Delay_ms(1);
   147f4:	e3a00001 	mov	r0, #1
   147f8:	ebfff2b5 	bl	112d4 <bcm2835_delay>
    DEV_Digital_Write(DEV_CS_PIN, 0);
   147fc:	e3a01000 	mov	r1, #0
   14800:	e3a00016 	mov	r0, #22
   14804:	ebfff316 	bl	11464 <bcm2835_gpio_write>
    DEV_SPI_WriteByte(CMD_RDATA);
   14808:	e3a00001 	mov	r0, #1
   1480c:	ebfff3a6 	bl	116ac <bcm2835_spi_transfer>
    DEV_Delay_ms(1);
   14810:	e3a00001 	mov	r0, #1
   14814:	ebfff2ae 	bl	112d4 <bcm2835_delay>
    buf[0] = DEV_SPI_ReadByte();
   14818:	e3a000ff 	mov	r0, #255	; 0xff
   1481c:	ebfff3a2 	bl	116ac <bcm2835_spi_transfer>
   14820:	e1a03000 	mov	r3, r0
   14824:	e54b300c 	strb	r3, [fp, #-12]
    buf[1] = DEV_SPI_ReadByte();
   14828:	e3a000ff 	mov	r0, #255	; 0xff
   1482c:	ebfff39e 	bl	116ac <bcm2835_spi_transfer>
   14830:	e1a03000 	mov	r3, r0
   14834:	e54b300b 	strb	r3, [fp, #-11]
    buf[2] = DEV_SPI_ReadByte();
   14838:	e3a000ff 	mov	r0, #255	; 0xff
   1483c:	ebfff39a 	bl	116ac <bcm2835_spi_transfer>
   14840:	e1a03000 	mov	r3, r0
   14844:	e54b300a 	strb	r3, [fp, #-10]
    DEV_Digital_Write(DEV_CS_PIN, 1);
   14848:	e3a01001 	mov	r1, #1
   1484c:	e3a00016 	mov	r0, #22
   14850:	ebfff303 	bl	11464 <bcm2835_gpio_write>
    read = ((UDOUBLE)buf[0] << 16) & 0x00FF0000;
   14854:	e55b300c 	ldrb	r3, [fp, #-12]
   14858:	e1a03803 	lsl	r3, r3, #16
   1485c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
   14860:	e50b3008 	str	r3, [fp, #-8]
    read |= ((UDOUBLE)buf[1] << 8);  /* Pay attention to It is wrong   read |= (buf[1] << 8) */
   14864:	e55b300b 	ldrb	r3, [fp, #-11]
   14868:	e1a03403 	lsl	r3, r3, #8
   1486c:	e51b2008 	ldr	r2, [fp, #-8]
   14870:	e1823003 	orr	r3, r2, r3
   14874:	e50b3008 	str	r3, [fp, #-8]
    read |= buf[2];
   14878:	e55b300a 	ldrb	r3, [fp, #-10]
   1487c:	e1a02003 	mov	r2, r3
   14880:	e51b3008 	ldr	r3, [fp, #-8]
   14884:	e1833002 	orr	r3, r3, r2
   14888:	e50b3008 	str	r3, [fp, #-8]
    if (read & 0x800000)
   1488c:	e51b3008 	ldr	r3, [fp, #-8]
   14890:	e2033502 	and	r3, r3, #8388608	; 0x800000
   14894:	e3530000 	cmp	r3, #0
   14898:	0a000002 	beq	148a8 <ADS1256_Read_ADC_Data+0xe4>
        read |= 0xFF000000;
   1489c:	e51b3008 	ldr	r3, [fp, #-8]
   148a0:	e38334ff 	orr	r3, r3, #-16777216	; 0xff000000
   148a4:	e50b3008 	str	r3, [fp, #-8]

    return read;
   148a8:	e51b3008 	ldr	r3, [fp, #-8]
}
   148ac:	e1a00003 	mov	r0, r3
   148b0:	e24bd004 	sub	sp, fp, #4
   148b4:	e8bd8800 	pop	{fp, pc}

000148b8 <ADS1256_GetChannalValue>:
parameter: 
    Channel: Channel number
Info:
******************************************************************************/
UDOUBLE ADS1256_GetChannalValue(UBYTE Channel)
{
   148b8:	e92d4800 	push	{fp, lr}
   148bc:	e28db004 	add	fp, sp, #4
   148c0:	e24dd010 	sub	sp, sp, #16
   148c4:	e1a03000 	mov	r3, r0
   148c8:	e54b300d 	strb	r3, [fp, #-13]
    UDOUBLE Value = 0;
   148cc:	e3a03000 	mov	r3, #0
   148d0:	e50b3008 	str	r3, [fp, #-8]
    while(DEV_Digital_Read(DEV_DRDY_PIN) == 1);
   148d4:	e1a00000 	nop			; (mov r0, r0)
   148d8:	e3a00011 	mov	r0, #17
   148dc:	ebfff25a 	bl	1124c <bcm2835_gpio_lev>
   148e0:	e1a03000 	mov	r3, r0
   148e4:	e3530001 	cmp	r3, #1
   148e8:	0afffffa 	beq	148d8 <ADS1256_GetChannalValue+0x20>
    if(ScanMode == 0){// 0  Single-ended input  8 channel1 Differential input  4 channe 
   148ec:	e59f308c 	ldr	r3, [pc, #140]	; 14980 <ADS1256_GetChannalValue+0xc8>
   148f0:	e5d33000 	ldrb	r3, [r3]
   148f4:	e3530000 	cmp	r3, #0
   148f8:	1a00000e 	bne	14938 <ADS1256_GetChannalValue+0x80>
        if(Channel>=8){
   148fc:	e55b300d 	ldrb	r3, [fp, #-13]
   14900:	e3530007 	cmp	r3, #7
   14904:	9a000001 	bls	14910 <ADS1256_GetChannalValue+0x58>
            return 0;
   14908:	e3a03000 	mov	r3, #0
   1490c:	ea000018 	b	14974 <ADS1256_GetChannalValue+0xbc>
        }
        ADS1256_SetChannal(Channel);
   14910:	e55b300d 	ldrb	r3, [fp, #-13]
   14914:	e1a00003 	mov	r0, r3
   14918:	ebffff44 	bl	14630 <ADS1256_SetChannal>
        ADS1256_WriteCmd(CMD_SYNC);
   1491c:	e3a000fc 	mov	r0, #252	; 0xfc
   14920:	ebfffe99 	bl	1438c <ADS1256_WriteCmd>
        ADS1256_WriteCmd(CMD_WAKEUP);
   14924:	e3a00000 	mov	r0, #0
   14928:	ebfffe97 	bl	1438c <ADS1256_WriteCmd>
        Value = ADS1256_Read_ADC_Data();
   1492c:	ebffffa4 	bl	147c4 <ADS1256_Read_ADC_Data>
   14930:	e50b0008 	str	r0, [fp, #-8]
   14934:	ea00000d 	b	14970 <ADS1256_GetChannalValue+0xb8>
    }
    else{
        if(Channel>=4){
   14938:	e55b300d 	ldrb	r3, [fp, #-13]
   1493c:	e3530003 	cmp	r3, #3
   14940:	9a000001 	bls	1494c <ADS1256_GetChannalValue+0x94>
            return 0;
   14944:	e3a03000 	mov	r3, #0
   14948:	ea000009 	b	14974 <ADS1256_GetChannalValue+0xbc>
        }
        ADS1256_SetDiffChannal(Channel);
   1494c:	e55b300d 	ldrb	r3, [fp, #-13]
   14950:	e1a00003 	mov	r0, r3
   14954:	ebffff4a 	bl	14684 <ADS1256_SetDiffChannal>
        ADS1256_WriteCmd(CMD_SYNC);
   14958:	e3a000fc 	mov	r0, #252	; 0xfc
   1495c:	ebfffe8a 	bl	1438c <ADS1256_WriteCmd>
        ADS1256_WriteCmd(CMD_WAKEUP);
   14960:	e3a00000 	mov	r0, #0
   14964:	ebfffe88 	bl	1438c <ADS1256_WriteCmd>
        Value = ADS1256_Read_ADC_Data();
   14968:	ebffff95 	bl	147c4 <ADS1256_Read_ADC_Data>
   1496c:	e50b0008 	str	r0, [fp, #-8]
    }
    return Value;
   14970:	e51b3008 	ldr	r3, [fp, #-8]
}
   14974:	e1a00003 	mov	r0, r3
   14978:	e24bd004 	sub	sp, fp, #4
   1497c:	e8bd8800 	pop	{fp, pc}
   14980:	00027244 	.word	0x00027244

00014984 <TableLineInterpolation>:
   Calculations are realized by means of tables T(U) inputed as iX and number of temperature point.
   Correctly works when sensor table has constant temperature step.
   Call from TemperatureCalc
   ------------------------------------------------------------------------------- */
uint16_t TableLineInterpolation(float fXX, uint16_t* piPointNumber, uint16_t* piX_Points, uint16_t* piY_Points)
{
   14984:	e92d4800 	push	{fp, lr}
   14988:	e28db004 	add	fp, sp, #4
   1498c:	e24dd020 	sub	sp, sp, #32
   14990:	ed0b0a06 	vstr	s0, [fp, #-24]	; 0xffffffe8
   14994:	e50b001c 	str	r0, [fp, #-28]	; 0xffffffe4
   14998:	e50b1020 	str	r1, [fp, #-32]	; 0xffffffe0
   1499c:	e50b2024 	str	r2, [fp, #-36]	; 0xffffffdc
   uint32_t lXX;

   #define mGetLongVoltage(px, shift) (uint32_t)((*(px + shift))*100)

   // Get Micro volts in integer
   lXX = fXX * 1000000;
   149a0:	ed5b7a06 	vldr	s15, [fp, #-24]	; 0xffffffe8
   149a4:	ed9f7ae6 	vldr	s14, [pc, #920]	; 14d44 <TableLineInterpolation+0x3c0>
   149a8:	ee677a87 	vmul.f32	s15, s15, s14
   149ac:	eefc7ae7 	vcvt.u32.f32	s15, s15
   149b0:	ee173a90 	vmov	r3, s15
   149b4:	e50b3010 	str	r3, [fp, #-16]

#ifdef debugmode
//   lXX = 1016711;
#endif

   iIndex = 0;
   149b8:	e3a03000 	mov	r3, #0
   149bc:	e14b30ba 	strh	r3, [fp, #-10]
   iFirstPoint = *piY_Points;
   149c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   149c4:	e1d330b0 	ldrh	r3, [r3]
   149c8:	e14b31b2 	strh	r3, [fp, #-18]	; 0xffffffee
   iYStep = *(piY_Points + 1) - *piY_Points;
   149cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   149d0:	e2833002 	add	r3, r3, #2
   149d4:	e1d320b0 	ldrh	r2, [r3]
   149d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   149dc:	e1d330b0 	ldrh	r3, [r3]
   149e0:	e0423003 	sub	r3, r2, r3
   149e4:	e14b31b4 	strh	r3, [fp, #-20]	; 0xffffffec

   if ((piPointNumber   == NULL)
   149e8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   149ec:	e3530000 	cmp	r3, #0
   149f0:	0a000013 	beq	14a44 <TableLineInterpolation+0xc0>
         || (piX_Points == NULL)
   149f4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
   149f8:	e3530000 	cmp	r3, #0
   149fc:	0a000010 	beq	14a44 <TableLineInterpolation+0xc0>
         || (piY_Points == NULL)
   14a00:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   14a04:	e3530000 	cmp	r3, #0
   14a08:	0a00000d 	beq	14a44 <TableLineInterpolation+0xc0>
         || (piY_Points == NULL)
   14a0c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   14a10:	e3530000 	cmp	r3, #0
   14a14:	0a00000a 	beq	14a44 <TableLineInterpolation+0xc0>
         || (*piPointNumber == 0)
   14a18:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   14a1c:	e1d330b0 	ldrh	r3, [r3]
   14a20:	e3530000 	cmp	r3, #0
   14a24:	0a000006 	beq	14a44 <TableLineInterpolation+0xc0>
         || (*piY_Points >= *(piY_Points + 1))
   14a28:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   14a2c:	e1d320b0 	ldrh	r2, [r3]
   14a30:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   14a34:	e2833002 	add	r3, r3, #2
   14a38:	e1d330b0 	ldrh	r3, [r3]
   14a3c:	e1520003 	cmp	r2, r3
   14a40:	3a000001 	bcc	14a4c <TableLineInterpolation+0xc8>
         )
   {
      // Error
      return(0);
   14a44:	e3a03000 	mov	r3, #0
   14a48:	ea0000ba 	b	14d38 <TableLineInterpolation+0x3b4>
   }
   else
   {
      if (lXX > (mGetLongVoltage(piX_Points, iIndex)))
   14a4c:	e15b30ba 	ldrh	r3, [fp, #-10]
   14a50:	e1a03083 	lsl	r3, r3, #1
   14a54:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14a58:	e0823003 	add	r3, r2, r3
   14a5c:	e1d330b0 	ldrh	r3, [r3]
   14a60:	e1a02003 	mov	r2, r3
   14a64:	e1a03002 	mov	r3, r2
   14a68:	e1a03103 	lsl	r3, r3, #2
   14a6c:	e0833002 	add	r3, r3, r2
   14a70:	e1a02103 	lsl	r2, r3, #2
   14a74:	e0833002 	add	r3, r3, r2
   14a78:	e1a03103 	lsl	r3, r3, #2
   14a7c:	e1a02003 	mov	r2, r3
   14a80:	e51b3010 	ldr	r3, [fp, #-16]
   14a84:	e1530002 	cmp	r3, r2
   14a88:	9a000002 	bls	14a98 <TableLineInterpolation+0x114>
      {
         // Out first temperature point
         return(*piY_Points);
   14a8c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   14a90:	e1d330b0 	ldrh	r3, [r3]
   14a94:	ea0000a7 	b	14d38 <TableLineInterpolation+0x3b4>
      }
      else
      {
         if (lXX < (mGetLongVoltage(piX_Points, (*piPointNumber - 1))))
   14a98:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   14a9c:	e1d330b0 	ldrh	r3, [r3]
   14aa0:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
   14aa4:	e1a03083 	lsl	r3, r3, #1
   14aa8:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14aac:	e0823003 	add	r3, r2, r3
   14ab0:	e1d330b0 	ldrh	r3, [r3]
   14ab4:	e1a02003 	mov	r2, r3
   14ab8:	e1a03002 	mov	r3, r2
   14abc:	e1a03103 	lsl	r3, r3, #2
   14ac0:	e0833002 	add	r3, r3, r2
   14ac4:	e1a02103 	lsl	r2, r3, #2
   14ac8:	e0833002 	add	r3, r3, r2
   14acc:	e1a03103 	lsl	r3, r3, #2
   14ad0:	e1a02003 	mov	r2, r3
   14ad4:	e51b3010 	ldr	r3, [fp, #-16]
   14ad8:	e1530002 	cmp	r3, r2
   14adc:	2a00000a 	bcs	14b0c <TableLineInterpolation+0x188>
         {
            // Out last temperature point

            return(*(piY_Points + *piPointNumber - 1));
   14ae0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   14ae4:	e1d330b0 	ldrh	r3, [r3]
   14ae8:	e2433106 	sub	r3, r3, #-2147483647	; 0x80000001
   14aec:	e1a03083 	lsl	r3, r3, #1
   14af0:	e51b2024 	ldr	r2, [fp, #-36]	; 0xffffffdc
   14af4:	e0823003 	add	r3, r2, r3
   14af8:	e1d330b0 	ldrh	r3, [r3]
   14afc:	ea00008d 	b	14d38 <TableLineInterpolation+0x3b4>
   }


   while ((lXX < (mGetLongVoltage(piX_Points, iIndex))) && (iIndex <= (*piPointNumber - 1)))
   {
      iIndex++;
   14b00:	e15b30ba 	ldrh	r3, [fp, #-10]
   14b04:	e2833001 	add	r3, r3, #1
   14b08:	e14b30ba 	strh	r3, [fp, #-10]
   while ((lXX < (mGetLongVoltage(piX_Points, iIndex))) && (iIndex <= (*piPointNumber - 1)))
   14b0c:	e15b30ba 	ldrh	r3, [fp, #-10]
   14b10:	e1a03083 	lsl	r3, r3, #1
   14b14:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14b18:	e0823003 	add	r3, r2, r3
   14b1c:	e1d330b0 	ldrh	r3, [r3]
   14b20:	e1a02003 	mov	r2, r3
   14b24:	e1a03002 	mov	r3, r2
   14b28:	e1a03103 	lsl	r3, r3, #2
   14b2c:	e0833002 	add	r3, r3, r2
   14b30:	e1a02103 	lsl	r2, r3, #2
   14b34:	e0833002 	add	r3, r3, r2
   14b38:	e1a03103 	lsl	r3, r3, #2
   14b3c:	e1a02003 	mov	r2, r3
   14b40:	e51b3010 	ldr	r3, [fp, #-16]
   14b44:	e1530002 	cmp	r3, r2
   14b48:	2a000004 	bcs	14b60 <TableLineInterpolation+0x1dc>
   14b4c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   14b50:	e1d330b0 	ldrh	r3, [r3]
   14b54:	e15b20ba 	ldrh	r2, [fp, #-10]
   14b58:	e1520003 	cmp	r2, r3
   14b5c:	3affffe7 	bcc	14b00 <TableLineInterpolation+0x17c>
   }

   if (iIndex)
   14b60:	e15b30ba 	ldrh	r3, [fp, #-10]
   14b64:	e3530000 	cmp	r3, #0
   14b68:	0a000002 	beq	14b78 <TableLineInterpolation+0x1f4>
   {
      iIndex--;
   14b6c:	e15b30ba 	ldrh	r3, [fp, #-10]
   14b70:	e2433001 	sub	r3, r3, #1
   14b74:	e14b30ba 	strh	r3, [fp, #-10]
   }

   lLocalWork = ((uint32_t)iFirstPoint + (uint32_t)iIndex * iYStep);
   14b78:	e15b21b2 	ldrh	r2, [fp, #-18]	; 0xffffffee
   14b7c:	e15b30ba 	ldrh	r3, [fp, #-10]
   14b80:	e15b11b4 	ldrh	r1, [fp, #-20]	; 0xffffffec
   14b84:	e0030391 	mul	r3, r1, r3
   14b88:	e0823003 	add	r3, r2, r3
   14b8c:	e50b3008 	str	r3, [fp, #-8]

   if ((lXX == (mGetLongVoltage(piX_Points, iIndex)))
   14b90:	e15b30ba 	ldrh	r3, [fp, #-10]
   14b94:	e1a03083 	lsl	r3, r3, #1
   14b98:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14b9c:	e0823003 	add	r3, r2, r3
   14ba0:	e1d330b0 	ldrh	r3, [r3]
   14ba4:	e1a02003 	mov	r2, r3
   14ba8:	e1a03002 	mov	r3, r2
   14bac:	e1a03103 	lsl	r3, r3, #2
   14bb0:	e0833002 	add	r3, r3, r2
   14bb4:	e1a02103 	lsl	r2, r3, #2
   14bb8:	e0833002 	add	r3, r3, r2
   14bbc:	e1a03103 	lsl	r3, r3, #2
   14bc0:	e1a02003 	mov	r2, r3
   14bc4:	e51b3010 	ldr	r3, [fp, #-16]
   14bc8:	e1530002 	cmp	r3, r2
   14bcc:	0a000057 	beq	14d30 <TableLineInterpolation+0x3ac>
         || (iIndex == 0)//
   14bd0:	e15b30ba 	ldrh	r3, [fp, #-10]
   14bd4:	e3530000 	cmp	r3, #0
   14bd8:	0a000054 	beq	14d30 <TableLineInterpolation+0x3ac>
         || (iIndex == (*piPointNumber - 1))//
   14bdc:	e15b20ba 	ldrh	r2, [fp, #-10]
   14be0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   14be4:	e1d330b0 	ldrh	r3, [r3]
   14be8:	e2433001 	sub	r3, r3, #1
   14bec:	e1520003 	cmp	r2, r3
   14bf0:	0a00004e 	beq	14d30 <TableLineInterpolation+0x3ac>
       //  || (iIndex <= (mGetLongVoltage(piX_Points, *piPointNumber - 1)))//
         || ((mGetLongVoltage(piX_Points, iIndex)) <= (mGetLongVoltage(piX_Points, iIndex+1))))                       // For divide by zero escaping
   14bf4:	e15b30ba 	ldrh	r3, [fp, #-10]
   14bf8:	e1a03083 	lsl	r3, r3, #1
   14bfc:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14c00:	e0823003 	add	r3, r2, r3
   14c04:	e1d330b0 	ldrh	r3, [r3]
   14c08:	e1a02003 	mov	r2, r3
   14c0c:	e1a03002 	mov	r3, r2
   14c10:	e1a03103 	lsl	r3, r3, #2
   14c14:	e0833002 	add	r3, r3, r2
   14c18:	e1a02103 	lsl	r2, r3, #2
   14c1c:	e0833002 	add	r3, r3, r2
   14c20:	e1a03103 	lsl	r3, r3, #2
   14c24:	e1a01003 	mov	r1, r3
   14c28:	e15b30ba 	ldrh	r3, [fp, #-10]
   14c2c:	e2833001 	add	r3, r3, #1
   14c30:	e1a03083 	lsl	r3, r3, #1
   14c34:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14c38:	e0823003 	add	r3, r2, r3
   14c3c:	e1d330b0 	ldrh	r3, [r3]
   14c40:	e1a02003 	mov	r2, r3
   14c44:	e1a03002 	mov	r3, r2
   14c48:	e1a03103 	lsl	r3, r3, #2
   14c4c:	e0833002 	add	r3, r3, r2
   14c50:	e1a02103 	lsl	r2, r3, #2
   14c54:	e0833002 	add	r3, r3, r2
   14c58:	e1a03103 	lsl	r3, r3, #2
   14c5c:	e1510003 	cmp	r1, r3
   14c60:	9a000032 	bls	14d30 <TableLineInterpolation+0x3ac>
      // iLocalWork = iLocalWork;                               // This knot temperature
   }
   else
   {

      lLocalWork = lLocalWork + (((uint32_t)(mGetLongVoltage(piX_Points, iIndex)) - lXX) * (uint32_t)iYStep) /
   14c64:	e15b30ba 	ldrh	r3, [fp, #-10]
   14c68:	e1a03083 	lsl	r3, r3, #1
   14c6c:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14c70:	e0823003 	add	r3, r2, r3
   14c74:	e1d330b0 	ldrh	r3, [r3]
   14c78:	e1a02003 	mov	r2, r3
   14c7c:	e1a03002 	mov	r3, r2
   14c80:	e1a03103 	lsl	r3, r3, #2
   14c84:	e0833002 	add	r3, r3, r2
   14c88:	e1a02103 	lsl	r2, r3, #2
   14c8c:	e0833002 	add	r3, r3, r2
   14c90:	e1a03103 	lsl	r3, r3, #2
   14c94:	e1a02003 	mov	r2, r3
   14c98:	e51b3010 	ldr	r3, [fp, #-16]
   14c9c:	e0423003 	sub	r3, r2, r3
   14ca0:	e15b21b4 	ldrh	r2, [fp, #-20]	; 0xffffffec
   14ca4:	e0000392 	mul	r0, r2, r3
            (uint32_t)(mGetLongVoltage(piX_Points, iIndex) - mGetLongVoltage(piX_Points, iIndex+1));
   14ca8:	e15b30ba 	ldrh	r3, [fp, #-10]
   14cac:	e1a03083 	lsl	r3, r3, #1
   14cb0:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14cb4:	e0823003 	add	r3, r2, r3
   14cb8:	e1d330b0 	ldrh	r3, [r3]
   14cbc:	e1a02003 	mov	r2, r3
   14cc0:	e1a03002 	mov	r3, r2
   14cc4:	e1a03103 	lsl	r3, r3, #2
   14cc8:	e0833002 	add	r3, r3, r2
   14ccc:	e1a02103 	lsl	r2, r3, #2
   14cd0:	e0833002 	add	r3, r3, r2
   14cd4:	e1a03103 	lsl	r3, r3, #2
   14cd8:	e1a01003 	mov	r1, r3
   14cdc:	e15b30ba 	ldrh	r3, [fp, #-10]
   14ce0:	e2833001 	add	r3, r3, #1
   14ce4:	e1a03083 	lsl	r3, r3, #1
   14ce8:	e51b2020 	ldr	r2, [fp, #-32]	; 0xffffffe0
   14cec:	e0823003 	add	r3, r2, r3
   14cf0:	e1d330b0 	ldrh	r3, [r3]
   14cf4:	e1a02003 	mov	r2, r3
   14cf8:	e1a03002 	mov	r3, r2
   14cfc:	e1a03103 	lsl	r3, r3, #2
   14d00:	e0833002 	add	r3, r3, r2
   14d04:	e1a02103 	lsl	r2, r3, #2
   14d08:	e0833002 	add	r3, r3, r2
   14d0c:	e1a03103 	lsl	r3, r3, #2
   14d10:	e0413003 	sub	r3, r1, r3
      lLocalWork = lLocalWork + (((uint32_t)(mGetLongVoltage(piX_Points, iIndex)) - lXX) * (uint32_t)iYStep) /
   14d14:	e1a01003 	mov	r1, r3
   14d18:	eb00035f 	bl	15a9c <__udivsi3>
   14d1c:	e1a03000 	mov	r3, r0
   14d20:	e1a02003 	mov	r2, r3
   14d24:	e51b3008 	ldr	r3, [fp, #-8]
   14d28:	e0833002 	add	r3, r3, r2
   14d2c:	e50b3008 	str	r3, [fp, #-8]

   }

   return (uint16_t)(lLocalWork);
   14d30:	e51b3008 	ldr	r3, [fp, #-8]
   14d34:	e6ff3073 	uxth	r3, r3
}
   14d38:	e1a00003 	mov	r0, r3
   14d3c:	e24bd004 	sub	sp, fp, #4
   14d40:	e8bd8800 	pop	{fp, pc}
   14d44:	49742400 	.word	0x49742400

00014d48 <iniTemperaturController>:
   void iniTemperaturController(void)

   Call at start during global initial
   ------------------------------------------------------------------------------- */
void iniTemperaturController(void)
{
   14d48:	e92d4800 	push	{fp, lr}
   14d4c:	e28db004 	add	fp, sp, #4
   getSensCharacteristic(&iTMH_Length, &iTMH_Temperature_points[0], &iTMH_Voltage_points[0]);
   14d50:	e59f2014 	ldr	r2, [pc, #20]	; 14d6c <iniTemperaturController+0x24>
   14d54:	e59f1014 	ldr	r1, [pc, #20]	; 14d70 <iniTemperaturController+0x28>
   14d58:	e59f0014 	ldr	r0, [pc, #20]	; 14d74 <iniTemperaturController+0x2c>
   14d5c:	eb0001d1 	bl	154a8 <getSensCharacteristic>

   getPIDcoefs();
   14d60:	eb00026b 	bl	15714 <getPIDcoefs>

}
   14d64:	e1a00000 	nop			; (mov r0, r0)
   14d68:	e8bd8800 	pop	{fp, pc}
   14d6c:	000272a8 	.word	0x000272a8
   14d70:	000275d4 	.word	0x000275d4
   14d74:	000278f4 	.word	0x000278f4

00014d78 <getTemperatureValue>:
   uint32_t getTemperatureValue(float fVoltage)

   Call at start during global initial
   ------------------------------------------------------------------------------- */
uint32_t getTemperatureValue(float fVoltage)
{
   14d78:	e92d4800 	push	{fp, lr}
   14d7c:	e28db004 	add	fp, sp, #4
   14d80:	e24dd010 	sub	sp, sp, #16
   14d84:	ed0b0a04 	vstr	s0, [fp, #-16]
   uint32_t lResult;


   lResult = TableLineInterpolation(fVoltage, &iTMH_Length, &iTMH_Voltage_points[0], &iTMH_Temperature_points[0]);
   14d88:	e59f2024 	ldr	r2, [pc, #36]	; 14db4 <getTemperatureValue+0x3c>
   14d8c:	e59f1024 	ldr	r1, [pc, #36]	; 14db8 <getTemperatureValue+0x40>
   14d90:	e59f0024 	ldr	r0, [pc, #36]	; 14dbc <getTemperatureValue+0x44>
   14d94:	ed1b0a04 	vldr	s0, [fp, #-16]
   14d98:	ebfffef9 	bl	14984 <TableLineInterpolation>
   14d9c:	e1a03000 	mov	r3, r0
   14da0:	e50b3008 	str	r3, [fp, #-8]


   return(lResult);
   14da4:	e51b3008 	ldr	r3, [fp, #-8]
}
   14da8:	e1a00003 	mov	r0, r3
   14dac:	e24bd004 	sub	sp, fp, #4
   14db0:	e8bd8800 	pop	{fp, pc}
   14db4:	000275d4 	.word	0x000275d4
   14db8:	000272a8 	.word	0x000272a8
   14dbc:	000278f4 	.word	0x000278f4

00014dc0 <getTemperatures>:
/* ------------------------------------------------------------------------------
 * void getTemperatures()
 * The Procedure reads current state of sensors data and converts it to temperature
 * ------------------------------------------------------------------------------*/
void getTemperatures()
{
   14dc0:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   14dc4:	e28db01c 	add	fp, sp, #28
   14dc8:	e24dd030 	sub	sp, sp, #48	; 0x30
   sSensorVoltageDataStruct sSensorVoltageData;
   uint32_t  lWork1, lWork2;
   int64_t   sllWork;

   sSensorVoltageData = getSensorData();
   14dcc:	e24b3048 	sub	r3, fp, #72	; 0x48
   14dd0:	e1a00003 	mov	r0, r3
   14dd4:	ebfffd17 	bl	14238 <getSensorData>
   float x = sSensorVoltageData.fVoltageCurrent;
   14dd8:	e51b3048 	ldr	r3, [fp, #-72]	; 0xffffffb8
   14ddc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
   lWork1 = getTemperatureValue(sSensorVoltageData.fVoltageCurrent);
   14de0:	ed5b7a12 	vldr	s15, [fp, #-72]	; 0xffffffb8
   14de4:	eeb00a67 	vmov.f32	s0, s15
   14de8:	ebffffe2 	bl	14d78 <getTemperatureValue>
   14dec:	e50b0024 	str	r0, [fp, #-36]	; 0xffffffdc
   lWork2 = getTemperatureValue(sSensorVoltageData.fVoltageLast);
   14df0:	ed5b7a11 	vldr	s15, [fp, #-68]	; 0xffffffbc
   14df4:	eeb00a67 	vmov.f32	s0, s15
   14df8:	ebffffde 	bl	14d78 <getTemperatureValue>
   14dfc:	e50b0028 	str	r0, [fp, #-40]	; 0xffffffd8
   pthread_mutex_lock(&data_lock);
   14e00:	e59f00d8 	ldr	r0, [pc, #216]	; 14ee0 <getTemperatures+0x120>
   14e04:	ebffeec0 	bl	1090c <pthread_mutex_lock@plt>


   lTemperatureReal     = lWork1;
   14e08:	e59f20d4 	ldr	r2, [pc, #212]	; 14ee4 <getTemperatures+0x124>
   14e0c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
   14e10:	e5823000 	str	r3, [r2]
   lTemperaturePrevious = lWork2;
   14e14:	e59f20cc 	ldr	r2, [pc, #204]	; 14ee8 <getTemperatures+0x128>
   14e18:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
   14e1c:	e5823000 	str	r3, [r2]

   /* according to measured time the relative reduced value of temperature changing speed
    * DT/dt = DTx/100ms => DTx = DT * 100ms / dt
   */

   sllWork = (int64_t)((int64_t)lTemperatureReal - lTemperaturePrevious) * mNormTime(kTemperaturControlPeriod);
   14e20:	e59f30bc 	ldr	r3, [pc, #188]	; 14ee4 <getTemperatures+0x124>
   14e24:	e5933000 	ldr	r3, [r3]
   14e28:	e1a00003 	mov	r0, r3
   14e2c:	e3a01000 	mov	r1, #0
   14e30:	e59f30b0 	ldr	r3, [pc, #176]	; 14ee8 <getTemperatures+0x128>
   14e34:	e5933000 	ldr	r3, [r3]
   14e38:	e1a02003 	mov	r2, r3
   14e3c:	e3a03000 	mov	r3, #0
   14e40:	e0504002 	subs	r4, r0, r2
   14e44:	e0c15003 	sbc	r5, r1, r3
   14e48:	e1a02004 	mov	r2, r4
   14e4c:	e1a03005 	mov	r3, r5
   14e50:	e0928002 	adds	r8, r2, r2
   14e54:	e0a39003 	adc	r9, r3, r3
   14e58:	e1a02008 	mov	r2, r8
   14e5c:	e1a03009 	mov	r3, r9
   14e60:	e0922004 	adds	r2, r2, r4
   14e64:	e0a33005 	adc	r3, r3, r5
   14e68:	e3a00000 	mov	r0, #0
   14e6c:	e3a01000 	mov	r1, #0
   14e70:	e1a01283 	lsl	r1, r3, #5
   14e74:	e1811da2 	orr	r1, r1, r2, lsr #27
   14e78:	e1a00282 	lsl	r0, r2, #5
   14e7c:	e0922000 	adds	r2, r2, r0
   14e80:	e0a33001 	adc	r3, r3, r1
   14e84:	e0926004 	adds	r6, r2, r4
   14e88:	e0a37005 	adc	r7, r3, r5
   14e8c:	e14b63f4 	strd	r6, [fp, #-52]	; 0xffffffcc
   if (sSensorVoltageData.lTimeDelta)
   14e90:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
   14e94:	e3530000 	cmp	r3, #0
   14e98:	0a000009 	beq	14ec4 <getTemperatures+0x104>
   {
      slTemperatureSpeed = (int32_t)(sllWork / sSensorVoltageData.lTimeDelta);
   14e9c:	e51b3040 	ldr	r3, [fp, #-64]	; 0xffffffc0
   14ea0:	e1a02003 	mov	r2, r3
   14ea4:	e3a03000 	mov	r3, #0
   14ea8:	e14b03d4 	ldrd	r0, [fp, #-52]	; 0xffffffcc
   14eac:	eb00037d 	bl	15ca8 <__aeabi_ldivmod>
   14eb0:	e1a02000 	mov	r2, r0
   14eb4:	e1a03001 	mov	r3, r1
   14eb8:	e59f302c 	ldr	r3, [pc, #44]	; 14eec <getTemperatures+0x12c>
   14ebc:	e5832000 	str	r2, [r3]
   14ec0:	ea000001 	b	14ecc <getTemperatures+0x10c>
   }
   else
   {
      printf("Timedelta error");
   14ec4:	e59f0024 	ldr	r0, [pc, #36]	; 14ef0 <getTemperatures+0x130>
   14ec8:	ebffee98 	bl	10930 <printf@plt>
   }

   pthread_mutex_unlock(&data_lock);
   14ecc:	e59f000c 	ldr	r0, [pc, #12]	; 14ee0 <getTemperatures+0x120>
   14ed0:	ebffeef3 	bl	10aa4 <pthread_mutex_unlock@plt>

}
   14ed4:	e1a00000 	nop			; (mov r0, r0)
   14ed8:	e24bd01c 	sub	sp, fp, #28
   14edc:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
   14ee0:	00027248 	.word	0x00027248
   14ee4:	000271dc 	.word	0x000271dc
   14ee8:	000271d8 	.word	0x000271d8
   14eec:	000271e0 	.word	0x000271e0
   14ef0:	00016398 	.word	0x00016398

00014ef4 <CalculRegulator>:
   Procedure for calculation output regulator effect out PID

   Call from
   ------------------------------------------------------------------------------- */
void CalculRegulator(void)
{
   14ef4:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   14ef8:	e28db01c 	add	fp, sp, #28
   14efc:	e24dd010 	sub	sp, sp, #16

   int64_t sllAccumulator;

#ifdef SCANNING
   int64_t sllDeltaT = (int64_t)lTemperatureCurrentSet - lTemperatureReal;
   14f00:	e59f31d4 	ldr	r3, [pc, #468]	; 150dc <CalculRegulator+0x1e8>
   14f04:	e5933000 	ldr	r3, [r3]
   14f08:	e1a00003 	mov	r0, r3
   14f0c:	e3a01000 	mov	r1, #0
   14f10:	e59f31c8 	ldr	r3, [pc, #456]	; 150e0 <CalculRegulator+0x1ec>
   14f14:	e5933000 	ldr	r3, [r3]
   14f18:	e1a02003 	mov	r2, r3
   14f1c:	e3a03000 	mov	r3, #0
   14f20:	e0504002 	subs	r4, r0, r2
   14f24:	e0c15003 	sbc	r5, r1, r3
   14f28:	e14b42f4 	strd	r4, [fp, #-36]	; 0xffffffdc
#else
   int64_t sllDeltaT = (int64_t)lTemperatureSet - lTemperatureReal;
#endif


   getTemperatures();
   14f2c:	ebffffa3 	bl	14dc0 <getTemperatures>

   sllAccumulator = (int64_t)iRegulatorEffect + (int64_t)(sllDeltaT * Kprop(lTemperatureReal)); // Get proportional part
   14f30:	e59f31ac 	ldr	r3, [pc, #428]	; 150e4 <CalculRegulator+0x1f0>
   14f34:	e1d330b0 	ldrh	r3, [r3]
   14f38:	e6ff4073 	uxth	r4, r3
   14f3c:	e3a05000 	mov	r5, #0
   14f40:	e59f3198 	ldr	r3, [pc, #408]	; 150e0 <CalculRegulator+0x1ec>
   14f44:	e5933000 	ldr	r3, [r3]
   14f48:	e6ff3073 	uxth	r3, r3
   14f4c:	e1a00003 	mov	r0, r3
   14f50:	eb000068 	bl	150f8 <Kprop>
   14f54:	e1a03000 	mov	r3, r0
   14f58:	e6ff2073 	uxth	r2, r3
   14f5c:	e3a03000 	mov	r3, #0
   14f60:	e51b1024 	ldr	r1, [fp, #-36]	; 0xffffffdc
   14f64:	e0000193 	mul	r0, r3, r1
   14f68:	e51b1020 	ldr	r1, [fp, #-32]	; 0xffffffe0
   14f6c:	e0010192 	mul	r1, r2, r1
   14f70:	e0801001 	add	r1, r0, r1
   14f74:	e51b0024 	ldr	r0, [fp, #-36]	; 0xffffffdc
   14f78:	e0832290 	umull	r2, r3, r0, r2
   14f7c:	e0811003 	add	r1, r1, r3
   14f80:	e1a03001 	mov	r3, r1
   14f84:	e0948002 	adds	r8, r4, r2
   14f88:	e0a59003 	adc	r9, r5, r3
   14f8c:	e14b82fc 	strd	r8, [fp, #-44]	; 0xffffffd4
/*
   sllAccumulator = mLimitSignLong(sllAccumulator);
   sllAccumulator = (int64_t)sllAccumulator   + (int64_t)slTemperatureSpeed * Kintegr(lTemperatureReal);  // Get differential part
*/

   sllAccumulator = mLimitSignLong(sllAccumulator);
   14f90:	e14b22dc 	ldrd	r2, [fp, #-44]	; 0xffffffd4
   14f94:	e3e00102 	mvn	r0, #-2147483648	; 0x80000000
   14f98:	e3a01000 	mov	r1, #0
   14f9c:	e1500002 	cmp	r0, r2
   14fa0:	e0d13003 	sbcs	r3, r1, r3
   14fa4:	ba000008 	blt	14fcc <CalculRegulator+0xd8>
   14fa8:	e14b22dc 	ldrd	r2, [fp, #-44]	; 0xffffffd4
   14fac:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
   14fb0:	e3e01000 	mvn	r1, #0
   14fb4:	e1520000 	cmp	r2, r0
   14fb8:	e0d31001 	sbcs	r1, r3, r1
   14fbc:	aa000004 	bge	14fd4 <CalculRegulator+0xe0>
   14fc0:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
   14fc4:	e3e03000 	mvn	r3, #0
   14fc8:	ea000001 	b	14fd4 <CalculRegulator+0xe0>
   14fcc:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
   14fd0:	e3a03000 	mov	r3, #0
   14fd4:	e14b22fc 	strd	r2, [fp, #-44]	; 0xffffffd4

   sllAccumulator = (int64_t)sllAccumulator   + (int64_t)slTemperatureSpeed * Kdif(lTemperatureReal);  // Get differential part
   14fd8:	e59f3108 	ldr	r3, [pc, #264]	; 150e8 <CalculRegulator+0x1f4>
   14fdc:	e5933000 	ldr	r3, [r3]
   14fe0:	e1a04003 	mov	r4, r3
   14fe4:	e1a05fc4 	asr	r5, r4, #31
   14fe8:	e59f30f0 	ldr	r3, [pc, #240]	; 150e0 <CalculRegulator+0x1ec>
   14fec:	e5933000 	ldr	r3, [r3]
   14ff0:	e6ff3073 	uxth	r3, r3
   14ff4:	e1a00003 	mov	r0, r3
   14ff8:	eb00004b 	bl	1512c <Kdif>
   14ffc:	e1a03000 	mov	r3, r0
   15000:	e1a02003 	mov	r2, r3
   15004:	e3a03000 	mov	r3, #0
   15008:	e0000592 	mul	r0, r2, r5
   1500c:	e0010394 	mul	r1, r4, r3
   15010:	e0801001 	add	r1, r0, r1
   15014:	e0832294 	umull	r2, r3, r4, r2
   15018:	e0811003 	add	r1, r1, r3
   1501c:	e1a03001 	mov	r3, r1
   15020:	e14b02dc 	ldrd	r0, [fp, #-44]	; 0xffffffd4
   15024:	e0906002 	adds	r6, r0, r2
   15028:	e0a17003 	adc	r7, r1, r3
   1502c:	e14b62fc 	strd	r6, [fp, #-44]	; 0xffffffd4

   sllAccumulator = mLimitSignLong(sllAccumulator);
   15030:	e14b22dc 	ldrd	r2, [fp, #-44]	; 0xffffffd4
   15034:	e3e00102 	mvn	r0, #-2147483648	; 0x80000000
   15038:	e3a01000 	mov	r1, #0
   1503c:	e1500002 	cmp	r0, r2
   15040:	e0d13003 	sbcs	r3, r1, r3
   15044:	ba000008 	blt	1506c <CalculRegulator+0x178>
   15048:	e14b22dc 	ldrd	r2, [fp, #-44]	; 0xffffffd4
   1504c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
   15050:	e3e01000 	mvn	r1, #0
   15054:	e1520000 	cmp	r2, r0
   15058:	e0d31001 	sbcs	r1, r3, r1
   1505c:	aa000004 	bge	15074 <CalculRegulator+0x180>
   15060:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
   15064:	e3e03000 	mvn	r3, #0
   15068:	ea000001 	b	15074 <CalculRegulator+0x180>
   1506c:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
   15070:	e3a03000 	mov	r3, #0
   15074:	e14b22fc 	strd	r2, [fp, #-44]	; 0xffffffd4


   iRegulatorEffect = mLimitWord(sllAccumulator);                                       // Output effect for regulator
   15078:	e14b22dc 	ldrd	r2, [fp, #-44]	; 0xffffffd4
   1507c:	e59f0068 	ldr	r0, [pc, #104]	; 150ec <CalculRegulator+0x1f8>
   15080:	e3a01000 	mov	r1, #0
   15084:	e1500002 	cmp	r0, r2
   15088:	e0d13003 	sbcs	r3, r1, r3
   1508c:	ba000007 	blt	150b0 <CalculRegulator+0x1bc>
   15090:	e14b22dc 	ldrd	r2, [fp, #-44]	; 0xffffffd4
   15094:	e3520000 	cmp	r2, #0
   15098:	e2d31000 	sbcs	r1, r3, #0
   1509c:	aa000001 	bge	150a8 <CalculRegulator+0x1b4>
   150a0:	e3a02000 	mov	r2, #0
   150a4:	e3a03000 	mov	r3, #0
   150a8:	e6ff3072 	uxth	r3, r2
   150ac:	ea000000 	b	150b4 <CalculRegulator+0x1c0>
   150b0:	e59f3038 	ldr	r3, [pc, #56]	; 150f0 <CalculRegulator+0x1fc>
   150b4:	e59f2028 	ldr	r2, [pc, #40]	; 150e4 <CalculRegulator+0x1f0>
   150b8:	e1c230b0 	strh	r3, [r2]

   lTemperaturePrevious = lTemperatureReal;
   150bc:	e59f301c 	ldr	r3, [pc, #28]	; 150e0 <CalculRegulator+0x1ec>
   150c0:	e5933000 	ldr	r3, [r3]
   150c4:	e59f2028 	ldr	r2, [pc, #40]	; 150f4 <CalculRegulator+0x200>
   150c8:	e5823000 	str	r3, [r2]

   // Calculation output effects
   getRegulatorOuputs();
   150cc:	eb000022 	bl	1515c <getRegulatorOuputs>
}
   150d0:	e1a00000 	nop			; (mov r0, r0)
   150d4:	e24bd01c 	sub	sp, fp, #28
   150d8:	e8bd8bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, pc}
   150dc:	000271f4 	.word	0x000271f4
   150e0:	000271dc 	.word	0x000271dc
   150e4:	00027260 	.word	0x00027260
   150e8:	000271e0 	.word	0x000271e0
   150ec:	0000fffe 	.word	0x0000fffe
   150f0:	0000ffff 	.word	0x0000ffff
   150f4:	000271d8 	.word	0x000271d8

000150f8 <Kprop>:
   Kprop
   Procedure for calculation proportional enclosure of PID-low
   Call from CalculRegulator
   ------------------------------------------------------------------------------- */
uint16_t Kprop(uint16_t T)
{
   150f8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   150fc:	e28db000 	add	fp, sp, #0
   15100:	e24dd00c 	sub	sp, sp, #12
   15104:	e1a03000 	mov	r3, r0
   15108:	e14b30b6 	strh	r3, [fp, #-6]
   {
      #ifndef debugmode
         lKprop = 512;
      #endif
   }
   return (lKprop);
   1510c:	e59f3014 	ldr	r3, [pc, #20]	; 15128 <Kprop+0x30>
   15110:	e5933000 	ldr	r3, [r3]
   15114:	e6ff3073 	uxth	r3, r3
}
   15118:	e1a00003 	mov	r0, r3
   1511c:	e28bd000 	add	sp, fp, #0
   15120:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   15124:	e12fff1e 	bx	lr
   15128:	000271e8 	.word	0x000271e8

0001512c <Kdif>:
   Kdif
   Procedure for calculation differential enclosure of PID-low
   Call from CalculRegulator
   ------------------------------------------------------------------------------- */
uint32_t Kdif(uint16_t T)
{
   1512c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   15130:	e28db000 	add	fp, sp, #0
   15134:	e24dd00c 	sub	sp, sp, #12
   15138:	e1a03000 	mov	r3, r0
   1513c:	e14b30b6 	strh	r3, [fp, #-6]
   {
      #ifndef debugmode
      lKdiff = 512;
      #endif
   }
   return (lKdiff);//(uint32_t)lKdiff * 512);
   15140:	e59f3010 	ldr	r3, [pc, #16]	; 15158 <Kdif+0x2c>
   15144:	e5933000 	ldr	r3, [r3]
}
   15148:	e1a00003 	mov	r0, r3
   1514c:	e28bd000 	add	sp, fp, #0
   15150:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   15154:	e12fff1e 	bx	lr
   15158:	000271f0 	.word	0x000271f0

0001515c <getRegulatorOuputs>:

   3. Cooling on PWM output timer 2 with low frequency.
   Call from MainLoop
   ------------------------------------------------------------------------------- */
void getRegulatorOuputs(void)
{
   1515c:	e92d4800 	push	{fp, lr}
   15160:	e28db004 	add	fp, sp, #4
   15164:	e24dd008 	sub	sp, sp, #8
#else
   #define kControlLevelChandge 200
   float         fWork;
#endif

   lLocal = (uint32_t)iRegulatorEffect;
   15168:	e59f315c 	ldr	r3, [pc, #348]	; 152cc <getRegulatorOuputs+0x170>
   1516c:	e1d330b0 	ldrh	r3, [r3]
   15170:	e50b3008 	str	r3, [fp, #-8]

#if (kTemperatureMin == 0)
   if (lTemperatureReal < kControlLevelChandge)
   15174:	e59f3154 	ldr	r3, [pc, #340]	; 152d0 <getRegulatorOuputs+0x174>
   15178:	e5933000 	ldr	r3, [r3]
   1517c:	e59f2150 	ldr	r2, [pc, #336]	; 152d4 <getRegulatorOuputs+0x178>
   15180:	e1530002 	cmp	r3, r2
   15184:	8a000009 	bhi	151b0 <getRegulatorOuputs+0x54>
   {
      lLocal = lLocal * lTemperatureReal;
   15188:	e59f3140 	ldr	r3, [pc, #320]	; 152d0 <getRegulatorOuputs+0x174>
   1518c:	e5932000 	ldr	r2, [r3]
   15190:	e51b3008 	ldr	r3, [fp, #-8]
   15194:	e0030392 	mul	r3, r2, r3
   15198:	e50b3008 	str	r3, [fp, #-8]
      lLocal = lLocal / kControlLevelChandge;
   1519c:	e51b3008 	ldr	r3, [fp, #-8]
   151a0:	e59f2130 	ldr	r2, [pc, #304]	; 152d8 <getRegulatorOuputs+0x17c>
   151a4:	e0832392 	umull	r2, r3, r2, r3
   151a8:	e1a03723 	lsr	r3, r3, #14
   151ac:	e50b3008 	str	r3, [fp, #-8]
      fWork = fWork / kControlLevelChandge;
      lLocal = lLocal * fWork;
   }
#endif

   iOut   = mAccToRegEffect((lLocal * kMaxRegulatorEffect) / 65535);
   151b0:	e51b2008 	ldr	r2, [fp, #-8]
   151b4:	e1a03002 	mov	r3, r2
   151b8:	e1a03803 	lsl	r3, r3, #16
   151bc:	e0433002 	sub	r3, r3, r2
   151c0:	e3730802 	cmn	r3, #131072	; 0x20000
   151c4:	8a000008 	bhi	151ec <getRegulatorOuputs+0x90>
   151c8:	e51b2008 	ldr	r2, [fp, #-8]
   151cc:	e1a03002 	mov	r3, r2
   151d0:	e1a03803 	lsl	r3, r3, #16
   151d4:	e0433002 	sub	r3, r3, r2
   151d8:	e59f20fc 	ldr	r2, [pc, #252]	; 152dc <getRegulatorOuputs+0x180>
   151dc:	e0832392 	umull	r2, r3, r2, r3
   151e0:	e1a037a3 	lsr	r3, r3, #15
   151e4:	e6ff3073 	uxth	r3, r3
   151e8:	ea000000 	b	151f0 <getRegulatorOuputs+0x94>
   151ec:	e59f30ec 	ldr	r3, [pc, #236]	; 152e0 <getRegulatorOuputs+0x184>
   151f0:	e14b30ba 	strh	r3, [fp, #-10]

   pthread_mutex_lock(&data_lock);
   151f4:	e59f00e8 	ldr	r0, [pc, #232]	; 152e4 <getRegulatorOuputs+0x188>
   151f8:	ebffedc3 	bl	1090c <pthread_mutex_lock@plt>
   iHeaterEffect  = iOut;
   151fc:	e59f20e4 	ldr	r2, [pc, #228]	; 152e8 <getRegulatorOuputs+0x18c>
   15200:	e15b30ba 	ldrh	r3, [fp, #-10]
   15204:	e1c230b0 	strh	r3, [r2]
   pthread_mutex_unlock(&data_lock);
   15208:	e59f00d4 	ldr	r0, [pc, #212]	; 152e4 <getRegulatorOuputs+0x188>
   1520c:	ebffee24 	bl	10aa4 <pthread_mutex_unlock@plt>

   iOut   = 65535 - iRegulatorEffect;
   15210:	e59f30b4 	ldr	r3, [pc, #180]	; 152cc <getRegulatorOuputs+0x170>
   15214:	e1d330b0 	ldrh	r3, [r3]
   15218:	e1e03003 	mvn	r3, r3
   1521c:	e14b30ba 	strh	r3, [fp, #-10]
   lLocal = (uint32_t)iOut * iOut;
   15220:	e15b30ba 	ldrh	r3, [fp, #-10]
   15224:	e15b20ba 	ldrh	r2, [fp, #-10]
   15228:	e0030392 	mul	r3, r2, r3
   1522c:	e50b3008 	str	r3, [fp, #-8]
   lLocal = lLocal / 65535;
   15230:	e51b3008 	ldr	r3, [fp, #-8]
   15234:	e59f20a0 	ldr	r2, [pc, #160]	; 152dc <getRegulatorOuputs+0x180>
   15238:	e0832392 	umull	r2, r3, r2, r3
   1523c:	e1a037a3 	lsr	r3, r3, #15
   15240:	e50b3008 	str	r3, [fp, #-8]

   iOut   = mAccToRegEffect((lLocal * kMaxRegulatorEffect) / 65535);
   15244:	e51b2008 	ldr	r2, [fp, #-8]
   15248:	e1a03002 	mov	r3, r2
   1524c:	e1a03803 	lsl	r3, r3, #16
   15250:	e0433002 	sub	r3, r3, r2
   15254:	e3730802 	cmn	r3, #131072	; 0x20000
   15258:	8a000008 	bhi	15280 <getRegulatorOuputs+0x124>
   1525c:	e51b2008 	ldr	r2, [fp, #-8]
   15260:	e1a03002 	mov	r3, r2
   15264:	e1a03803 	lsl	r3, r3, #16
   15268:	e0433002 	sub	r3, r3, r2
   1526c:	e59f2068 	ldr	r2, [pc, #104]	; 152dc <getRegulatorOuputs+0x180>
   15270:	e0832392 	umull	r2, r3, r2, r3
   15274:	e1a037a3 	lsr	r3, r3, #15
   15278:	e6ff3073 	uxth	r3, r3
   1527c:	ea000000 	b	15284 <getRegulatorOuputs+0x128>
   15280:	e59f3058 	ldr	r3, [pc, #88]	; 152e0 <getRegulatorOuputs+0x184>
   15284:	e14b30ba 	strh	r3, [fp, #-10]

   pthread_mutex_lock(&data_lock);
   15288:	e59f0054 	ldr	r0, [pc, #84]	; 152e4 <getRegulatorOuputs+0x188>
   1528c:	ebffed9e 	bl	1090c <pthread_mutex_lock@plt>
   iCoolerEffect = iOut;
   15290:	e59f2054 	ldr	r2, [pc, #84]	; 152ec <getRegulatorOuputs+0x190>
   15294:	e15b30ba 	ldrh	r3, [fp, #-10]
   15298:	e1c230b0 	strh	r3, [r2]
   pthread_mutex_unlock(&data_lock);
   1529c:	e59f0040 	ldr	r0, [pc, #64]	; 152e4 <getRegulatorOuputs+0x188>
   152a0:	ebffedff 	bl	10aa4 <pthread_mutex_unlock@plt>

   #ifdef VALVE_CONTROL
      pthread_mutex_lock(&data_lock);
   152a4:	e59f0038 	ldr	r0, [pc, #56]	; 152e4 <getRegulatorOuputs+0x188>
   152a8:	ebffed97 	bl	1090c <pthread_mutex_lock@plt>
      iValveOutput = iOut;
   152ac:	e59f203c 	ldr	r2, [pc, #60]	; 152f0 <getRegulatorOuputs+0x194>
   152b0:	e15b30ba 	ldrh	r3, [fp, #-10]
   152b4:	e1c230b0 	strh	r3, [r2]
      pthread_mutex_unlock(&data_lock);
   152b8:	e59f0024 	ldr	r0, [pc, #36]	; 152e4 <getRegulatorOuputs+0x188>
   152bc:	ebffedf8 	bl	10aa4 <pthread_mutex_unlock@plt>
   //   printf("iRegulatorEffect  = %u;\r\n", iRegulatorEffect);
   //   printf("iHeaterEffect  = %u;\r\n", iHeaterEffect);
   //   printf("iCoolerEffect  = %u;\r\n", iCoolerEffect);
   //   printf("iValveOutput  = %u;\r\n", iValveOutput);

}
   152c0:	e1a00000 	nop			; (mov r0, r0)
   152c4:	e24bd004 	sub	sp, fp, #4
   152c8:	e8bd8800 	pop	{fp, pc}
   152cc:	00027260 	.word	0x00027260
   152d0:	000271dc 	.word	0x000271dc
   152d4:	00004e1f 	.word	0x00004e1f
   152d8:	d1b71759 	.word	0xd1b71759
   152dc:	80008001 	.word	0x80008001
   152e0:	0000ffff 	.word	0x0000ffff
   152e4:	00027248 	.word	0x00027248
   152e8:	0002726c 	.word	0x0002726c
   152ec:	0002726e 	.word	0x0002726e
   152f0:	00027270 	.word	0x00027270

000152f4 <GetHeaterSetpoint>:

/*
 * */
uint16_t GetHeaterSetpoint(void)
{
   152f4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   152f8:	e28db000 	add	fp, sp, #0
   return(iHeaterEffect);
   152fc:	e59f3010 	ldr	r3, [pc, #16]	; 15314 <GetHeaterSetpoint+0x20>
   15300:	e1d330b0 	ldrh	r3, [r3]
}
   15304:	e1a00003 	mov	r0, r3
   15308:	e28bd000 	add	sp, fp, #0
   1530c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   15310:	e12fff1e 	bx	lr
   15314:	0002726c 	.word	0x0002726c

00015318 <GetCoolerSetpoint>:

uint16_t GetCoolerSetpoint(void)
{
   15318:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1531c:	e28db000 	add	fp, sp, #0
   return(iCoolerEffect);
   15320:	e59f3010 	ldr	r3, [pc, #16]	; 15338 <GetCoolerSetpoint+0x20>
   15324:	e1d330b0 	ldrh	r3, [r3]
}
   15328:	e1a00003 	mov	r0, r3
   1532c:	e28bd000 	add	sp, fp, #0
   15330:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   15334:	e12fff1e 	bx	lr
   15338:	0002726e 	.word	0x0002726e

0001533c <AutoSettingTemperature>:
   Procedure for setting temperature in automatic scanning mode
   The flag of scanning mode is difference from 0 lDelta_t and lDelta_T
   Call from MainLoop
   ------------------------------------------------------------------------------- */
void AutoSettingTemperature(void)
{
   1533c:	e92d4800 	push	{fp, lr}
   15340:	e28db004 	add	fp, sp, #4
   15344:	e24dd008 	sub	sp, sp, #8
   static uint32_t lTau;
   boolean bLocalBool;

   bLocalBool = false;
   15348:	e3a03000 	mov	r3, #0
   1534c:	e14b30b6 	strh	r3, [fp, #-6]

   if ((lDelta_t > mNormTime(0))
   15350:	e59f3134 	ldr	r3, [pc, #308]	; 1548c <AutoSettingTemperature+0x150>
   15354:	e5933000 	ldr	r3, [r3]
   15358:	e3530000 	cmp	r3, #0
   1535c:	0a000039 	beq	15448 <AutoSettingTemperature+0x10c>
       && (lDelta_T > mNormTime(0)))
   15360:	e59f3128 	ldr	r3, [pc, #296]	; 15490 <AutoSettingTemperature+0x154>
   15364:	e5933000 	ldr	r3, [r3]
   15368:	e3530000 	cmp	r3, #0
   1536c:	0a000035 	beq	15448 <AutoSettingTemperature+0x10c>
   {

      bScanOrSetMode = TRUE;
   15370:	e59f311c 	ldr	r3, [pc, #284]	; 15494 <AutoSettingTemperature+0x158>
   15374:	e3a02001 	mov	r2, #1
   15378:	e1c320b0 	strh	r2, [r3]


      if ((appMillis() - lTau) <= lDelta_t)
   1537c:	ebfff427 	bl	12420 <appMillis>
   15380:	e1a02000 	mov	r2, r0
   15384:	e59f310c 	ldr	r3, [pc, #268]	; 15498 <AutoSettingTemperature+0x15c>
   15388:	e5933000 	ldr	r3, [r3]
   1538c:	e0422003 	sub	r2, r2, r3
   15390:	e59f30f4 	ldr	r3, [pc, #244]	; 1548c <AutoSettingTemperature+0x150>
   15394:	e5933000 	ldr	r3, [r3]
   15398:	e1520003 	cmp	r2, r3
   1539c:	9a000034 	bls	15474 <AutoSettingTemperature+0x138>
      {
         // No any iTemperatureCurent changing
      }
      else
      {
         lTau = appMillis();
   153a0:	ebfff41e 	bl	12420 <appMillis>
   153a4:	e1a02000 	mov	r2, r0
   153a8:	e59f30e8 	ldr	r3, [pc, #232]	; 15498 <AutoSettingTemperature+0x15c>
   153ac:	e5832000 	str	r2, [r3]
         if (mAbs((signed long)lTemperatureCurrentSet - lTemperatureSet) > lDelta_T)
   153b0:	e59f30e4 	ldr	r3, [pc, #228]	; 1549c <AutoSettingTemperature+0x160>
   153b4:	e5932000 	ldr	r2, [r3]
   153b8:	e59f30e0 	ldr	r3, [pc, #224]	; 154a0 <AutoSettingTemperature+0x164>
   153bc:	e5933000 	ldr	r3, [r3]
   153c0:	e0422003 	sub	r2, r2, r3
   153c4:	e59f30c4 	ldr	r3, [pc, #196]	; 15490 <AutoSettingTemperature+0x154>
   153c8:	e5933000 	ldr	r3, [r3]
   153cc:	e1520003 	cmp	r2, r3
   153d0:	9a000015 	bls	1542c <AutoSettingTemperature+0xf0>
         {
            if (lTemperatureCurrentSet > lTemperatureSet)
   153d4:	e59f30c0 	ldr	r3, [pc, #192]	; 1549c <AutoSettingTemperature+0x160>
   153d8:	e5932000 	ldr	r2, [r3]
   153dc:	e59f30bc 	ldr	r3, [pc, #188]	; 154a0 <AutoSettingTemperature+0x164>
   153e0:	e5933000 	ldr	r3, [r3]
   153e4:	e1520003 	cmp	r2, r3
   153e8:	9a000007 	bls	1540c <AutoSettingTemperature+0xd0>
            {
               lTemperatureCurrentSet -= lDelta_T;
   153ec:	e59f30a8 	ldr	r3, [pc, #168]	; 1549c <AutoSettingTemperature+0x160>
   153f0:	e5932000 	ldr	r2, [r3]
   153f4:	e59f3094 	ldr	r3, [pc, #148]	; 15490 <AutoSettingTemperature+0x154>
   153f8:	e5933000 	ldr	r3, [r3]
   153fc:	e0423003 	sub	r3, r2, r3
   15400:	e59f2094 	ldr	r2, [pc, #148]	; 1549c <AutoSettingTemperature+0x160>
   15404:	e5823000 	str	r3, [r2]
      if ((appMillis() - lTau) <= lDelta_t)
   15408:	ea000019 	b	15474 <AutoSettingTemperature+0x138>
            }
            else // iTemperatureCurent < lTemperatureSet
            {
               lTemperatureCurrentSet += lDelta_T;
   1540c:	e59f3088 	ldr	r3, [pc, #136]	; 1549c <AutoSettingTemperature+0x160>
   15410:	e5932000 	ldr	r2, [r3]
   15414:	e59f3074 	ldr	r3, [pc, #116]	; 15490 <AutoSettingTemperature+0x154>
   15418:	e5933000 	ldr	r3, [r3]
   1541c:	e0823003 	add	r3, r2, r3
   15420:	e59f2074 	ldr	r2, [pc, #116]	; 1549c <AutoSettingTemperature+0x160>
   15424:	e5823000 	str	r3, [r2]
      if ((appMillis() - lTau) <= lDelta_t)
   15428:	ea000011 	b	15474 <AutoSettingTemperature+0x138>
            }
         }
         else
         {
            bLocalBool = true;
   1542c:	e3a03001 	mov	r3, #1
   15430:	e14b30b6 	strh	r3, [fp, #-6]
            lTemperatureCurrentSet = lTemperatureSet;
   15434:	e59f3064 	ldr	r3, [pc, #100]	; 154a0 <AutoSettingTemperature+0x164>
   15438:	e5933000 	ldr	r3, [r3]
   1543c:	e59f2058 	ldr	r2, [pc, #88]	; 1549c <AutoSettingTemperature+0x160>
   15440:	e5823000 	str	r3, [r2]
      if ((appMillis() - lTau) <= lDelta_t)
   15444:	ea00000a 	b	15474 <AutoSettingTemperature+0x138>

      }
   }
   else
   {
      bScanOrSetMode = FALSE;
   15448:	e59f3044 	ldr	r3, [pc, #68]	; 15494 <AutoSettingTemperature+0x158>
   1544c:	e3a02000 	mov	r2, #0
   15450:	e1c320b0 	strh	r2, [r3]
      lTemperatureCurrentSet = lTemperatureSet;
   15454:	e59f3044 	ldr	r3, [pc, #68]	; 154a0 <AutoSettingTemperature+0x164>
   15458:	e5933000 	ldr	r3, [r3]
   1545c:	e59f2038 	ldr	r2, [pc, #56]	; 1549c <AutoSettingTemperature+0x160>
   15460:	e5823000 	str	r3, [r2]
      lTau = appMillis();
   15464:	ebfff3ed 	bl	12420 <appMillis>
   15468:	e1a02000 	mov	r2, r0
   1546c:	e59f3024 	ldr	r3, [pc, #36]	; 15498 <AutoSettingTemperature+0x15c>
   15470:	e5832000 	str	r2, [r3]
   }

   bTempSetAchieved = bLocalBool;
   15474:	e59f2028 	ldr	r2, [pc, #40]	; 154a4 <AutoSettingTemperature+0x168>
   15478:	e15b30b6 	ldrh	r3, [fp, #-6]
   1547c:	e1c230b0 	strh	r3, [r2]
}
   15480:	e1a00000 	nop			; (mov r0, r0)
   15484:	e24bd004 	sub	sp, fp, #4
   15488:	e8bd8800 	pop	{fp, pc}
   1548c:	000271f8 	.word	0x000271f8
   15490:	00027274 	.word	0x00027274
   15494:	000275ca 	.word	0x000275ca
   15498:	00027264 	.word	0x00027264
   1549c:	000271f4 	.word	0x000271f4
   154a0:	000271e4 	.word	0x000271e4
   154a4:	000275ce 	.word	0x000275ce

000154a8 <getSensCharacteristic>:
 * piPointNumber - pointer on the number of points in table
 * pflTemperature_Points - pointer on temperature knots
 * pflTemperature_Points - pointer on voltage values
 ***********************************************************************************************************/
void getSensCharacteristic(uint16_t* piPointNumber, uint16_t* piTemperature_Points, uint16_t* piVoltage_Points)
{
   154a8:	e92d4800 	push	{fp, lr}
   154ac:	e28db004 	add	fp, sp, #4
   154b0:	e24dd0a0 	sub	sp, sp, #160	; 0xa0
   154b4:	e50b0090 	str	r0, [fp, #-144]	; 0xffffff70
   154b8:	e50b1094 	str	r1, [fp, #-148]	; 0xffffff6c
   154bc:	e50b2098 	str	r2, [fp, #-152]	; 0xffffff68

   uint32_t iPointQuantity;
   float flTemperature, flVoltage;
   unsigned int iCode;

   pFilePointer = fopen(TMH_file,"r");
   154c0:	e59f1238 	ldr	r1, [pc, #568]	; 15700 <getSensCharacteristic+0x258>
   154c4:	e59f0238 	ldr	r0, [pc, #568]	; 15704 <getSensCharacteristic+0x25c>
   154c8:	ebffed2a 	bl	10978 <fopen@plt>
   154cc:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec

   if (pFilePointer == NULL)
   154d0:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
   154d4:	e3530000 	cmp	r3, #0
   154d8:	1a000004 	bne	154f0 <getSensCharacteristic+0x48>
   {
      printf("Impossible to open file %s\r\n",TMH_file);
   154dc:	e59f1220 	ldr	r1, [pc, #544]	; 15704 <getSensCharacteristic+0x25c>
   154e0:	e59f0220 	ldr	r0, [pc, #544]	; 15708 <getSensCharacteristic+0x260>
   154e4:	ebffed11 	bl	10930 <printf@plt>
      getDirectory();
   154e8:	eb00010e 	bl	15928 <getDirectory>
   154ec:	ea00007d 	b	156e8 <getSensCharacteristic+0x240>
   }
   else
   {
      // read first string

      fgets(str, 50, pFilePointer);
   154f0:	e24b3080 	sub	r3, fp, #128	; 0x80
   154f4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
   154f8:	e3a01032 	mov	r1, #50	; 0x32
   154fc:	e1a00003 	mov	r0, r3
   15500:	ebffed34 	bl	109d8 <fgets@plt>

      uint16_t ctr = 0;
   15504:	e3a03000 	mov	r3, #0
   15508:	e14b30be 	strh	r3, [fp, #-14]
      Localchar = '_';
   1550c:	e3a0305f 	mov	r3, #95	; 0x5f
   15510:	e54b3005 	strb	r3, [fp, #-5]
      while (str[ctr])
   15514:	ea000025 	b	155b0 <getSensCharacteristic+0x108>
      {
         if (isspace(Localchar) && isspace(str[ctr]))
   15518:	ebffed2b 	bl	109cc <__ctype_b_loc@plt>
   1551c:	e1a03000 	mov	r3, r0
   15520:	e5932000 	ldr	r2, [r3]
   15524:	e55b3005 	ldrb	r3, [fp, #-5]
   15528:	e1a03083 	lsl	r3, r3, #1
   1552c:	e0823003 	add	r3, r2, r3
   15530:	e1d330b0 	ldrh	r3, [r3]
   15534:	e2033a02 	and	r3, r3, #8192	; 0x2000
   15538:	e3530000 	cmp	r3, #0
   1553c:	0a000013 	beq	15590 <getSensCharacteristic+0xe8>
   15540:	ebffed21 	bl	109cc <__ctype_b_loc@plt>
   15544:	e1a03000 	mov	r3, r0
   15548:	e5932000 	ldr	r2, [r3]
   1554c:	e15b30be 	ldrh	r3, [fp, #-14]
   15550:	e24b1004 	sub	r1, fp, #4
   15554:	e0813003 	add	r3, r1, r3
   15558:	e553307c 	ldrb	r3, [r3, #-124]	; 0xffffff84
   1555c:	e1a03083 	lsl	r3, r3, #1
   15560:	e0823003 	add	r3, r2, r3
   15564:	e1d330b0 	ldrh	r3, [r3]
   15568:	e2033a02 	and	r3, r3, #8192	; 0x2000
   1556c:	e3530000 	cmp	r3, #0
   15570:	0a000006 	beq	15590 <getSensCharacteristic+0xe8>
         {
            str[ctr-1] = '\0';
   15574:	e15b30be 	ldrh	r3, [fp, #-14]
   15578:	e2433001 	sub	r3, r3, #1
   1557c:	e24b2004 	sub	r2, fp, #4
   15580:	e0823003 	add	r3, r2, r3
   15584:	e3a02000 	mov	r2, #0
   15588:	e543207c 	strb	r2, [r3, #-124]	; 0xffffff84
            break;
   1558c:	ea00000d 	b	155c8 <getSensCharacteristic+0x120>
         }
         else
         {
            Localchar=str[ctr];
   15590:	e15b30be 	ldrh	r3, [fp, #-14]
   15594:	e24b2004 	sub	r2, fp, #4
   15598:	e0823003 	add	r3, r2, r3
   1559c:	e553307c 	ldrb	r3, [r3, #-124]	; 0xffffff84
   155a0:	e54b3005 	strb	r3, [fp, #-5]
            ctr++;
   155a4:	e15b30be 	ldrh	r3, [fp, #-14]
   155a8:	e2833001 	add	r3, r3, #1
   155ac:	e14b30be 	strh	r3, [fp, #-14]
      while (str[ctr])
   155b0:	e15b30be 	ldrh	r3, [fp, #-14]
   155b4:	e24b2004 	sub	r2, fp, #4
   155b8:	e0823003 	add	r3, r2, r3
   155bc:	e553307c 	ldrb	r3, [r3, #-124]	; 0xffffff84
   155c0:	e3530000 	cmp	r3, #0
   155c4:	1affffd3 	bne	15518 <getSensCharacteristic+0x70>
         }
      }

      // find last occurrence of space bar
      ptr = strrchr( str, ' ');
   155c8:	e24b3080 	sub	r3, fp, #128	; 0x80
   155cc:	e3a01020 	mov	r1, #32
   155d0:	e1a00003 	mov	r0, r3
   155d4:	ebffed26 	bl	10a74 <strrchr@plt>
   155d8:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8

      // Sensor name
      SensorName = ptr;
   155dc:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   155e0:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
      printf("Sensor name: %s\r\n",SensorName);
   155e4:	e51b101c 	ldr	r1, [fp, #-28]	; 0xffffffe4
   155e8:	e59f011c 	ldr	r0, [pc, #284]	; 1570c <getSensCharacteristic+0x264>
   155ec:	ebffeccf 	bl	10930 <printf@plt>

      iPointQuantity = 0;
   155f0:	e3a03000 	mov	r3, #0
   155f4:	e50b300c 	str	r3, [fp, #-12]

      // 3 lines pass - nothing to save
      (void)fgets(str, 50, pFilePointer);
   155f8:	e24b3080 	sub	r3, fp, #128	; 0x80
   155fc:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
   15600:	e3a01032 	mov	r1, #50	; 0x32
   15604:	e1a00003 	mov	r0, r3
   15608:	ebffecf2 	bl	109d8 <fgets@plt>
      (void)fgets(str, 50, pFilePointer);
   1560c:	e24b3080 	sub	r3, fp, #128	; 0x80
   15610:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
   15614:	e3a01032 	mov	r1, #50	; 0x32
   15618:	e1a00003 	mov	r0, r3
   1561c:	ebffeced 	bl	109d8 <fgets@plt>
      (void)fgets(str, 50, pFilePointer);
   15620:	e24b3080 	sub	r3, fp, #128	; 0x80
   15624:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
   15628:	e3a01032 	mov	r1, #50	; 0x32
   1562c:	e1a00003 	mov	r0, r3
   15630:	ebffece8 	bl	109d8 <fgets@plt>

      // Get table data
      while( fscanf(pFilePointer, "%f %f %u\n"
   15634:	ea00001a 	b	156a4 <getSensCharacteristic+0x1fc>
                      , &flTemperature, &flVoltage, &iCode) != EOF )
      {
         // If we get hear it means the string was read, otherwise the loop would be end

          //printf("%f %f %d \n", flTemperature, flVoltage, iCode);
          iPointQuantity++;
   15638:	e51b300c 	ldr	r3, [fp, #-12]
   1563c:	e2833001 	add	r3, r3, #1
   15640:	e50b300c 	str	r3, [fp, #-12]

          // get the read values
          *piTemperature_Points = (uint16_t)(flTemperature * 100.0);
   15644:	ed5b7a21 	vldr	s15, [fp, #-132]	; 0xffffff7c
   15648:	eeb77ae7 	vcvt.f64.f32	d7, s15
   1564c:	ed9f6b27 	vldr	d6, [pc, #156]	; 156f0 <getSensCharacteristic+0x248>
   15650:	ee277b06 	vmul.f64	d7, d7, d6
   15654:	eefc7bc7 	vcvt.u32.f64	s15, d7
   15658:	ee173a90 	vmov	r3, s15
   1565c:	e6ff2073 	uxth	r2, r3
   15660:	e51b3094 	ldr	r3, [fp, #-148]	; 0xffffff6c
   15664:	e1c320b0 	strh	r2, [r3]
          *piVoltage_Points = (uint16_t)(flVoltage * 10000.0);
   15668:	ed5b7a22 	vldr	s15, [fp, #-136]	; 0xffffff78
   1566c:	eeb77ae7 	vcvt.f64.f32	d7, s15
   15670:	ed9f6b20 	vldr	d6, [pc, #128]	; 156f8 <getSensCharacteristic+0x250>
   15674:	ee277b06 	vmul.f64	d7, d7, d6
   15678:	eefc7bc7 	vcvt.u32.f64	s15, d7
   1567c:	ee173a90 	vmov	r3, s15
   15680:	e6ff2073 	uxth	r2, r3
   15684:	e51b3098 	ldr	r3, [fp, #-152]	; 0xffffff68
   15688:	e1c320b0 	strh	r2, [r3]

         // Increase pointers for next point-values
          piTemperature_Points++;
   1568c:	e51b3094 	ldr	r3, [fp, #-148]	; 0xffffff6c
   15690:	e2833002 	add	r3, r3, #2
   15694:	e50b3094 	str	r3, [fp, #-148]	; 0xffffff6c
          piVoltage_Points++;
   15698:	e51b3098 	ldr	r3, [fp, #-152]	; 0xffffff68
   1569c:	e2833002 	add	r3, r3, #2
   156a0:	e50b3098 	str	r3, [fp, #-152]	; 0xffffff68
      while( fscanf(pFilePointer, "%f %f %u\n"
   156a4:	e24b1088 	sub	r1, fp, #136	; 0x88
   156a8:	e24b2084 	sub	r2, fp, #132	; 0x84
   156ac:	e24b308c 	sub	r3, fp, #140	; 0x8c
   156b0:	e58d3000 	str	r3, [sp]
   156b4:	e1a03001 	mov	r3, r1
   156b8:	e59f1050 	ldr	r1, [pc, #80]	; 15710 <getSensCharacteristic+0x268>
   156bc:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
   156c0:	ebffecee 	bl	10a80 <__isoc99_fscanf@plt>
   156c4:	e1a03000 	mov	r3, r0
   156c8:	e3730001 	cmn	r3, #1
   156cc:	1affffd9 	bne	15638 <getSensCharacteristic+0x190>
      }

      *piPointNumber = iPointQuantity;
   156d0:	e51b300c 	ldr	r3, [fp, #-12]
   156d4:	e6ff2073 	uxth	r2, r3
   156d8:	e51b3090 	ldr	r3, [fp, #-144]	; 0xffffff70
   156dc:	e1c320b0 	strh	r2, [r3]

      fclose(pFilePointer);
   156e0:	e51b0014 	ldr	r0, [fp, #-20]	; 0xffffffec
   156e4:	ebffecd6 	bl	10a44 <fclose@plt>
   }
}
   156e8:	e24bd004 	sub	sp, fp, #4
   156ec:	e8bd8800 	pop	{fp, pc}
   156f0:	00000000 	.word	0x00000000
   156f4:	40590000 	.word	0x40590000
   156f8:	00000000 	.word	0x00000000
   156fc:	40c38800 	.word	0x40c38800
   15700:	000163a8 	.word	0x000163a8
   15704:	000163ac 	.word	0x000163ac
   15708:	000163b8 	.word	0x000163b8
   1570c:	000163d8 	.word	0x000163d8
   15710:	000163ec 	.word	0x000163ec

00015714 <getPIDcoefs>:
 * plKprop   -
 * plKintegr -
 * plKdiff   -
 ***********************************************************************************************************/
boolean getPIDcoefs(void)
{
   15714:	e92d4800 	push	{fp, lr}
   15718:	e28db004 	add	fp, sp, #4
   1571c:	e24dd080 	sub	sp, sp, #128	; 0x80
   const char* str_Kprop = "#Kprop";
   15720:	e59f31c0 	ldr	r3, [pc, #448]	; 158e8 <getPIDcoefs+0x1d4>
   15724:	e50b300c 	str	r3, [fp, #-12]
   const char* str_Kint  = "#Kint";
   15728:	e59f31bc 	ldr	r3, [pc, #444]	; 158ec <getPIDcoefs+0x1d8>
   1572c:	e50b3010 	str	r3, [fp, #-16]
   const char* str_Kdiff = "#Kdiff";
   15730:	e59f31b8 	ldr	r3, [pc, #440]	; 158f0 <getPIDcoefs+0x1dc>
   15734:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
   char  str[100];
   uint32_t lLocal;
   uint32_t lLocalKoef;
   uint16_t iResult;

   pFilePointer = fopen(config_file,"r");
   15738:	e59f11b4 	ldr	r1, [pc, #436]	; 158f4 <getPIDcoefs+0x1e0>
   1573c:	e59f01b4 	ldr	r0, [pc, #436]	; 158f8 <getPIDcoefs+0x1e4>
   15740:	ebffec8c 	bl	10978 <fopen@plt>
   15744:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
   iResult = 0;
   15748:	e3a03000 	mov	r3, #0
   1574c:	e14b30b6 	strh	r3, [fp, #-6]

   printf("Im here\n");
   15750:	e59f01a4 	ldr	r0, [pc, #420]	; 158fc <getPIDcoefs+0x1e8>
   15754:	ebffec7b 	bl	10948 <puts@plt>

   if (pFilePointer == NULL)
   15758:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
   1575c:	e3530000 	cmp	r3, #0
   15760:	1a00004d 	bne	1589c <getPIDcoefs+0x188>
   {
      printf("Impossible to open file %s\n",config_file);
   15764:	e59f118c 	ldr	r1, [pc, #396]	; 158f8 <getPIDcoefs+0x1e4>
   15768:	e59f0190 	ldr	r0, [pc, #400]	; 15900 <getPIDcoefs+0x1ec>
   1576c:	ebffec6f 	bl	10930 <printf@plt>
      return(FALSE);
   15770:	e3a03000 	mov	r3, #0
   15774:	ea000058 	b	158dc <getPIDcoefs+0x1c8>
   {

      while (fscanf(pFilePointer, "%s", str ) != EOF)
      {

         if (str[0] == '#')
   15778:	e55b3080 	ldrb	r3, [fp, #-128]	; 0xffffff80
   1577c:	e3530023 	cmp	r3, #35	; 0x23
   15780:	1a000045 	bne	1589c <getPIDcoefs+0x188>
         {
            printf("And here Im trying: %s\n", str);
   15784:	e24b3080 	sub	r3, fp, #128	; 0x80
   15788:	e1a01003 	mov	r1, r3
   1578c:	e59f0170 	ldr	r0, [pc, #368]	; 15904 <getPIDcoefs+0x1f0>
   15790:	ebffec66 	bl	10930 <printf@plt>
            lLocal = fscanf(pFilePointer, "%u", &lLocalKoef);
   15794:	e24b3084 	sub	r3, fp, #132	; 0x84
   15798:	e1a02003 	mov	r2, r3
   1579c:	e59f1164 	ldr	r1, [pc, #356]	; 15908 <getPIDcoefs+0x1f4>
   157a0:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
   157a4:	ebffecb5 	bl	10a80 <__isoc99_fscanf@plt>
   157a8:	e1a03000 	mov	r3, r0
   157ac:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
            if (lLocal > 0)
   157b0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
   157b4:	e3530000 	cmp	r3, #0
   157b8:	0a000037 	beq	1589c <getPIDcoefs+0x188>
            {
               if (!strcmp(str, str_Kprop))
   157bc:	e24b3080 	sub	r3, fp, #128	; 0x80
   157c0:	e51b100c 	ldr	r1, [fp, #-12]
   157c4:	e1a00003 	mov	r0, r3
   157c8:	ebffeca3 	bl	10a5c <strcmp@plt>
   157cc:	e1a03000 	mov	r3, r0
   157d0:	e3530000 	cmp	r3, #0
   157d4:	1a00000b 	bne	15808 <getPIDcoefs+0xf4>
               {
                  lKprop = lLocalKoef;
   157d8:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
   157dc:	e59f2128 	ldr	r2, [pc, #296]	; 1590c <getPIDcoefs+0x1f8>
   157e0:	e5823000 	str	r3, [r2]
                  printf("lKprop: %u\n", lKprop);
   157e4:	e59f3120 	ldr	r3, [pc, #288]	; 1590c <getPIDcoefs+0x1f8>
   157e8:	e5933000 	ldr	r3, [r3]
   157ec:	e1a01003 	mov	r1, r3
   157f0:	e59f0118 	ldr	r0, [pc, #280]	; 15910 <getPIDcoefs+0x1fc>
   157f4:	ebffec4d 	bl	10930 <printf@plt>
                  iResult++;
   157f8:	e15b30b6 	ldrh	r3, [fp, #-6]
   157fc:	e2833001 	add	r3, r3, #1
   15800:	e14b30b6 	strh	r3, [fp, #-6]
   15804:	ea000024 	b	1589c <getPIDcoefs+0x188>
               }
               else if (!strcmp(str, str_Kint))
   15808:	e24b3080 	sub	r3, fp, #128	; 0x80
   1580c:	e51b1010 	ldr	r1, [fp, #-16]
   15810:	e1a00003 	mov	r0, r3
   15814:	ebffec90 	bl	10a5c <strcmp@plt>
   15818:	e1a03000 	mov	r3, r0
   1581c:	e3530000 	cmp	r3, #0
   15820:	1a00000b 	bne	15854 <getPIDcoefs+0x140>
               {
                  lKint = lLocalKoef;
   15824:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
   15828:	e59f20e4 	ldr	r2, [pc, #228]	; 15914 <getPIDcoefs+0x200>
   1582c:	e5823000 	str	r3, [r2]
                  printf("lKint: %u\n", lKint);
   15830:	e59f30dc 	ldr	r3, [pc, #220]	; 15914 <getPIDcoefs+0x200>
   15834:	e5933000 	ldr	r3, [r3]
   15838:	e1a01003 	mov	r1, r3
   1583c:	e59f00d4 	ldr	r0, [pc, #212]	; 15918 <getPIDcoefs+0x204>
   15840:	ebffec3a 	bl	10930 <printf@plt>
                  iResult++;
   15844:	e15b30b6 	ldrh	r3, [fp, #-6]
   15848:	e2833001 	add	r3, r3, #1
   1584c:	e14b30b6 	strh	r3, [fp, #-6]
   15850:	ea000011 	b	1589c <getPIDcoefs+0x188>
               }
               else if (!strcmp(str, str_Kdiff))
   15854:	e24b3080 	sub	r3, fp, #128	; 0x80
   15858:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
   1585c:	e1a00003 	mov	r0, r3
   15860:	ebffec7d 	bl	10a5c <strcmp@plt>
   15864:	e1a03000 	mov	r3, r0
   15868:	e3530000 	cmp	r3, #0
   1586c:	1a00000a 	bne	1589c <getPIDcoefs+0x188>
               {
                  lKdiff = lLocalKoef;
   15870:	e51b3084 	ldr	r3, [fp, #-132]	; 0xffffff7c
   15874:	e59f20a0 	ldr	r2, [pc, #160]	; 1591c <getPIDcoefs+0x208>
   15878:	e5823000 	str	r3, [r2]
                  printf("lKdiff: %u\n", lKdiff);
   1587c:	e59f3098 	ldr	r3, [pc, #152]	; 1591c <getPIDcoefs+0x208>
   15880:	e5933000 	ldr	r3, [r3]
   15884:	e1a01003 	mov	r1, r3
   15888:	e59f0090 	ldr	r0, [pc, #144]	; 15920 <getPIDcoefs+0x20c>
   1588c:	ebffec27 	bl	10930 <printf@plt>
                  iResult++;
   15890:	e15b30b6 	ldrh	r3, [fp, #-6]
   15894:	e2833001 	add	r3, r3, #1
   15898:	e14b30b6 	strh	r3, [fp, #-6]
      while (fscanf(pFilePointer, "%s", str ) != EOF)
   1589c:	e24b3080 	sub	r3, fp, #128	; 0x80
   158a0:	e1a02003 	mov	r2, r3
   158a4:	e59f1078 	ldr	r1, [pc, #120]	; 15924 <getPIDcoefs+0x210>
   158a8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
   158ac:	ebffec73 	bl	10a80 <__isoc99_fscanf@plt>
   158b0:	e1a03000 	mov	r3, r0
   158b4:	e3730001 	cmn	r3, #1
   158b8:	1affffae 	bne	15778 <getPIDcoefs+0x64>
            }

         }
      }

      fclose(pFilePointer);
   158bc:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
   158c0:	ebffec5f 	bl	10a44 <fclose@plt>
   }

   /// Exactly 3 coefficients should be read
   return(iResult == 3);
   158c4:	e15b30b6 	ldrh	r3, [fp, #-6]
   158c8:	e3530003 	cmp	r3, #3
   158cc:	03a03001 	moveq	r3, #1
   158d0:	13a03000 	movne	r3, #0
   158d4:	e6ef3073 	uxtb	r3, r3
   158d8:	e6ff3073 	uxth	r3, r3
}
   158dc:	e1a00003 	mov	r0, r3
   158e0:	e24bd004 	sub	sp, fp, #4
   158e4:	e8bd8800 	pop	{fp, pc}
   158e8:	000163f8 	.word	0x000163f8
   158ec:	00016400 	.word	0x00016400
   158f0:	00016408 	.word	0x00016408
   158f4:	000163a8 	.word	0x000163a8
   158f8:	00016410 	.word	0x00016410
   158fc:	00016424 	.word	0x00016424
   15900:	0001642c 	.word	0x0001642c
   15904:	00016448 	.word	0x00016448
   15908:	00016460 	.word	0x00016460
   1590c:	000271e8 	.word	0x000271e8
   15910:	00016464 	.word	0x00016464
   15914:	000271ec 	.word	0x000271ec
   15918:	00016470 	.word	0x00016470
   1591c:	000271f0 	.word	0x000271f0
   15920:	0001647c 	.word	0x0001647c
   15924:	00016488 	.word	0x00016488

00015928 <getDirectory>:
/*
 * Get directory
 *
 * */
uint16_t getDirectory(void)
{
   15928:	e92d4800 	push	{fp, lr}
   1592c:	e28db004 	add	fp, sp, #4
   15930:	e24dd018 	sub	sp, sp, #24
   char cwd[20];
   if (getcwd(cwd, sizeof(cwd)) != NULL) {
   15934:	e24b3018 	sub	r3, fp, #24
   15938:	e3a01014 	mov	r1, #20
   1593c:	e1a00003 	mov	r0, r3
   15940:	ebffec36 	bl	10a20 <getcwd@plt>
   15944:	e1a03000 	mov	r3, r0
   15948:	e3530000 	cmp	r3, #0
   1594c:	0a000005 	beq	15968 <getDirectory+0x40>
       printf("Current working dir: %s\n", cwd);
   15950:	e24b3018 	sub	r3, fp, #24
   15954:	e1a01003 	mov	r1, r3
   15958:	e59f0020 	ldr	r0, [pc, #32]	; 15980 <getDirectory+0x58>
   1595c:	ebffebf3 	bl	10930 <printf@plt>
   } else {
       perror("getcwd() error");
       return 1;
   }
   return 0;
   15960:	e3a03000 	mov	r3, #0
   15964:	ea000002 	b	15974 <getDirectory+0x4c>
       perror("getcwd() error");
   15968:	e59f0014 	ldr	r0, [pc, #20]	; 15984 <getDirectory+0x5c>
   1596c:	ebffebf8 	bl	10954 <perror@plt>
       return 1;
   15970:	e3a03001 	mov	r3, #1
}
   15974:	e1a00003 	mov	r0, r3
   15978:	e24bd004 	sub	sp, fp, #4
   1597c:	e8bd8800 	pop	{fp, pc}
   15980:	0001648c 	.word	0x0001648c
   15984:	000164a8 	.word	0x000164a8

00015988 <saveSettings>:

/* ---------------------------------------------------------------------------------
 * Settings to be saved
 * --------------------------------------------------------------------------------- */
uint16_t saveSettings(void)
{
   15988:	e92d4800 	push	{fp, lr}
   1598c:	e28db004 	add	fp, sp, #4
   15990:	e24dd008 	sub	sp, sp, #8

   FILE *fp;

   fp = fopen(config_file,"w");
   15994:	e59f10d8 	ldr	r1, [pc, #216]	; 15a74 <saveSettings+0xec>
   15998:	e59f00d8 	ldr	r0, [pc, #216]	; 15a78 <saveSettings+0xf0>
   1599c:	ebffebf5 	bl	10978 <fopen@plt>
   159a0:	e50b0008 	str	r0, [fp, #-8]
   if (fp)
   159a4:	e51b3008 	ldr	r3, [fp, #-8]
   159a8:	e3530000 	cmp	r3, #0
   159ac:	0a00002c 	beq	15a64 <saveSettings+0xdc>
   {
      fprintf(fp, "// The configurations K43 controller\r\n");
   159b0:	e51b3008 	ldr	r3, [fp, #-8]
   159b4:	e3a02026 	mov	r2, #38	; 0x26
   159b8:	e3a01001 	mov	r1, #1
   159bc:	e59f00b8 	ldr	r0, [pc, #184]	; 15a7c <saveSettings+0xf4>
   159c0:	ebffec0a 	bl	109f0 <fwrite@plt>
      fprintf(fp, "\n");
   159c4:	e51b1008 	ldr	r1, [fp, #-8]
   159c8:	e3a0000a 	mov	r0, #10
   159cc:	ebffec04 	bl	109e4 <fputc@plt>

      fprintf(fp, "\n#Kprop\r\n");
   159d0:	e51b3008 	ldr	r3, [fp, #-8]
   159d4:	e3a02009 	mov	r2, #9
   159d8:	e3a01001 	mov	r1, #1
   159dc:	e59f009c 	ldr	r0, [pc, #156]	; 15a80 <saveSettings+0xf8>
   159e0:	ebffec02 	bl	109f0 <fwrite@plt>
      fprintf(fp, "%u\r\n", lKprop);
   159e4:	e59f3098 	ldr	r3, [pc, #152]	; 15a84 <saveSettings+0xfc>
   159e8:	e5933000 	ldr	r3, [r3]
   159ec:	e1a02003 	mov	r2, r3
   159f0:	e59f1090 	ldr	r1, [pc, #144]	; 15a88 <saveSettings+0x100>
   159f4:	e51b0008 	ldr	r0, [fp, #-8]
   159f8:	ebffec0e 	bl	10a38 <fprintf@plt>

      fprintf(fp, "\n#Kint\r\n");
   159fc:	e51b3008 	ldr	r3, [fp, #-8]
   15a00:	e3a02008 	mov	r2, #8
   15a04:	e3a01001 	mov	r1, #1
   15a08:	e59f007c 	ldr	r0, [pc, #124]	; 15a8c <saveSettings+0x104>
   15a0c:	ebffebf7 	bl	109f0 <fwrite@plt>
      fprintf(fp, "%u\r\n", lKint);
   15a10:	e59f3078 	ldr	r3, [pc, #120]	; 15a90 <saveSettings+0x108>
   15a14:	e5933000 	ldr	r3, [r3]
   15a18:	e1a02003 	mov	r2, r3
   15a1c:	e59f1064 	ldr	r1, [pc, #100]	; 15a88 <saveSettings+0x100>
   15a20:	e51b0008 	ldr	r0, [fp, #-8]
   15a24:	ebffec03 	bl	10a38 <fprintf@plt>

      fprintf(fp, "\n#Kdiff\r\n");
   15a28:	e51b3008 	ldr	r3, [fp, #-8]
   15a2c:	e3a02009 	mov	r2, #9
   15a30:	e3a01001 	mov	r1, #1
   15a34:	e59f0058 	ldr	r0, [pc, #88]	; 15a94 <saveSettings+0x10c>
   15a38:	ebffebec 	bl	109f0 <fwrite@plt>
      fprintf(fp, "%u\r\n", lKdiff);
   15a3c:	e59f3054 	ldr	r3, [pc, #84]	; 15a98 <saveSettings+0x110>
   15a40:	e5933000 	ldr	r3, [r3]
   15a44:	e1a02003 	mov	r2, r3
   15a48:	e59f1038 	ldr	r1, [pc, #56]	; 15a88 <saveSettings+0x100>
   15a4c:	e51b0008 	ldr	r0, [fp, #-8]
   15a50:	ebffebf8 	bl	10a38 <fprintf@plt>

      fclose(fp);
   15a54:	e51b0008 	ldr	r0, [fp, #-8]
   15a58:	ebffebf9 	bl	10a44 <fclose@plt>
   {
      // Error
      return(1);
   }

   return(0);
   15a5c:	e3a03000 	mov	r3, #0
   15a60:	ea000000 	b	15a68 <saveSettings+0xe0>
      return(1);
   15a64:	e3a03001 	mov	r3, #1
}
   15a68:	e1a00003 	mov	r0, r3
   15a6c:	e24bd004 	sub	sp, fp, #4
   15a70:	e8bd8800 	pop	{fp, pc}
   15a74:	000164b8 	.word	0x000164b8
   15a78:	00016410 	.word	0x00016410
   15a7c:	000164bc 	.word	0x000164bc
   15a80:	000164e4 	.word	0x000164e4
   15a84:	000271e8 	.word	0x000271e8
   15a88:	000164f0 	.word	0x000164f0
   15a8c:	000164f8 	.word	0x000164f8
   15a90:	000271ec 	.word	0x000271ec
   15a94:	00016504 	.word	0x00016504
   15a98:	000271f0 	.word	0x000271f0

00015a9c <__udivsi3>:
   15a9c:	e2512001 	subs	r2, r1, #1
   15aa0:	012fff1e 	bxeq	lr
   15aa4:	3a000074 	bcc	15c7c <__udivsi3+0x1e0>
   15aa8:	e1500001 	cmp	r0, r1
   15aac:	9a00006b 	bls	15c60 <__udivsi3+0x1c4>
   15ab0:	e1110002 	tst	r1, r2
   15ab4:	0a00006c 	beq	15c6c <__udivsi3+0x1d0>
   15ab8:	e16f3f10 	clz	r3, r0
   15abc:	e16f2f11 	clz	r2, r1
   15ac0:	e0423003 	sub	r3, r2, r3
   15ac4:	e273301f 	rsbs	r3, r3, #31
   15ac8:	10833083 	addne	r3, r3, r3, lsl #1
   15acc:	e3a02000 	mov	r2, #0
   15ad0:	108ff103 	addne	pc, pc, r3, lsl #2
   15ad4:	e1a00000 	nop			; (mov r0, r0)
   15ad8:	e1500f81 	cmp	r0, r1, lsl #31
   15adc:	e0a22002 	adc	r2, r2, r2
   15ae0:	20400f81 	subcs	r0, r0, r1, lsl #31
   15ae4:	e1500f01 	cmp	r0, r1, lsl #30
   15ae8:	e0a22002 	adc	r2, r2, r2
   15aec:	20400f01 	subcs	r0, r0, r1, lsl #30
   15af0:	e1500e81 	cmp	r0, r1, lsl #29
   15af4:	e0a22002 	adc	r2, r2, r2
   15af8:	20400e81 	subcs	r0, r0, r1, lsl #29
   15afc:	e1500e01 	cmp	r0, r1, lsl #28
   15b00:	e0a22002 	adc	r2, r2, r2
   15b04:	20400e01 	subcs	r0, r0, r1, lsl #28
   15b08:	e1500d81 	cmp	r0, r1, lsl #27
   15b0c:	e0a22002 	adc	r2, r2, r2
   15b10:	20400d81 	subcs	r0, r0, r1, lsl #27
   15b14:	e1500d01 	cmp	r0, r1, lsl #26
   15b18:	e0a22002 	adc	r2, r2, r2
   15b1c:	20400d01 	subcs	r0, r0, r1, lsl #26
   15b20:	e1500c81 	cmp	r0, r1, lsl #25
   15b24:	e0a22002 	adc	r2, r2, r2
   15b28:	20400c81 	subcs	r0, r0, r1, lsl #25
   15b2c:	e1500c01 	cmp	r0, r1, lsl #24
   15b30:	e0a22002 	adc	r2, r2, r2
   15b34:	20400c01 	subcs	r0, r0, r1, lsl #24
   15b38:	e1500b81 	cmp	r0, r1, lsl #23
   15b3c:	e0a22002 	adc	r2, r2, r2
   15b40:	20400b81 	subcs	r0, r0, r1, lsl #23
   15b44:	e1500b01 	cmp	r0, r1, lsl #22
   15b48:	e0a22002 	adc	r2, r2, r2
   15b4c:	20400b01 	subcs	r0, r0, r1, lsl #22
   15b50:	e1500a81 	cmp	r0, r1, lsl #21
   15b54:	e0a22002 	adc	r2, r2, r2
   15b58:	20400a81 	subcs	r0, r0, r1, lsl #21
   15b5c:	e1500a01 	cmp	r0, r1, lsl #20
   15b60:	e0a22002 	adc	r2, r2, r2
   15b64:	20400a01 	subcs	r0, r0, r1, lsl #20
   15b68:	e1500981 	cmp	r0, r1, lsl #19
   15b6c:	e0a22002 	adc	r2, r2, r2
   15b70:	20400981 	subcs	r0, r0, r1, lsl #19
   15b74:	e1500901 	cmp	r0, r1, lsl #18
   15b78:	e0a22002 	adc	r2, r2, r2
   15b7c:	20400901 	subcs	r0, r0, r1, lsl #18
   15b80:	e1500881 	cmp	r0, r1, lsl #17
   15b84:	e0a22002 	adc	r2, r2, r2
   15b88:	20400881 	subcs	r0, r0, r1, lsl #17
   15b8c:	e1500801 	cmp	r0, r1, lsl #16
   15b90:	e0a22002 	adc	r2, r2, r2
   15b94:	20400801 	subcs	r0, r0, r1, lsl #16
   15b98:	e1500781 	cmp	r0, r1, lsl #15
   15b9c:	e0a22002 	adc	r2, r2, r2
   15ba0:	20400781 	subcs	r0, r0, r1, lsl #15
   15ba4:	e1500701 	cmp	r0, r1, lsl #14
   15ba8:	e0a22002 	adc	r2, r2, r2
   15bac:	20400701 	subcs	r0, r0, r1, lsl #14
   15bb0:	e1500681 	cmp	r0, r1, lsl #13
   15bb4:	e0a22002 	adc	r2, r2, r2
   15bb8:	20400681 	subcs	r0, r0, r1, lsl #13
   15bbc:	e1500601 	cmp	r0, r1, lsl #12
   15bc0:	e0a22002 	adc	r2, r2, r2
   15bc4:	20400601 	subcs	r0, r0, r1, lsl #12
   15bc8:	e1500581 	cmp	r0, r1, lsl #11
   15bcc:	e0a22002 	adc	r2, r2, r2
   15bd0:	20400581 	subcs	r0, r0, r1, lsl #11
   15bd4:	e1500501 	cmp	r0, r1, lsl #10
   15bd8:	e0a22002 	adc	r2, r2, r2
   15bdc:	20400501 	subcs	r0, r0, r1, lsl #10
   15be0:	e1500481 	cmp	r0, r1, lsl #9
   15be4:	e0a22002 	adc	r2, r2, r2
   15be8:	20400481 	subcs	r0, r0, r1, lsl #9
   15bec:	e1500401 	cmp	r0, r1, lsl #8
   15bf0:	e0a22002 	adc	r2, r2, r2
   15bf4:	20400401 	subcs	r0, r0, r1, lsl #8
   15bf8:	e1500381 	cmp	r0, r1, lsl #7
   15bfc:	e0a22002 	adc	r2, r2, r2
   15c00:	20400381 	subcs	r0, r0, r1, lsl #7
   15c04:	e1500301 	cmp	r0, r1, lsl #6
   15c08:	e0a22002 	adc	r2, r2, r2
   15c0c:	20400301 	subcs	r0, r0, r1, lsl #6
   15c10:	e1500281 	cmp	r0, r1, lsl #5
   15c14:	e0a22002 	adc	r2, r2, r2
   15c18:	20400281 	subcs	r0, r0, r1, lsl #5
   15c1c:	e1500201 	cmp	r0, r1, lsl #4
   15c20:	e0a22002 	adc	r2, r2, r2
   15c24:	20400201 	subcs	r0, r0, r1, lsl #4
   15c28:	e1500181 	cmp	r0, r1, lsl #3
   15c2c:	e0a22002 	adc	r2, r2, r2
   15c30:	20400181 	subcs	r0, r0, r1, lsl #3
   15c34:	e1500101 	cmp	r0, r1, lsl #2
   15c38:	e0a22002 	adc	r2, r2, r2
   15c3c:	20400101 	subcs	r0, r0, r1, lsl #2
   15c40:	e1500081 	cmp	r0, r1, lsl #1
   15c44:	e0a22002 	adc	r2, r2, r2
   15c48:	20400081 	subcs	r0, r0, r1, lsl #1
   15c4c:	e1500001 	cmp	r0, r1
   15c50:	e0a22002 	adc	r2, r2, r2
   15c54:	20400001 	subcs	r0, r0, r1
   15c58:	e1a00002 	mov	r0, r2
   15c5c:	e12fff1e 	bx	lr
   15c60:	03a00001 	moveq	r0, #1
   15c64:	13a00000 	movne	r0, #0
   15c68:	e12fff1e 	bx	lr
   15c6c:	e16f2f11 	clz	r2, r1
   15c70:	e262201f 	rsb	r2, r2, #31
   15c74:	e1a00230 	lsr	r0, r0, r2
   15c78:	e12fff1e 	bx	lr
   15c7c:	e3500000 	cmp	r0, #0
   15c80:	13e00000 	mvnne	r0, #0
   15c84:	ea00004b 	b	15db8 <__aeabi_idiv0>

00015c88 <__aeabi_uidivmod>:
   15c88:	e3510000 	cmp	r1, #0
   15c8c:	0afffffa 	beq	15c7c <__udivsi3+0x1e0>
   15c90:	e92d4003 	push	{r0, r1, lr}
   15c94:	ebffff80 	bl	15a9c <__udivsi3>
   15c98:	e8bd4006 	pop	{r1, r2, lr}
   15c9c:	e0030092 	mul	r3, r2, r0
   15ca0:	e0411003 	sub	r1, r1, r3
   15ca4:	e12fff1e 	bx	lr

00015ca8 <__aeabi_ldivmod>:
   15ca8:	e3530000 	cmp	r3, #0
   15cac:	03520000 	cmpeq	r2, #0
   15cb0:	1a000007 	bne	15cd4 <__aeabi_ldivmod+0x2c>
   15cb4:	e3510000 	cmp	r1, #0
   15cb8:	b3a01102 	movlt	r1, #-2147483648	; 0x80000000
   15cbc:	b3a00000 	movlt	r0, #0
   15cc0:	ba000002 	blt	15cd0 <__aeabi_ldivmod+0x28>
   15cc4:	03500000 	cmpeq	r0, #0
   15cc8:	13e01102 	mvnne	r1, #-2147483648	; 0x80000000
   15ccc:	13e00000 	mvnne	r0, #0
   15cd0:	ea000038 	b	15db8 <__aeabi_idiv0>
   15cd4:	e24dd008 	sub	sp, sp, #8
   15cd8:	e92d6000 	push	{sp, lr}
   15cdc:	e3510000 	cmp	r1, #0
   15ce0:	ba000006 	blt	15d00 <__aeabi_ldivmod+0x58>
   15ce4:	e3530000 	cmp	r3, #0
   15ce8:	ba000011 	blt	15d34 <__aeabi_ldivmod+0x8c>
   15cec:	eb000035 	bl	15dc8 <__udivmoddi4>
   15cf0:	e59de004 	ldr	lr, [sp, #4]
   15cf4:	e28dd008 	add	sp, sp, #8
   15cf8:	e8bd000c 	pop	{r2, r3}
   15cfc:	e12fff1e 	bx	lr
   15d00:	e2700000 	rsbs	r0, r0, #0
   15d04:	e0c11081 	sbc	r1, r1, r1, lsl #1
   15d08:	e3530000 	cmp	r3, #0
   15d0c:	ba000011 	blt	15d58 <__aeabi_ldivmod+0xb0>
   15d10:	eb00002c 	bl	15dc8 <__udivmoddi4>
   15d14:	e59de004 	ldr	lr, [sp, #4]
   15d18:	e28dd008 	add	sp, sp, #8
   15d1c:	e8bd000c 	pop	{r2, r3}
   15d20:	e2700000 	rsbs	r0, r0, #0
   15d24:	e0c11081 	sbc	r1, r1, r1, lsl #1
   15d28:	e2722000 	rsbs	r2, r2, #0
   15d2c:	e0c33083 	sbc	r3, r3, r3, lsl #1
   15d30:	e12fff1e 	bx	lr
   15d34:	e2722000 	rsbs	r2, r2, #0
   15d38:	e0c33083 	sbc	r3, r3, r3, lsl #1
   15d3c:	eb000021 	bl	15dc8 <__udivmoddi4>
   15d40:	e59de004 	ldr	lr, [sp, #4]
   15d44:	e28dd008 	add	sp, sp, #8
   15d48:	e8bd000c 	pop	{r2, r3}
   15d4c:	e2700000 	rsbs	r0, r0, #0
   15d50:	e0c11081 	sbc	r1, r1, r1, lsl #1
   15d54:	e12fff1e 	bx	lr
   15d58:	e2722000 	rsbs	r2, r2, #0
   15d5c:	e0c33083 	sbc	r3, r3, r3, lsl #1
   15d60:	eb000018 	bl	15dc8 <__udivmoddi4>
   15d64:	e59de004 	ldr	lr, [sp, #4]
   15d68:	e28dd008 	add	sp, sp, #8
   15d6c:	e8bd000c 	pop	{r2, r3}
   15d70:	e2722000 	rsbs	r2, r2, #0
   15d74:	e0c33083 	sbc	r3, r3, r3, lsl #1
   15d78:	e12fff1e 	bx	lr

00015d7c <__aeabi_uldivmod>:
   15d7c:	e3530000 	cmp	r3, #0
   15d80:	03520000 	cmpeq	r2, #0
   15d84:	1a000004 	bne	15d9c <__aeabi_uldivmod+0x20>
   15d88:	e3510000 	cmp	r1, #0
   15d8c:	03500000 	cmpeq	r0, #0
   15d90:	13e01000 	mvnne	r1, #0
   15d94:	13e00000 	mvnne	r0, #0
   15d98:	ea000006 	b	15db8 <__aeabi_idiv0>
   15d9c:	e24dd008 	sub	sp, sp, #8
   15da0:	e92d6000 	push	{sp, lr}
   15da4:	eb000007 	bl	15dc8 <__udivmoddi4>
   15da8:	e59de004 	ldr	lr, [sp, #4]
   15dac:	e28dd008 	add	sp, sp, #8
   15db0:	e8bd000c 	pop	{r2, r3}
   15db4:	e12fff1e 	bx	lr

00015db8 <__aeabi_idiv0>:
   15db8:	e92d4002 	push	{r1, lr}
   15dbc:	e3a00008 	mov	r0, #8
   15dc0:	ebffeafe 	bl	109c0 <raise@plt>
   15dc4:	e8bd8002 	pop	{r1, pc}

00015dc8 <__udivmoddi4>:
   15dc8:	e1510003 	cmp	r1, r3
   15dcc:	01500002 	cmpeq	r0, r2
   15dd0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15dd4:	e1a04000 	mov	r4, r0
   15dd8:	33a00000 	movcc	r0, #0
   15ddc:	e1a05001 	mov	r5, r1
   15de0:	e59de024 	ldr	lr, [sp, #36]	; 0x24
   15de4:	31a01000 	movcc	r1, r0
   15de8:	3a00003d 	bcc	15ee4 <__udivmoddi4+0x11c>
   15dec:	e3530000 	cmp	r3, #0
   15df0:	016fcf12 	clzeq	ip, r2
   15df4:	116fcf13 	clzne	ip, r3
   15df8:	028cc020 	addeq	ip, ip, #32
   15dfc:	e3550000 	cmp	r5, #0
   15e00:	016f1f14 	clzeq	r1, r4
   15e04:	02811020 	addeq	r1, r1, #32
   15e08:	116f1f15 	clzne	r1, r5
   15e0c:	e04cc001 	sub	ip, ip, r1
   15e10:	e24ca020 	sub	sl, ip, #32
   15e14:	e1a09c13 	lsl	r9, r3, ip
   15e18:	e26cb020 	rsb	fp, ip, #32
   15e1c:	e1899a12 	orr	r9, r9, r2, lsl sl
   15e20:	e1899b32 	orr	r9, r9, r2, lsr fp
   15e24:	e1a08c12 	lsl	r8, r2, ip
   15e28:	e1550009 	cmp	r5, r9
   15e2c:	01540008 	cmpeq	r4, r8
   15e30:	33a00000 	movcc	r0, #0
   15e34:	31a01000 	movcc	r1, r0
   15e38:	3a000005 	bcc	15e54 <__udivmoddi4+0x8c>
   15e3c:	e3a00001 	mov	r0, #1
   15e40:	e0544008 	subs	r4, r4, r8
   15e44:	e1a01a10 	lsl	r1, r0, sl
   15e48:	e1811b30 	orr	r1, r1, r0, lsr fp
   15e4c:	e1a00c10 	lsl	r0, r0, ip
   15e50:	e0c55009 	sbc	r5, r5, r9
   15e54:	e35c0000 	cmp	ip, #0
   15e58:	0a000021 	beq	15ee4 <__udivmoddi4+0x11c>
   15e5c:	e1a060a8 	lsr	r6, r8, #1
   15e60:	e1866f89 	orr	r6, r6, r9, lsl #31
   15e64:	e1a070a9 	lsr	r7, r9, #1
   15e68:	e1a0200c 	mov	r2, ip
   15e6c:	ea000007 	b	15e90 <__udivmoddi4+0xc8>
   15e70:	e0543006 	subs	r3, r4, r6
   15e74:	e0c58007 	sbc	r8, r5, r7
   15e78:	e0933003 	adds	r3, r3, r3
   15e7c:	e0a88008 	adc	r8, r8, r8
   15e80:	e2934001 	adds	r4, r3, #1
   15e84:	e2a85000 	adc	r5, r8, #0
   15e88:	e2522001 	subs	r2, r2, #1
   15e8c:	0a000006 	beq	15eac <__udivmoddi4+0xe4>
   15e90:	e1550007 	cmp	r5, r7
   15e94:	01540006 	cmpeq	r4, r6
   15e98:	2afffff4 	bcs	15e70 <__udivmoddi4+0xa8>
   15e9c:	e0944004 	adds	r4, r4, r4
   15ea0:	e0a55005 	adc	r5, r5, r5
   15ea4:	e2522001 	subs	r2, r2, #1
   15ea8:	1afffff8 	bne	15e90 <__udivmoddi4+0xc8>
   15eac:	e1a03c34 	lsr	r3, r4, ip
   15eb0:	e1833b15 	orr	r3, r3, r5, lsl fp
   15eb4:	e1a02c35 	lsr	r2, r5, ip
   15eb8:	e1833a35 	orr	r3, r3, r5, lsr sl
   15ebc:	e0900004 	adds	r0, r0, r4
   15ec0:	e1a04003 	mov	r4, r3
   15ec4:	e1a03c12 	lsl	r3, r2, ip
   15ec8:	e1833a14 	orr	r3, r3, r4, lsl sl
   15ecc:	e1a0cc14 	lsl	ip, r4, ip
   15ed0:	e1833b34 	orr	r3, r3, r4, lsr fp
   15ed4:	e0a11005 	adc	r1, r1, r5
   15ed8:	e050000c 	subs	r0, r0, ip
   15edc:	e1a05002 	mov	r5, r2
   15ee0:	e0c11003 	sbc	r1, r1, r3
   15ee4:	e35e0000 	cmp	lr, #0
   15ee8:	11ce40f0 	strdne	r4, [lr]
   15eec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

00015ef0 <__libc_csu_init>:
   15ef0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   15ef4:	e1a07000 	mov	r7, r0
   15ef8:	e59f6048 	ldr	r6, [pc, #72]	; 15f48 <__libc_csu_init+0x58>
   15efc:	e59f5048 	ldr	r5, [pc, #72]	; 15f4c <__libc_csu_init+0x5c>
   15f00:	e08f6006 	add	r6, pc, r6
   15f04:	e08f5005 	add	r5, pc, r5
   15f08:	e0466005 	sub	r6, r6, r5
   15f0c:	e1a08001 	mov	r8, r1
   15f10:	e1a09002 	mov	r9, r2
   15f14:	ebffea71 	bl	108e0 <_init>
   15f18:	e1b06146 	asrs	r6, r6, #2
   15f1c:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
   15f20:	e3a04000 	mov	r4, #0
   15f24:	e2844001 	add	r4, r4, #1
   15f28:	e4953004 	ldr	r3, [r5], #4
   15f2c:	e1a02009 	mov	r2, r9
   15f30:	e1a01008 	mov	r1, r8
   15f34:	e1a00007 	mov	r0, r7
   15f38:	e12fff33 	blx	r3
   15f3c:	e1560004 	cmp	r6, r4
   15f40:	1afffff7 	bne	15f24 <__libc_csu_init+0x34>
   15f44:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
   15f48:	00010ffc 	.word	0x00010ffc
   15f4c:	00010ff4 	.word	0x00010ff4

00015f50 <__libc_csu_fini>:
   15f50:	e12fff1e 	bx	lr

Disassembly of section .fini:

00015f54 <_fini>:
   15f54:	e92d4008 	push	{r3, lr}
   15f58:	e8bd8008 	pop	{r3, pc}
